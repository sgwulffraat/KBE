#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import functools
import os
import sys
from collections import defaultdict
from inspect import isgeneratorfunction
from threading import Lock


def is_frozen():
    """Returns whether we are frozen via py2exe.
    This will affect how we find out where we are located."""
    return hasattr(sys, "frozen")


def executable_dir():
    """ This will get us the program's directory,
    even if we are frozen using py2exe"""

    if is_frozen():
        return os.path.dirname(sys.executable)

    return os.path.dirname(__file__)


def get_module_dir_when_frozen(fq_module_name):
    """Get the absolute directory path of th ``fq_module_name``.

    :param str fq_module_name: fully qualified module name
    :return: str
    """
    name_parts = fq_module_name.split('.')

    pkg_path = executable_dir()

    return os.path.join(pkg_path, os.path.join(*name_parts[:-1]))


_CONCURRENCY_LOCKS = defaultdict(Lock)
_CONCURRENTLY_EXECUTED = {}


class ConcurrencyConflict(RuntimeError):
    """Raised when one function is called while another, which cannot run
    concurrently, is still active.
    """

    MSG_PATTERN = ("Cannot execute {fn!r}! Another function guarded "
                   "with the same key ({key}), and thus cannot "
                   "run concurrently with this one, is already "
                   "running: {active_fn!r}.")

    def __init__(self, key, fn, active_fn, msg=None) -> None:
        msg = msg or self.MSG_PATTERN
        formatted_msg = msg.format(fn=fn, key=key, active_fn=active_fn)
        super().__init__(formatted_msg)


def concurrency_guard(key):
    """Guard the decorated function against running concurrently
    with functions marked with the same `key`.

    The guard will keep on guarding from acquiring the first item
    until the generator exits. Normal functions will acquire the guard
    immediately when calling the function.

    This guarantee only exists within the same process space.
    """
    def _concurrency_guard(fn):
        def wrap(*args, **kwargs):  # this is executed every call
            lock = _CONCURRENCY_LOCKS[key]

            is_generator = isgeneratorfunction(fn)
            if is_generator:
                # we need to wrap the generator so we can return
                # now, but keep the context open until the
                # generator is finished
                def yield_result():
                    if lock.acquire(blocking=False):
                        _CONCURRENTLY_EXECUTED[key] = fn
                        try:
                            # don't return here to keep the lazy evaluation of
                            # a generator (acquire lock only when used)
                            yield from fn(*args, **kwargs)
                        finally:
                            del _CONCURRENTLY_EXECUTED[key]
                            lock.release()
                    else:
                        active_fn = _CONCURRENTLY_EXECUTED.get(key)
                        raise ConcurrencyConflict(key, fn, active_fn)
                return yield_result()
            else:  # normal result -> return
                if lock.acquire(blocking=False):
                    _CONCURRENTLY_EXECUTED[key] = fn
                    try:
                        return fn(*args, **kwargs)
                    finally:
                        del _CONCURRENTLY_EXECUTED[key]
                        lock.release()
                else:
                    active_fn = _CONCURRENTLY_EXECUTED.get(key)
                    raise ConcurrencyConflict(key, fn, active_fn)

        wrapper = functools.wraps(fn)(wrap)
        return wrapper

    return _concurrency_guard  # the decorator

