#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""Utilities from parapy.geom.generic"""

import math
import typing

from parapy.core import all_map, is_real_number
from parapy.geom.generic.globs import (
    DIM_KEY, DIM_VALID, KEY_AXIS_KEY, KEY_DIM, KEY_MAIN_KEY, KEY_OPP_KEY,
    KEY_PERP_KEY, KEY_SIGN, KEY_VALID, KEY_VECTOR, KEY_VECTOR_TUPLE)
from parapy.geom.globs import CONFIGURATION

if typing.TYPE_CHECKING:
    from parapy.geom.generic.positioning import Vector


# ---- direction keyword utilities ----
def key_to_main_key(key):
    """Returns the main direction key for various synonyms in directions.
    
    Args:
        key (str): named direction key
        
    Returns:
        str
        
    Raises:
        KeyError: if direction key is invalid
        
    Example:
    >>>key_to_main_key('top')
    'z'
    >>>key_to_main_key('front')
    'y_'
    """
    try:
        return KEY_MAIN_KEY[key]
    except KeyError:
        msg = "{!r} is not a valid direction key. Use one of: {!r}"
        raise KeyError(msg.format(key, KEY_VALID))


def signed_direction_value(key, value):
    """Returns *signed* value.
    
     Args:
        key (str): named direction key
        value (Number): the value to be signed. We sort of expect a positive number here.

    Returns:
        str

    Raises:
        KeyError: if direction key is invalid

    Example:
    >>>signed_direction_value('right', 2)
    2    
    >>>signed_direction_value('left', 2)
    -2"""
    sign = KEY_SIGN[key_to_main_key(key)]
    return sign * value


def key_to_axis(key):
    """Returns the axis keyword associated to direction keyword ``key``.
    
    Args:
        key (str): named direction key

    Returns:
        str

    Raises:
        KeyError: if direction key is invalid
    
    Usage:
    >>>key_to_axis('right')
    'x'    
    >>>key_to_axis('y_')
    'y'"""
    return KEY_AXIS_KEY[key_to_main_key(key)]


def opposite_key(key):
    """Returns the opposite direction keyword of given direction keyword ``key``.
    
    Args:
        key (str): named direction key

    Returns:
        str

    Raises:
        KeyError: if direction key is invalid
    
    Usage:
    >>>opposite_key('right')
    'x_'    
    >>>opposite_key('y_')
    'y'"""
    return KEY_OPP_KEY[key_to_main_key(key)]


def key_to_vector_tuple(key):
    """Returns the vector tuple corresponding to direction keyword ``key``.
    
    Args:
        key (str): named direction key

    Returns:
        tuple (3 numbers)

    Raises:
        KeyError: if direction key is invalid
    
    Usage:
    >>>key_to_vector_tuple('right')
    (1,0,0)
    >>>key_to_vector_tuple('y_')
    (0,-1,0)"""
    return KEY_VECTOR_TUPLE[key_to_main_key(key)]


def key_to_vector_key(key):
    """Returns the vector tuple corresponding to direction keyword ``key``.
    
    Args:
        key (str): named direction key

    Returns:
        tuple (3 numbers)

    Raises:
        KeyError: if direction key is invalid
    
    Usage:
    >>>key_to_vector_key('right')
    'Vx'
    >>>key_to_vector_key('y_')
    'Vy_'"""
    return KEY_VECTOR[key_to_main_key(key)]


def key_to_perp_key(key):
    """Returns the main perpendicular direction key. Used for Orientation/Position.align, where
    rotation axis is ambiguous, because normal vector is_zero. The perpendicular axis, is the one
    principle axis normal to the principle plane that ``key`` is in. So, 'x' is in 'XY' plane, so
    perpendicular key is 'z'. Likely, 'z' is in 'XZ' plane, so perpendicular key is 'y'. 

    Args:
        key (str): named direction key

    Returns:
        str

    Raises:
        KeyError: if direction key is invalid
    
    Example:
    >>>key_to_perp_key('x')
    'z'    
    >>>key_to_perp_key('right')
    'z'
    """
    return KEY_PERP_KEY[key_to_main_key(key)]


def key_to_dim(key):
    """Returns the dimension key associated to the named direction key.
    
    Args:
        key (str): named direction key

    Returns:
        str

    Raises:
        KeyError: if direction key is invalid
    
    Example:
    >>>key_to_dim('rear')
    'length'
    >>>key_to_dim('z_')
    'height'
    """
    return KEY_DIM[key_to_main_key(key)]


def dim_to_key(key):
    """Returns the main direction key associated to the named dimension ``dim``.
    
    Args:
        dim (str)
    
    Returns:
        str

    Raises:
        KeyError: if direction key is invalid
    
    Example:
    >>>key_to_dim('rear')
    'length'
    >>>key_to_dim('z_')
    'height'
    """
    try:
        return DIM_KEY[key]
    except:
        raise KeyError("'%s' is not a valid dimension key. Use one of: %s" % (key, DIM_VALID))


# ==================================================================================================
# Vector and Matrix utilities
# ==================================================================================================
def is_almost_equal(num1, num2, tol=None):
    """Test is two numbers are equal within tolerance ``tol`` (<=). Tolerance defaults to 
    ``CONFIGURATION['tolerance']``.
    
    Arguments:
        num1 (number): first number
        num2 (number): second number
        tol (number): tolerance value >= 0.
    
    Returns:
        bool
    """
    tol = CONFIGURATION['tolerance'] if tol is None else abs(tol)
    return abs(num2 - num1) <= tol


def is_almost_equal_vec(vec1, vec2, tol=None):
    tol = CONFIGURATION['tolerance'] if tol is None else abs(tol)
    return all(is_almost_equal(x, y, tol) for x, y in zip(vec1, vec2))


def is_almost_equal_mat(mat1, mat2, tol=None):
    tol = CONFIGURATION['tolerance'] if tol is None else abs(tol)
    return all(is_almost_equal(x, y, tol) for w, z in zip(mat1, mat2) for x, y in zip(w, z))


def _matrix_times_matrix(matrix1, matrix2):
    """
    @return: list
    NxM matrix times MxP matrix ==> NxP matrix.
    vector is interpolated as a (column) vector
    TODO: check for ranks?
    """
    zip_b = list(zip(*matrix2))
    return [[sum(ele_a * ele_b for ele_a, ele_b in zip(row_a, col_b)) for col_b in zip_b] for row_a in matrix1]


def _matrix_times_vector(matrix, vector):
    """
    @return: list of lists    
    NxM matrix times MxP vector ==> NxP vector.
    vector is interpolated as a column vector
    TODO: check for ranks?
    TODO: check vector type?
    """
    return [sum(ele_a * ele_b for ele_a, ele_b in zip(row_a, vector)) for row_a in matrix]


def _vector_times_matrix(vector, matrix):
    """
    @return: list of lists
    NxM vector times MxP matrix ==> NxP matrix.
    vector is interpolated as a row vector
    TODO: check for ranks?
    TODO: check vector type?
    """
    zip_b = list(zip(*matrix))
    return [sum(ele_a * ele_b for ele_b in col_b) for col_b, ele_a in zip(zip_b, vector)]


def _transpose(matrix):
    """
    @return: List of lists.
    Returns transpose of matrix (list/tuple of list tuple)
    """
    return list(zip(*matrix))


def _invert_3x3_matrix(matrix):
    """Return the inverse of the given 3x3 matrix.

    :param typing.Sequence[typing.Sequence] matrix: 3x3 matrix to be inverted
    :rtype: typing.Sequence[typing.Sequence]
    """
    try:
        (a1, a2, a3), (b1, b2, b3), (c1, c2, c3) = matrix
    except ValueError:
        msg = "{} is not a 3x3 matrix"
        raise TypeError(msg.format(matrix))

    # calculate the determinant; if it's zero the matrix has no inverse
    det = a1 * b2 * c3 - a1 * b3 * c2 + a2 * b3 * c1 - a2 * b1 * c3 + a3 * b1 * c2 - a3 * b2 * c1
    if is_almost_equal(det, 0):
        msg = "Matrix {} has no inverse."
        raise ValueError(msg.format(matrix))

    f = 1.0 / det
    inverse = [
        [f * (b2 * c3 - c2 * b3), f * (a3 * c2 - c3 * a2), f * (a2 * b3 - b2 * a3)],
        [f * (b3 * c1 - c3 * b1), f * (a1 * c3 - c1 * a3), f * (a3 * b1 - b3 * a1)],
        [f * (b1 * c2 - c1 * b2), f * (a2 * c1 - c2 * a1), f * (a1 * b2 - b1 * a2)]]
    return inverse


def _magnitude(seq):
    """
    Returns the magnitude of a vector

    Arguments:
        seq (sequence of numbers)

    Returns:
        number.
    """
    return math.sqrt(sum([x ** 2 for x in seq]))


def _normalize(seq):
    """
    Returns the normalize vector.

    Arguments:
        seq (sequence of three numbers)

    Returns:
        tuple of three numbers
    """
    mag = _magnitude(seq)
    return (seq[0] / mag, seq[1] / mag, seq[2] / mag)


def _cross_3d_vectors(seq1, seq2):
    """
    Given two iterables ``seq1`` and ``seq2`` of length 3, returns cross product.
    
    Arguments:
        seq1 (sequence of three numbers): first vector
        seq2 (sequence of three numbers): second vector

    Returns:
        tuple of three numbers
    """
    return (seq1[1] * seq2[2] - seq1[2] * seq2[1],
            seq1[2] * seq2[0] - seq1[0] * seq2[2],
            seq1[0] * seq2[1] - seq1[1] * seq2[0])


def vector_angle(v1: 'Vector', v2: 'Vector', inputs_normalized=False) -> float:
    """The angle in radians between Vector ``v1`` and Vector ``v2``.

    :param inputs_normalized: If ``v1`` and ``v2`` are already normalized,
        this can be set to ``True`` as an optimization.
    """
    if inputs_normalized:
        dot = v1 * v2
    else:
        dot = v1.normalize * v2.normalize

    try:
        angle = math.acos(dot)
    # Due to floating point precision the dot value may fall outside the
    # valid range of acos: -1.0 <= X <= 1.0; which would raise a
    # ValueError: "math domain error".
    except ValueError:
        if dot > 1.:
            angle = 0.
        elif dot < -1.:
            angle = math.pi
        else:
            raise

    return angle


def is_3dpoint(obj):
    """Return :py:`True` if ``obj`` represents a 3D point

    Usage:

    >>> from parapy.geom.generic.utilities import is_3dpoint
    >>> from parapy.geom import Point
    >>> is_3dpoint((1, 2, 3))
    True
    >>> is_3dpoint((1.1, 2.2, 3.3))
    True
    >>> is_3dpoint(Point(1, 2, 3))
    True
    >>> is_3dpoint((1, 2))
    False
    >>> is_3dpoint("not a point")
    False

    :param obj: Any Python object.
    :rtype: bool
    """
    try:
        _ = obj.__len__
    except AttributeError:
        return False  # It does not have a length
    else:
        return len(obj) == 3 and all_map(is_real_number, obj)


def plane_line_intersection(plane_point, plane_normal, line_point,
                            line_direction, tolerance=1.0e-7):
    """Return the intersection point between a plane and a line or :py:`None`
    if the line is parallel to the plane. The plane is defined by
    ``plane_point`` and ``plane_normal``. The line is defined by
    ``line_point`` and ``line_direction``. ``tolerance`` defines the threshold
    for

    >>> from parapy.geom import Point, Vector
    >>> plane_line_intersection(Point(0, 0, 0), Vector(0, 0, 1),
    ...                         Point(1, 1, 1), Vector(0, 0, 1))
    Point(1, 1, 0)
    >>> plane_line_intersection(Point(0, 0, 0), Vector(0, 0, 1),
    ...                         Point(1, 1, 1), Vector(1, 0, 0)) is None
    True
    >>> # default tolerance illustrated
    >>> plane_line_intersection(Point(0, 0, 0), Vector(0, 0, 1),
    ...                         Point(1, 1, 1), Vector(1, 0, 1e-8)) is None
    True
    >>> # custom tolerance illustrated
    >>> plane_line_intersection(Point(0, 0, 0), Vector(0, 0, 1),
    ...                         Point(1, 1, 1), Vector(1, 0, 1e-8),
    ...                         tolerance=1e-9) is None
    False

    :param parapy.geom.Point plane_point: Point on the Plane
    :param parapy.geom.Vector plane_normal: Normal Vector of the plane
    :param parapy.geom.Point line_point: Point on the line intersecting with
        the plane
    :param parapy.geom.Vector line_direction: Direction of the line
        intersecting with the plane
    :param float tolerance: tolerance below which ``plane_normal`` and
        ``line_direction`` are considered perpendicular and do not intersect.
    :rtype: parapy.geom.Point | None
    """
    dot = plane_normal * line_direction

    if abs(dot) < tolerance:
        return None

    d = (plane_point - line_point) * plane_normal / dot
    return line_point + (line_direction * d)


class PlaneNormalFromPointsException(RuntimeError):
    pass


def plane_normal_from_points(points, tolerance=1e-7):
    """Give the normal vector of the plane in which ``points`` lies given a
    ``tolerance``. Raise in case ``points`` are not in a plane or aren't
    appropriate to derive a plane normal (e.g. too few, all on a line).

    >>> from parapy.geom import Point
    >>> points = [Point(0, 0, 0), Point(1, 0, 0), Point(1, 1, 0)]
    >>> plane_normal_from_points(points)
    Vector(0.0, 0.0, 1.0)

    :param collection.Sequence[parapy.geom.Point] points:
    :param float tolerance: tolerance for finding the plane.
    :rtype: parapy.geom.Vector
    :returns plane normal unit vector
    :raises PlaneNormalFromPointsException: if ``points`` aren't in a plane,
        or don't allow for finding a plane, either because there are too few
        points or they are on top of each other, or are within a line.
    """
    if len(points) < 3:
        msg = "Need at least 3 points to derive a plane normal"
        raise PlaneNormalFromPointsException(msg)
    pt_ref = points[0]
    v_ref = None
    normal = None
    for pt in points[1:]:
        v = pt - pt_ref
        if v.is_zero_tol(tol=tolerance):  # on top of each other
            continue
        if v_ref is None:
            v_ref = v
            continue
        if normal is None:
            candidate_normal = v_ref.cross(v)
            if candidate_normal.is_zero_tol(tol=tolerance):
                continue
            else:
                normal = candidate_normal
        else:
            new_normal = v_ref.cross(v)
            if new_normal.is_parallel(normal, tol=tolerance):
                continue
            else:
                msg = ("Points are not in a plane. If close, consider "
                       "increasing tolerance.")
                raise PlaneNormalFromPointsException(msg)
    if normal is None:
        msg = ("Plane normal couldn't be resolved because points "
               "are in a line (or on top of each other)")
        raise PlaneNormalFromPointsException(msg)
    return normal.normalized
