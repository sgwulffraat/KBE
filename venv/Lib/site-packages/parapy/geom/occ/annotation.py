#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import os
import warnings
from math import radians, tan

from OCC.wrapper.Aspect import (
    Aspect_SequenceOfColor, Aspect_TOCSD_AUTO, Aspect_TOCSD_USER,
    Aspect_TOCSP_CENTER, Aspect_TOCSP_LEFT, Aspect_TOCSP_NONE,
    Aspect_TOCSP_RIGHT, Aspect_TOTP_BOTTOM, Aspect_TOTP_CENTER,
    Aspect_TOTP_LEFT, Aspect_TOTP_LEFT_LOWER, Aspect_TOTP_LEFT_UPPER,
    Aspect_TOTP_RIGHT, Aspect_TOTP_RIGHT_LOWER, Aspect_TOTP_RIGHT_UPPER,
    Aspect_TOTP_TOP)
from OCC.wrapper.Font import (
    BRepFont, Font_BRepTextBuilder, Font_FontMgr)
from OCC.wrapper.Graphic3d import (
    Graphic3d_HTA_CENTER, Graphic3d_HTA_LEFT, Graphic3d_HTA_RIGHT,
    Graphic3d_TMF_2d, Graphic3d_TransformPers, Graphic3d_VTA_BOTTOM,
    Graphic3d_VTA_CENTER, Graphic3d_VTA_TOP, Graphic3d_VTA_TOPFIRSTLINE,
    Graphic3d_Vec2i, Graphic3d_ZLayerId_TopOSD)
from OCC.wrapper.NCollection import NCollection_Utf8String
from OCC.wrapper.TColStd import TColStd_SequenceOfExtendedString
from OCC.wrapper.TCollection import (
    TCollection_AsciiString,
    TCollection_ExtendedString, TCollection_HAsciiString)
from OCC.utils.annotation import Font
from OCC.utils.utilities import (QuantityColor_rgb, rgb_QuantityColor)

from parapy.core import Attribute, Input, Part, apply_to_all, derived
from parapy.core.base import Base, DrawableBase
from parapy.core.exceptions import ParaPyDeprecationWarning
from parapy.core.utilities import get_rgb_value
from parapy.core.validate import IsInstance, OneOf, Optional
from parapy.core.widgets import CheckBox, Dropdown
from parapy.geom.generic import Orientation, Point, Position, VX, VY
from parapy.geom.generic.positioning import XOY
from parapy.geom.generic.utilities import is_almost_equal, vector_angle
from parapy.geom.globs import ICN_DIR
from parapy.geom.occ.compound import Compound, Compound_
from parapy.geom.occ.face import PolygonalFace
from parapy.geom.occ.surface import Plane
from parapy.geom.occ.utilities import gp_Ax3_from_position, iflatten_color
from parapy.geom.occ.wire import Polygon

__all__ = ("LengthDimension", "DiameterDimension", "RadiusDimension",
           "AngleDimension", "AngleDimension3Points", "TextLabel", "TextShape",
           "ColorScale", "NumericColorScale", "Leader", "TextLeader")


##############
# Dimensions #
##############


class Dimension(DrawableBase):
    """Abstract base class of objects that show some dimensioning in the GUI.

    .. note::  The Attribute :attr:`in_plane` allows a user to set the
        plane in which the dimension will be shown. It is however known
        that some combinations of input shapes and values for this plane
        will not result in a valid Dimension object. If this happens,
        and you want to force the Dimension to be in the given plane, it
        might help to use :class:`~parapy.geom.Point` instances
        to place the dimensions.

    Units
    -----

    The Dimension objects 'measure' one or multiple shapes, and display the
    measured value in the GUI. By default the displayed values are measured in
    world units. However, one can convert them to the units one wants by
    specifying :attr:`units`:

    units='m', displayed value: ``1``

    units='cm', displayed value: ``100``

    When the default ``world_units`` do not match the ones used for your
    ParaPy model, the :attr:`world_units` can be set. For instance, specifying
    'world_units' to be 'in' will convert values based on that 1 world unit
    is 1 inch. By default, the unit for measured lengths is meter.

    Using :attr:`append_unit` will append the the unit to the value string:

    units='cm', append_unit=True, displayed value: '100 cm'

    To offer more customization, for instance if you do not like the default
    'append' style of units, is to use :attr:`text`, where you can use
    'format' style placeholders. For example:

    '{value} {unit} more text'

    Dimension Scale
    ---------------

    To quickly scale all the Dimension objects in a ParaPy product tree,
    it is possible to use the defaulting behaviour of :attr:`dimension_scale`
    in a common ancestor of the dimensions to assign it with a reasonable
    default.

    Example::

        class MyDimensions(Base):

            # controls scale of all child object of type Dimension
            dimension_scale = Input(0.5)

            @Part
            def dim1(self):
                return AngularDimension(...)

            @Part
            def dim2(self):
                return LinearDimension(...)

            @Part
            def dim3(self):
                return RadialDimension(...)

             # more dimensions ...


    Known subclasses
    ----------------

    :class:`LengthDimension`, :class:`DiameterDimension`,
    :class:`RadiusDimension`, :class:`AngleDimension`,
    :class:`AngleDimension3Points`.
    """
    __initargs__ = "shape"

    #: Shape or point which is used for the construction of the Dimension
    #: object, refer to the relevant subclass to get an overview of the
    #: supported combinations.
    #: :type: parapy.geom.BRep | parapy.geom.Curve | parapy.geom.Surface | parapy.geom.Point
    shape = Input()

    #: :class:`~parapy.geom.Plane` in which the dimension annotation is placed.
    #: If set to :py:`None` it tries to automatically calculate a suitable
    #: plane.
    #: :type: parapy.geom.Plane
    in_plane = Input(None, validator=Optional(IsInstance(Plane)))

    #: Factor used to scale the automatically calculated
    #: sizes of the dimensions to an appropriate size.
    #: It will rescale the automatically calculated :attr:`arrow_tail_length`,
    #: :attr:`label_extension_length`, :attr:`arrow_size` and
    #: :attr:`text_size`. This means that if one sets a value for one of
    #: these attributes, they will not be based on the ``dimension_scale``
    #: anymore. It is a defaulting Input so one can specify the
    #: dimension scale for a given ParaPy (sub-)tree.
    #: :type: float
    dimension_scale = Input(1, defaulting=True)

    # Units

    #: Units used for this dimension. A conversion will be done based on the
    #: currently used :attr:`world_units`. For instance, if this dimension
    #: should display the value in `cm`, and :attr:`world_units` is 'm',
    #: it will show '200' if the length is 1 world unit.
    #: :type: str
    units = Input(None)

    #: World units (e.g. one unit in the geometry corresponds to one 'm').
    #: :type: str
    world_units = Input(None)

    #: If set to :py:`True` append the :attr:`units` to the displayed
    #: dimension text.
    #: :type: bool
    append_unit = Input(False)

    # TODO (TBD): Standard_ExtCharacter is problematic.
    # #: .
    # #: :type: unicode
    # unit_symbol = Input(None)

    # Arrow
    #: Size of the arrows in the dimension. If set to :py:`None` it will
    #: have an appropriate auto-calculated default value based on
    #: :attr:`dimension_scale`.
    #: :type: float | None
    arrow_size = Input(None)

    #: Length of the tail behind the arrow in world units. If set to
    #: :py:`None` it will have an appropriate auto-calculated default value
    #: based on :attr:`dimension_scale`.
    #: :type: float | None
    arrow_tail_length = Input(None)

    #: In which direction should the arrows point? Either specify 'inward'
    #: or 'outward'. Set to :py:`None` to use the default value of the
    #: framework used to generate a representation of the Dimension, which
    #: might also be different across different Dimension objects.
    #: :type: str | None
    arrow_direction = Input(None,
                            validator=OneOf({'inward', 'outward', None}))

    #: If set to :py:`True`, it will show a 3D arrow instead of a 2D arrow.
    #: :type: bool
    arrow_in_3d = Input(False)

    # Text

    #: Color of the dimension object, this includes the visual lines,
    #: arrows, and the text.
    #: :type: str | tuple[float, float, float]
    color = Input('black')

    #: Distance that the annotation 'flies out' from the place where the
    #: annotation was measured in world units. Setting it to a negative value
    #: will reverse the direction of the fly_out.
    #: When :py:`None` is specified, the default value is used: the measured
    #:  value in world units * fly_out_ratio.
    #: :type: float
    fly_out = Input(None)

    #: The ratio between the fly_out and the measured value.
    #: Use :py:`None` to revert to the default values.
    #: Set it to a negative value to reverse the default fly-out direction.
    #: :type: float | None
    fly_out_ratio = Input(1.)

    #: Length of the 'arrow tail' at the side of where the text label (the
    #: dimension value) is place. Defaults to :attr:`arrow_tail_length`.
    #: If set to :py:`None` it will have an appropriate auto-calculated
    #: default value based on :attr:`dimension_scale`.
    #: :type: float
    label_extension_length = Input(derived)

    #: Size of the text. If :attr:`text_in_3d` is set to :py:`True`,
    #: the size corresponds to the amount of on-screen pixels. Otherwise
    #: it specifies the text-size in world-units.
    #: If set to :py:`None` it will have an appropriate auto-calculated
    #: default value based on :attr:`dimension_scale`.
    #: :type: float | None
    text_size = Input(None)

    #: Is the text a 3D object in the viewer? If set to :py:`True` the text
    #: will have a height of :attr:`text_size` in world-coordinates and
    #: will be oriented in the plane of the dimension annotation.
    #: If set to :py:`False`, the text will have a height of
    #: :attr:`text_size` on-screen pixels and will always be oriented towards
    #: the user.
    #: :type: bool
    text_in_3d = Input(True)

    #: Force the text to appear on this location.
    #: :type: parapy.geom.Point | None
    text_location = Input(None)

    #: Custom text to display in the dimension. You can use the '{value}'
    #: and '{unit}' placeholders to refer to the computed value for the
    #: dimension.
    #:
    #: :py:`my_dimension.text = "my value: {value} {unit}"`
    #:
    #: All modifiers are available from the python 'format' functionality
    #: for instance {value:g} would give the value without decimals
    #: :type: str
    text = Input(None)

    #: Should the Dimension object always be displayed 'on top' of everything
    #: else in the GUI?
    #: :type: bool
    top_most = Input(False)

    @label_extension_length.getter
    def label_extension_length(self):
        return self.arrow_tail_length

    # TODO (TBD): Not here, repsponsibility of the GUI code: separation of...
    # TODO (FT): Could be nicely done with dynamic entry points.
    @property
    def _Handle_AIS_InteractiveObject(self):
        raise RuntimeError("This property is patched in parapy.gui. "
                           "First import ``from parapy.gui import "
                           "display``.")


class LengthDimension(Dimension):
    """Show the distance between :attr:`shape` and :attr:`other_shape`.

    Legal input combinations:

    When a reference plane :attr:`in_plane` is specified:

    - Two shapes
    - Two :class:`parapy.geom.Point` instances

    When no reference plane :attr:`in_plane` is specified:

    - Two :class:`parapy.geom.Surface`s
    - A :class:`parapy.geom.Surface` and a :class:`parapy.geom.Curve`

    Usage:

    >>> from parapy.geom import LengthDimension, Box
    >>> box = Box(1, 1, 1)
    >>> # keywords:
    >>> # LengthDimension(shape=box.front_face, other_shape=box.rear_face)
    >>> dimension = LengthDimension(box.front_face, box.rear_face)

    """
    __initargs__ = "shape", "other_shape"

    #: :type: parapy.geom.BRep | parapy.geom.Point
    other_shape = Input(None)


class DiameterDimension(Dimension):
    """Show the diameter of a (circular) shape.

    .. note:: Will fail if it the given shape is not a
        :class:`~parapy.geom.Circle`, or a shape that contains a
        geometry where a diameter can be measured: (circular
        :class:`~parapy.geom.Wire`, circular
        :class:`~parapy.geom.Face`, etc.)

    Usage:

    >>> from parapy.geom import DiameterDimension, Circle
    >>> circle = Circle(radius=1)
    >>> # keywords: DiameterDimension(shape=circle)
    >>> dimension = DiameterDimension(circle)

    """


class RadiusDimension(Dimension):
    """Show the radius of a (circular) shape.

    .. note:: Will fail if it the given shape is not a
        :class:`~parapy.geom.Circle`, or a shape that contains a
        geometry where a radius can be measured: (circular
        :class:`~parapy.geom.Wire`, circular
        :class:`~parapy.geom.Face`, etc.)

    Usage:

    >>> from parapy.geom import RadiusDimension, Circle
    >>> circle = Circle(radius=1)
    >>> # keywords: RadiusDimension(shape=circle)
    >>> dimension = RadiusDimension(circle)

    """
    fly_out_ratio = Input(2.)


class AngleDimension(Dimension):
    """Show the angle between two shapes.

    Legal input combinations:

    - Two straight edges that intersect
    - Two planar faces

    Usage:

    >>> from parapy.geom import AngleDimension, LineSegment, Point
    >>> l1 = LineSegment(Point(0, 0, 0), Point(1, 0, 0))
    >>> l2 = LineSegment(Point(0, 0, 0), Point(1, 1, 1))
    >>> # keywords: AngleDimension(shape=l1, other_shape=l2)
    >>> dimension = AngleDimension(l1, l2)

    """
    __initargs__ = "shape", "other_shape"

    #: The second shape.
    #: :type: parapy.geom.Curve | parapy.geom.Surface
    other_shape = Input()

    #: .
    #: :type: str | None
    display_arrows = Input('both', validator=OneOf({'both', 'first', 'second',
                                                    None}))

    #: Is this the interior angle? Otherwise shows the exterior angle.
    #: :type: bool
    interior_angle = Input(True)

    fly_out_ratio = Attribute(None)


class AngleDimension3Points(AngleDimension):
    """Construct an AngleDimension based on three :class:`~parapy.geom.Point`
    or :class:`~parapy.geom.Vertex" instances.

    Legal input combinations for :attr:`point`, :attr:`other_point` and
    :attr:`rotation_point`.

    - Three :class:`~parapy.geom.Point` instances.
    - Three :class:`~parapy.geom.Vertex` instances.

    >>> from parapy.geom import AngleDimension3Points, Point
    >>> pt1 = Point(1, 0, 0)
    >>> pt2 = Point(0, 0, 0)
    >>> pt3 = Point(1, 1, 1)
    >>> # keywords: AngleDimension3Points(point=pt1,
    >>> #                                 rotation_point=pt2,
    >>> #                                 other_point=pt3)
    >>> dimension = AngleDimension3Points(pt1, pt2, pt3)

    """
    __initargs__ = "start", "center", "end"

    #: Going from this :attr:`start` to :attr:`center` creates
    #: one of the two lines between which the angle will be measured.
    #: :type: parapy.geom.Point | parapy.geom.occ.vertex.Vertex_
    start = Input()

    #: The 'center' point of the angle, where the two angle lines come
    #: together.
    #: :type: parapy.geom.Point | parapy.geom.occ.vertex.Vertex_
    center = Input()

    #: Going from this :attr:`end` to :attr:`center` creates
    #: the other of the two lines between which the angle will be measured.
    #: :type: parapy.geom.Point | parapy.geom.occ.vertex.Vertex_
    end = Input()

    @Input
    def shape(self):
        return self.start

    @Input
    def other_shape(self):
        return self.end

    @Attribute
    def points(self):
        """The tree points of this AngleDimension in the order:
        :attr:`start`, :attr:`center`, :attr:`end`.

        :rtype: tuple[parapy.geom.Point | parapy.geom.occ.vertex.Vertex_]
        """
        return self.shape, self.center, self.other_shape


########
# Text #
########


class AbstractText(DrawableBase):
    """Base class for Text related classes."""

    __initargs__ = ["text", "size"]
    __icon__ = os.path.join(ICN_DIR, 'text.png')

    _ANCHOR_TO_HTA = {'left': Graphic3d_HTA_LEFT,
                      'center': Graphic3d_HTA_CENTER,
                      'right': Graphic3d_HTA_RIGHT}
    ANCHOR_OPTIONS = list(_ANCHOR_TO_HTA.keys())

    _VANCHOR_TO_VTA = {'bottom': Graphic3d_VTA_BOTTOM,
                       'center': Graphic3d_VTA_CENTER,
                       'top': Graphic3d_VTA_TOP,
                       'bottom_first_line': Graphic3d_VTA_TOPFIRSTLINE}
    VANCHOR_OPTIONS = list(_VANCHOR_TO_VTA.keys())

    #: text for display
    #: :type: str
    text = Input()

    #: text height in world units
    #: :type: int
    size = Input()

    #: Name of the font
    #: str
    font = Input('Arial')

    #: Is it bold text?
    #: :type: is it bold text?
    bold = Input(False, widget=CheckBox)

    #: Is it italic text?
    #: :type: bool
    italic = Input(False, widget=CheckBox)

    #: Where is the text positioned?
    #: :type: parapy.geom.Position
    position = Input(XOY, defaulting=True)

    #: color of the text
    #: :type: str | (float, float, float)
    color = Input("black")

    #: Horizontally seen, relative to the text, where is the anchor-point of
    #: the text?
    #: Options 'left', 'center', 'right'.
    #: :type: str
    anchor = Input('left',
                   widget=Dropdown(ANCHOR_OPTIONS),
                   validator=OneOf(ANCHOR_OPTIONS))

    #: Vertically seen, relative to the text, where is the anchor-point of
    #: the text?
    #: Options 'bottom', 'center', 'top', and 'bottom_first_line'. The
    #: 'bottom_first_line' will put the anchor-point underneath the
    #: first-line of the text.
    #: :type: str
    vanchor = Input('bottom',
                    widget=Dropdown(VANCHOR_OPTIONS),
                    validator=OneOf(VANCHOR_OPTIONS))

    @font.validator
    def font(self, name):
        font_name = TCollection_HAsciiString(name).handle
        font_aspect = self._font_aspect
        font_mgr = Font_FontMgr.GetInstance()

        # The size is specified as a wildcard because the lookup method
        # needs the size in points. We have the size in world-coordinates.
        # Current method might therefore not
        # give the exact same results as Init of BRepFont. Probably this will
        # not happen often since most fonts are resizable.
        system_font = font_mgr.GetFont(font_name, font_aspect, -1)
        if system_font.IsNull():  # no exact font match
            system_font = font_mgr.FindFont(font_name, font_aspect, -1)

            if system_font.IsNull():  # no 'look-alike' font found
                msg = ("Could not find any font as either full or partial "
                       "match to '{}'. Object: {!r}")
                return False, msg.format(name, self)
            else:
                font = Font.from_system_font(system_font)

                msg = ("Could not find exact font match to '{}', Bold: {}, "
                       "Italic: {}, falling back to font '{}', Bold: {}, "
                       "Italic: {}. Object: {!r}")
                warnings.warn(msg.format(name, self.bold, self.italic,
                                         font.name, font.bold, font.italic,
                                         self))
        return True

    @Attribute
    def _font_aspect(self):
        return Font.bi_to_font_aspect(self.bold, self.italic)


class TextLabel(AbstractText):
    """Use to display :attr:`text` string in the GUI at :attr:`position`. You
    can specify the text :attr:`size` and control whether text should always
    be shown in front of other objects using :attr:`overlay` (default False).

    Usage:

    >>> from parapy.geom import TextLabel, Point
    >>> obj = TextLabel("Some text", Point(1, 2, 3))

    More advanced example, showing text labels at all vertices of a box:

    >>> from parapy.core import Base, Part, child
    >>> from parapy.geom import Box
    ... 
    ... class TextLabelSample(Base):
    ...     #: text size
    ...     size = Input(30)       # type: int
    ...     #: shows text always in front of other objects?
    ...     overlay = Input(False)  # type: bool
    ... 
    ...     @Part
    ...     def box(self):
    ...         return Box(1, 2, 3)
    ... 
    ...     @Part
    ...     def labels(self):
    ...         return TextLabel(quantify=8,
    ...                          text="Vertex {}".format(child.index),
    ...                          position=self.box.vertices[child.index].point,
    ...                          pass_down="size, overlay")
    """

    @Input
    def size(self):
        """text size in screen-pixels if :attr:`zoom_persistent` is ``True``.
        If :attr:`zoom_persistent` is ``False`` it is  in  world-units

        :rtype: int
        """
        # TODO (FT): Remove later, this is only here to deprecate not
        #  setting a size for the TextLabel
        if self.is_user_defined('height'):
            msg = ("Using 'height' has been deprecated, use "
                   "'size' instead. Object: {!r}")
            warnings.warn(msg.format(self), ParaPyDeprecationWarning)
        else:
            msg = ("Relying on a default value for `size` has been deprecated "
                   "set the 'size' instead. Object: {!r}")
            warnings.warn(msg.format(self), ParaPyDeprecationWarning)

        return self.height

    #: Orient text in 3D or have text always face camera? This Input defaults
    #: to False if :attr:`position` is of type :class:`~parapy.geom.Point`,
    #: (i.e. text always facing user) or True if of type
    #: :class:`~parapy.geom.Position` (i.e. text oriented in 3D frame)
    #: :type: bool
    orient = Input(derived)

    #: If set to zoom-persistent, the text :attr:`size` will the size of
    #: the text in pixels on screen. If not, the :attr:`size` will be
    #: the size of the text in word units.
    #: :type: bool
    zoom_persistent = Input(True)

    #: Show text always in front of other objects?
    #: :type: bool
    overlay = Input(False)

    #: (deprecated) text height in screen-pixels
    #: :type: int | None
    height = Input(None)

    @orient.getter
    def orient(self):
        return isinstance(self.position, Position)

    @Part(in_tree=False)
    def shape(self):
        """The shape representation for this TextLabel. Note that the size
        of the create shape will only match the expected size when
        :attr:`zoom_persistent` is set to ``False``. This is because this
        forces the units of the TextLabel to be screen pixels, which is not
        supported by TextShape.
        """
        return TextShape(
            position=self.position if isinstance(self.position, Position)
            else Position(location=self.position),
            pass_down='text, font, size, bold, italic, color, anchor, vanchor')

    @shape.validator
    def shape(self):
        if self.zoom_persistent:
            msg = ("Cannot create shape of TextLabel due to 'zoom_persistent' "
                   "being True. Set zoom_persistent to False, and specify "
                   "the size in world-units to be able to get the shape.")
            return False, msg
        elif self.size is None:
            msg = ("Cannot create shape of TextLabel due to 'size' "
                   "being set to None, which is deprecated. Please specify a "
                   "size in world-units.")
            return False, msg
        else:
            return True

    @property
    def _Handle_AIS_InteractiveObject(self):
        raise RuntimeError("This property is patched in parapy.gui. First "
                           "import ``from parapy.gui import display``.")


class TextShape(AbstractText, Compound_):
    """Render a :attr:`text` of given :attr:`size` as a shape.

    Usage:

    >>> from parapy.geom import TextShape
    >>> obj = TextShape("foo", size=1)

    """
    __initargs__ = 'text', 'size'
    __icon__ = os.path.join(ICN_DIR, 'text.png')

    @Attribute
    def _brep_font(self):
        name = self.font
        size = self.size

        brep_font = BRepFont()
        name_utf8 = NCollection_Utf8String(name)
        if brep_font.Init(name_utf8, self._font_aspect, size):
            return brep_font
        else:
            msg = ("Could not instantiate font '{}'. Size: {}, Bold: {}, "
                   "Italic: {}. Object: {!r}")
            raise RuntimeError(msg.format(name, size, self.bold,
                                          self.italic, self))

    @Attribute(private=True)
    def builder(self):
        return Font_BRepTextBuilder()

    @Attribute(private=True)
    def TopoDS_Shape(self):
        builder = self.builder

        text = NCollection_Utf8String(self.text)
        text_pos = gp_Ax3_from_position(self.position)
        anchor = self._ANCHOR_TO_HTA[self.anchor]
        vanchor = self._VANCHOR_TO_VTA[self.vanchor]

        return builder.Perform(self._brep_font, text, text_pos, anchor,
                               vanchor)


###############
# ColorScales #
###############

COLORSCALE_LABEL_POSITIONS = {
    None: Aspect_TOCSP_NONE,
    'center': Aspect_TOCSP_CENTER,
    'left': Aspect_TOCSP_LEFT,
    'right': Aspect_TOCSP_RIGHT
}

_REV_COLORSCALE_LABEL_POSITIONS = {
    Aspect_TOCSP_NONE: None,
    Aspect_TOCSP_CENTER: 'center',
    Aspect_TOCSP_LEFT: 'left',
    Aspect_TOCSP_RIGHT: 'right'
}

COLORSCALE_ANCHOR_POSITIONS = {
    'center': Aspect_TOTP_CENTER,
    'left': Aspect_TOTP_LEFT,
    'right': Aspect_TOTP_RIGHT,
    'bottom': Aspect_TOTP_BOTTOM,
    'top': Aspect_TOTP_TOP,
    'bottom-left': Aspect_TOTP_LEFT_LOWER,
    'top-left': Aspect_TOTP_LEFT_UPPER,
    'bottom-right': Aspect_TOTP_RIGHT_LOWER,
    'top-right': Aspect_TOTP_RIGHT_UPPER,
}

_NOT_USER_DEFINED = []


class ColorScale(DrawableBase):
    """Creates a ColorScale named :attr:`title` that has intervals with
    :attr:`labels`. The color of the intervals can be overridden by setting
    :attr:`colors`.

    By default, the labels will be placed at the border between two intervals,
    but this can be overridden using :attr:`label_at_border`.

    Usage:

    >>> from parapy.geom import ColorScale
    >>> # Create a scale "My Scale" with 2 intervals colored 'red' and 'green'
    >>> # and on the borders of these intervals the numbers '1', '2', '3'
    >>> scale = ColorScale(title="My Scale",
    ...                    labels=("1", "2", "3"),
    ...                    colors=('red', 'green'))
    >>> # Create a scale "My Scale" with 3 intervals colored 'red', 'green'
    >>> # and 'blue' with the numbers '1', '2', '3' next to them.
    >>> scale = ColorScale(title="My Scale",
    ...                    labels=("1", "2", "3"),
    ...                    colors=('red', 'green', 'blue'),
    ...                    label_at_border=False)


    .. note:: If you want to create a ColorScale for numeric data, please
        use :class:`NumericColorScale`, which offers better support for this.

    """

    __icon__ = os.path.join(ICN_DIR, 'colorscale.png')

    #: Title of this ColorScale.
    #: :type: str
    title = Input()

    #: Text labels next to the ColorScale intervals. By default, labels are
    #: placed at interval boundaries. Ensure that
    #: ``len(labels) = len(colors) + 1``. If you want labels to be vertically
    #: aligned with the center of a respective interval,
    #: set :attr:label_at_border to :py:`False` and ensure that
    #: ``len(labels) = len(colors)``. Set a label to :py:`None` if you do not
    #: want to have a label at that specific place.
    #: :type: collections.Sequence[str | None]
    labels = Input()

    #: Colors used for the intervals. If :attr:`label_at_border` is :py:`True`
    #: at least :py:`len(labels) - 1` colors should be specified. If
    #: :attr:`label_at_border` is :py:`False` at least :py:`len(labels)`
    #: colors should be specified. When not setting colors,
    #: OCC will automatically determine colors for you.
    #: :type: collections.Iterable[str | tuple[int, int, int]]
    colors = Input(derived)

    #: Width of the ColorScale.
    #: .. note:: If the width is too small, it might cause the scale not to
    #:      display.
    #: .. note:: It seems that this call is only responsive in open-cascade
    #:      between 70 (thin bar) and 90 (wide bar)
    #: :type: int
    width = Input(100)

    #: Height of the ColorScale in pixels.
    #: .. note:: If the height is too small, it might cause the scale not to
    #:      display.
    #: :type: int
    height = Input(200)

    #: Where should the lower left corner of the ColorScale be placed
    #: relative to the screen?
    #: Options:
    #: 'center', 'left', 'right', 'bottom', 'top', 'top-left', 'top-right'
    #: 'bottom-left', 'bottom-right'
    #:
    #: .. note:: When positioning the ColorScale near the top or right of
    #:      the screen, it will appear off-screen without specifying
    #:      a proper :attr:`offset`.
    #:
    #: :type: str
    screen_position = Input('bottom-left', validator=OneOf(
        list(COLORSCALE_ANCHOR_POSITIONS.keys())))

    #: The pixel offset from the screen edges mentioned in
    #: :attr:`screen_position` in the inward x, y direction.
    #: For instance, when :attr:`screen_position` is
    #: 'bottom_left', and ``offset == (20, 30)`` it means 20 pixels offset from
    #: the left edge, and 30 pixels from the bottom. However,
    #: when 'top_right' is specified, it would mean 20 pixels offset from the
    #: right edge, and 30 pixels from the top.
    #: When the screen edge is ambiguous for one of the components, it will
    #: not be taken into account.
    #: For instance when ``screen_position = 'left'``,
    #: the y-component could relate to either the 'top' or 'bottom', so the
    #: component will not affect the placement. Note that in this case, you
    #: still *need* to specify the component, which you can set to any value.
    #: :type: collections.Sequence[int, int]
    offset = Input((0, 0))

    #: Vertically align the label with the border between two scale interval
    #: colors. If set to :py:`False` the label will be vertically aligned
    #: with the color of the corresponding interval.
    #: :type: bool
    label_at_border = Input(True)

    #: Reverse the scale.
    #: :type: bool
    reverse = Input(False)

    #: Size in pixels of the text in the ColorScale (both labels and title).
    #: :type: int
    font_size = Input(derived)

    #: Where should the labels be positioned relatively to the ColorScale.
    #: Options: 'center', 'left', 'right', :py:`None`
    #: :type: str | None
    label_position = Input(derived, validator=OneOf(
        list(COLORSCALE_LABEL_POSITIONS.keys())))

    @label_position.getter
    def label_position(self):
        return _REV_COLORSCALE_LABEL_POSITIONS[
            self._AIS_ColorScale.GetLabelPosition()]

    # Does not seem to be responsive
    #: Where should the title be positioned relatively to the ColorScale.
    #: :type: str | None
    # title_position = Input(derived, validator=OneOf(
    #     COLORSCALE_LABEL_POSITIONS.keys()))
    #
    # @title_position.getter
    # def title_position(self):
    #     return _REV_COLORSCALE_LABEL_POSITIONS[
    #         self._AIS_ColorScale.GetLabelPosition()]

    @colors.getter
    def colors(self):
        scale = self._AIS_ColorScale
        get_color = lambda qc: QuantityColor_rgb(scale.GetIntervalColor(qc))
        return tuple(get_color(i) for i in range(1, self.nb_intervals + 1))

    @font_size.getter
    def font_size(self):
        return self._AIS_ColorScale.GetTextHeight()

    @Input
    def label(self):
        return self.title.replace('\n', ' ')

    @Attribute
    def nb_intervals(self):
        """The number of intervals that this scale has.

        :rtype: int
        """
        num_labels = len(self.labels)
        return num_labels - 1 if self.label_at_border else num_labels

    @Attribute(private=True)
    def _AIS_ColorScale(self):
        """OCC object which represents the color scale.

        :rtype: OCC.AIS.AIS_ColorScale
        """
        # TODO (TBD): These classes are in a way more a GUI widget.
        # /todo They are not 'geometry' and have no meaning without a viewer
        from OCC.wrapper.AIS import AIS_ColorScale, Handle_AIS_InteractiveObject

        # We need to return a non-handle type over here, because the
        # Handle_AIS_ColorScale is currently broken in the wrapper
        color_scale = AIS_ColorScale()
        # the Handle will ensure that the color scale will be GC'd in C++
        color_scale.__d = Handle_AIS_InteractiveObject(color_scale)
        self._set_color_scale(color_scale)
        return color_scale

    @Attribute(private=True)
    def _occ_labels(self):
        """The labels wrapped in an OCC-compatible container.

        :rtype: OCC.TColStd.TColStd_SequenceOfExtendedString
        """
        seq = TColStd_SequenceOfExtendedString()
        gen_str_labels = map(lambda x: '' if x is None else x, self.labels)
        apply_to_all(seq.Append, map(TCollection_ExtendedString,
                                     gen_str_labels))
        return seq

    @Attribute(private=True)
    def _occ_interval_colors(self):
        seq = Aspect_SequenceOfColor()

        def convert(color):
            return rgb_QuantityColor(get_rgb_value(color))

        # append all the colors
        q_colors = map(convert, iflatten_color(self.colors))
        apply_to_all(seq.Append, q_colors)

        return seq

    def _set_labels(self, color_scale):
        color_scale.SetLabelType(Aspect_TOCSD_USER)
        color_scale.SetLabels(self._occ_labels)

    def _set_colors(self, color_scale):
        colors_defined = self.is_user_defined('colors') and self.colors
        self.touch_slot('colors')

        label_type = (Aspect_TOCSD_USER if colors_defined
                      else Aspect_TOCSD_AUTO)
        color_scale.SetColorType(label_type)
        if colors_defined:
            color_scale.SetColors(self._occ_interval_colors)

    def _set_color_scale(self, color_scale):
        color_scale.SetTitle(TCollection_ExtendedString(self.title))
        color_scale.SetNumberOfIntervals(self.nb_intervals)

        self._set_labels(color_scale)
        self._set_colors(color_scale)

        # look and feel of scale
        color_scale.SetSize(self.width, self.height)
        color_scale.SetReversed(self.reverse)

        # positioning
        label_position = self.get_if_user_defined('label_position', touch=True,
                                                  default=_NOT_USER_DEFINED)
        if label_position is not _NOT_USER_DEFINED:
            position_enum = COLORSCALE_LABEL_POSITIONS[label_position]
            color_scale.SetLabelPosition(position_enum)

        # title position does not seem to be responsive:
        # title_position = self.get_if_user_defined('title_position',
        #                                           touch=True,
        #                                           default=_NOT_USER_DEFINED)
        # if title_position is not _NOT_USER_DEFINED:
        #     title_position_enum = COLORSCALE_LABEL_POSITIONS[title_position]
        #     color_scale.SetTitlePosition(title_position_enum)

        color_scale.SetLabelAtBorder(self.label_at_border)

        color_scale.SetZLayer(Graphic3d_ZLayerId_TopOSD)

        # set the on-screen position
        transf_persistance = Graphic3d_TransformPers(Graphic3d_TMF_2d)
        transf_persistance.SetCorner2d(
            COLORSCALE_ANCHOR_POSITIONS[self.screen_position])
        transf_persistance.SetOffset2d(Graphic3d_Vec2i(*self.offset))
        color_scale.SetTransformPersistence(transf_persistance.handle)

        # text
        font_size = self.get_if_user_defined('font_size', touch=True,
                                             default=_NOT_USER_DEFINED)
        if font_size is not _NOT_USER_DEFINED:
            color_scale.SetTextHeight(font_size)

        color_scale.SetToUpdate()

    @property
    def _Handle_AIS_InteractiveObject(self):
        raise RuntimeError("This property is patched in parapy.gui. First "
                           "import ``from parapy.gui import display``.")


class NumericColorScale(ColorScale):
    """Creates a ColorScale for numeric values, where the colors are
    corresponding to a numeric range defined by :attr:`min`, and :attr:`max`.

    Usage:

    >>> from parapy.geom import NumericColorScale
    >>> # Scale titled 'My Scale' from 0 to 5, divided into 5 color intervals
    >>> scale = NumericColorScale(title="My Scale", min=0, max=5, nb_intervals=5)

    .. note:: If you need more custom control over the labels and colors,
        please use :class:`ColorScale`.

    """

    #: The minimum value of the scale.
    #: :type: float
    min = Input()

    #: The maximum value of the scale.
    #: :type: float
    max = Input()

    #: Amount of intervals used to segment the range between the
    #: 'min_value' and 'max_value'.
    #: :type: int
    nb_intervals = Input()

    #: Is this a logarithmic scale? Will change the numbers on the scale
    #: to follow a logarithmic scale. It will not scale the color intervals
    #: their size.
    #: :type: bool
    logarithmic = Input(False)

    #: A C-style ``printf()`` formatting of how the numbers are displayed
    #: as a label on the color scale. For instance ``'%e'`` would print the
    #: number in lowercase scientific notation, and ``'%.2f'`` would print
    #: the rounded number in 2 decimal places.
    #: :type: str
    label_format = Input(derived)

    @label_format.getter
    def label_format(self):
        """:rtype: str"""
        return self._AIS_ColorScale.GetFormat().ToCString()

    @Attribute
    def labels(self):
        """Labels of the ColorScale.

        :rtype: tuple[str]
        """

        def get_label(label_index):
            extended_string = self._AIS_ColorScale.GetLabel(label_index)
            return extended_string.ToExtString()

        return tuple(get_label(i) for i in range(1, self.nb_intervals + 1))

    def _set_labels(self, color_scale):
        color_scale.SetRange(self.min, self.max)

    def _set_color_scale(self, color_scale):
        super(NumericColorScale, self)._set_color_scale(color_scale)

        label_format = self.get_if_user_defined('label_format', touch=True,
                                                default=_NOT_USER_DEFINED)
        if label_format is not _NOT_USER_DEFINED:
            color_scale.SetFormat(TCollection_AsciiString(label_format))

        color_scale.SetLogarithmic(self.logarithmic)

##########
# Leader #
##########


class Leader(Compound):
    """A Leader with a Polygon line defined by :attr:`points` with an
    arrow at the start and an :attr:`annotation` at the end.

    Usage:

    >>> from parapy.geom import Point, Leader
    >>> # simple
    >>> pts = [Point(0, 0, 0), Point(1, 1, 0), Point(2, 1, 0)]
    >>> leader = Leader(pts)
    >>> # With a circle symbol:
    >>> from parapy.core import Base, Input, Part
    >>> from parapy.geom import Circle, translate
    >>> class LeaderWithSymbol(Base):
    ...     @Part
    ...     def symbol(self):
    ...         return Circle(radius=1,
    ...                       position=translate(
    ...                           self.leader.annotation_position, 'x', 1))
    ... 
    ...     @Part
    ...     def leader(self):
    ...         return Leader(pts, annotation=self.symbol)

    """

    __initargs__ = 'points', 'annotation'

    #: Points that make up the Leader its Polygonal Curve. Note that the
    #: Annotation will be attached to the first point, and the tip of the
    #: arrow will be located at the last Point. At least 2 Points should be
    #: specified.
    #: :type: collection.Sequence[parapy.geom.Point]
    points = Input()

    @points.validator
    def points(self, value):
        if len(value) < 2:
            return False, ("At least 2 points should be specified to "
                           "construct the Leader!")
        return True

    #: Shape to be used as annotation, or ``None`` if there is no annotation.
    #: Note that the provided shape should
    #: already positioned correctly. One can use :attr:`annotation_position`,
    #: attr:`annotation_outward_dir`, attr:`annotation_up_dir` and
    #: attr:`annotation_right_dir` for this purpose.
    #: :type: parapy.geom.occ.drawable.DrawableShape | None
    annotation = Input(None)

    @Input
    def arrow_size(self):
        """Size of the arrow-head, measured from the base to the tip.
        """
        points = self.points
        last_segment_length = (points[-1] - points[-2]).length
        return last_segment_length * self.head_size_ratio

    #: Half of the angle of the arrow-tip in radians.
    #: :type: float
    arrow_angle = Input(radians(10))

    #: Size of the arrow-head defined as a fraction of length of the segment
    #: :type: float
    head_size_ratio = Input(0.1)

    #: Reference vector to denote what is considered 'up'. (default: global y)
    #: :type: parapy.geom.Vector
    up_reference = Input(VY)

    #: Reference vector to denote what is considered the left-to-right
    #: direction. (default: global x)
    #: :type: parapy.geom.Vector
    right_reference = Input(VX)

    color = Input("black")

    #: Distance between start of the leader and the annotation.
    #: :type: float
    gap = Input(0.0)

    #: Maximum allowed tolerance between the :attr:`plane_normal` and the
    #: plane in which :attr:`points` lie.
    #: :type: float
    tolerance = Input(1e-7)

    @Input
    def plane_normal(self):
        """Normal to the plane in which the Leader's points lie. Defaults to
        the plane_normal of the :attr:`points`. If the :attr:`points` lie in
        a straight line, you need to specify a
        :class:`~parapy.geom.Vector` that defines the plane normal
        within :attr:`tolerance`.

        :rtype: parapy.geom.Vector
        """
        return self.curve.plane_normal

    @plane_normal.validator
    def plane_normal(self, value):
        curve = self.curve
        tolerance = self.tolerance
        if curve.is_planar_with_tolerance(tolerance) or len(self.points) == 2:
            # the test if the provided plane_normal is a bit cumbersome since
            # we cannot test if the curve.is_straight when it is a Wire,
            # and we cannot rely on the RuntimeError thrown by
            # curve.plane_normal when OCC cannot calculate a plane_normal,
            # so we assume it is normal when all edges in the curve are normal
            edges = curve.edges
            for edge in edges:
                if not edge.tangent1.is_orthogonal(value, tolerance):
                    msg = ("The provided plane_normal {} is not a normal of "
                           "the plane in which the points lie within "
                           "tolerance {}. If you are sure that it is a "
                           "normal of the plane, consider increasing the"
                           "tolerance.")
                    return False, msg.format(value, tolerance)
            else:  # all edges orthogonal
                return True
        else:
            msg = ("The points do not lie in a plane, therefore it cannot "
                   "have a plane_normal.")
            return False, msg

    @Attribute
    def curve_pts(self):
        """:attr:`points`` with the last point moved from the tip of the
        arrow to the base of the arrow-head.
        """
        points = self.points
        last_pt = points[-1]
        second_last_pt = points[-2]

        last_segment_dir = last_pt - second_last_pt
        last_segment_length = last_segment_dir.length

        arrow_size = self.arrow_size
        if last_segment_length < arrow_size:
            msg = ("Could not construct the Leader, the arrow_size {} is "
                   "bigger than the last segment {}. Object: {!r}.")
            raise RuntimeError(msg.format(arrow_size, last_segment_length,
                                          self))

        trimmed_length = last_segment_length - arrow_size
        trimmed_last_pt = (second_last_pt +
                           last_segment_dir.normalized * trimmed_length)
        return points[:-1] + [trimmed_last_pt]

    @Part(in_tree=False)
    def curve(self):
        return Polygon(self.curve_pts, force_closure=False)

    @Attribute
    def arrow_direction(self):
        return self.curve.tangent2

    @Attribute
    def arrow_points(self):
        return self.get_arrow_points(self.points[-1], self.arrow_direction,
                                     self.arrow_size, self.arrow_angle,
                                     self.plane_normal)

    @Part(in_tree=False)
    def arrow_head(self):
        return PolygonalFace(self.arrow_points)

    @Attribute
    def annotation_location(self):
        return self.curve.start + self.annotation_outward_dir * self.gap

    @Attribute
    def annotation_outward_dir(self):
        return -self.curve.tangent1

    @Attribute
    def annotation_up_dir(self):
        outward_dir = self.annotation_outward_dir
        up_direction = self.plane_normal.cross(outward_dir)
        if up_direction * self.up_reference < 0:
            up_direction = -up_direction
        return up_direction

    @Attribute
    def annotation_right_dir(self):
        right_direction = self.annotation_outward_dir
        if right_direction * self.right_reference < 0:
            right_direction = -right_direction
        return right_direction

    @Attribute
    def annotation_position(self):
        """The position of the location. The x-direction will point away
        from the curve. The y-direction will be aligned with
        :attr:`up_reference`.

        :rtype: parapy.geom.Position
        """
        return Position(location=self.annotation_location,
                        orientation=Orientation(x=self.annotation_outward_dir,
                                                y=self.annotation_up_dir))

    @Attribute(private=True)
    def built_from(self):
        leader_arrow = [self.curve, self.arrow_head]

        if self.annotation:
            return leader_arrow + [self.annotation]
        else:
            return leader_arrow

    @staticmethod
    def get_arrow_points(tip, direction, size, angle, plane_normal):
        arrow_dir = direction.normalized
        plane_normal = plane_normal.normalized

        base_direction = arrow_dir.cross(plane_normal)
        arrow_base_size = tan(angle) * size
        sized_base_dir = base_direction.normalized * arrow_base_size

        base_pt = tip + (-arrow_dir) * size
        base_pt1 = base_pt + sized_base_dir
        base_pt2 = base_pt - sized_base_dir

        return tip, base_pt1, base_pt2


class TextLeader(Leader):
    """A :class:`Leader` with a ``text`` as annotation.

    Usage:

    >>> from parapy.geom import Point, TextLeader
    >>> pts = [Point(0, 0, 0), Point(1, 1, 0), Point(2, 1, 0)]
    >>> leader = TextLeader(pts, "foo")

    """

    VANCHOR_OPTIONS = ('bottom', 'center', 'top')

    __initargs__ = "points", "text"

    #: Text to be displayed at the end of the Leader
    #: :type: str
    text = Input()

    #: Size of the text, see ``size`` in :class:`TextShape`.
    #: :type: float
    text_size = Input(1.)

    #: Font of the text, see ``size`` in :class:`TextShape`.
    #: :type: str
    text_font = Input('Arial')

    #: Is it bold text?
    #: :type: is it bold text?
    text_bold = Input(False, widget=CheckBox)

    #: Is it italic text?
    #: :type: bool
    text_italic = Input(False, widget=CheckBox)

    #: Vertically seen, relative to the text, where is the anchor-point of
    #: the text?
    #: Options 'bottom', 'center' and 'top'.
    #: :type: str
    text_vanchor = Input('center',
                         widget=Dropdown(VANCHOR_OPTIONS),
                         validator=OneOf(VANCHOR_OPTIONS))

    @Attribute
    def text_anchor(self):
        """If the text goes against the curve its outward-direction, it needs
        to have its anchor-point on the right-side, otherwise the
        text-direction is outward, so the anchor-point can be on the left-side.

        :rtype: str
        """
        if self.annotation_right_dir * self.annotation_outward_dir < 0:
            return 'right'
        else:
            return 'left'

    @Attribute
    def text_position(self):
        annotation_position = self.annotation_position
        right_dir = self.annotation_right_dir
        if right_dir == self.annotation_outward_dir:
            return annotation_position
        else:
            text_ori = Orientation(x=right_dir, y=annotation_position.Vy)
            return annotation_position.replace(orientation=text_ori)

    @Part(in_tree=False)
    def annotation(self):
        return TextShape(self.text, size=self.text_size, font=self.text_font,
                         bold=self.text_bold, italic=self.text_italic,
                         vanchor=self.text_vanchor, anchor=self.text_anchor,
                         position=self.text_position)


if __name__ == '__main__':
    from parapy.geom import (
        Box, Cylinder, AngleDimension,
        AngleDimension3Points, LengthDimension,
        RadiusDimension, DiameterDimension, Point)
    from parapy.gui import display

    ##############
    # Dimensions #
    ##############

    dim_examples = []

    # length
    box = Box(1, 2, 3)
    obj = LengthDimension(shape=box.front_face,
                          other_shape=box.rear_face)
    dim_examples.append((obj, obj.shape, obj.other_shape))

    # radius
    cyl = Cylinder(radius=0.1, height=3)
    obj = RadiusDimension(shape=cyl.top_face)
    dim_examples.append((obj, obj.shape))

    # diameter
    obj = DiameterDimension(shape=cyl.top_face)
    dim_examples.append((obj, obj.shape))

    # angle
    obj = AngleDimension(shape=box.front_face,
                         other_shape=box.right_face)
    dim_examples.append((obj, obj.shape, obj.other_shape))

    # angle 3 points
    obj = AngleDimension3Points(start=Point(1, 0, 0),
                                center=Point(0.5, 1, 1),
                                end=Point(0, 0, 0))
    dim_examples.append((obj, obj.start, obj.center, obj.end))

    display(dim_examples)

