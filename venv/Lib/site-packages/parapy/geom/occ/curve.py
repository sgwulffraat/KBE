#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import logging
import math
import os
import warnings
from itertools import combinations
from numbers import Number
from operator import itemgetter

from OCC.wrapper.BRepBuilderAPI import BRepBuilderAPI_MakeEdge, BRepBuilderAPI_MakeWire
from OCC.wrapper.BRepExtrema import BRepExtrema_ExtPC
from OCC.wrapper.BSplCLib import BSplCLib__Reparametrize
from OCC.wrapper.Bnd import Bnd_Box
from OCC.wrapper.BndLib import BndLib_Add3dCurve
from OCC.wrapper.Convert import Convert_Polynomial
from OCC.wrapper.GC import GC_MakeArcOfCircle, GC_MakeCircle, GC_MakeSegment
from OCC.wrapper.GCPnts import GCPnts_AbscissaPoint, GCPnts_UniformAbscissa
from OCC.wrapper.Geom import (
    Geom_BSplineCurve, Geom_BezierCurve, Geom_Circle,
    Geom_Ellipse, Geom_Line, Geom_OffsetCurve,
    Geom_TrimmedCurve,
    Handle_Geom_BSplineCurve, Handle_Geom_BezierCurve,
    Handle_Geom_BoundedCurve, Handle_Geom_Circle,
    Handle_Geom_Curve,
    Handle_Geom_Ellipse, Handle_Geom_Line,
    Handle_Geom_TrimmedCurve)
from OCC.wrapper.GeomAPI import (
    GeomAPI_ExtremaCurveCurve,
    GeomAPI_ExtremaCurveSurface,
    GeomAPI_IntCS, GeomAPI_Interpolate,
    GeomAPI_PointsToBSpline, GeomAPI_ProjectPointOnCurve, GeomAPI__To2d)
from OCC.wrapper.GeomAbs import (
    GeomAbs_BSplineCurve, GeomAbs_BezierCurve, GeomAbs_C0,
    GeomAbs_C1, GeomAbs_C2, GeomAbs_Circle,
    GeomAbs_Ellipse, GeomAbs_Hyperbola,
    GeomAbs_Line, GeomAbs_Parabola)
from OCC.wrapper.GeomAdaptor import (
    GeomAdaptor_Curve, GeomAdaptor_HCurve,
    GeomAdaptor_HSurface, GeomAdaptor_Surface)
from OCC.wrapper.GeomConvert import (
    GeomConvert_ApproxCurve,
    GeomConvert_BSplineCurveKnotSplitting,
    GeomConvert_BSplineCurveToBezierCurve,
    GeomConvert_CompCurveToBSplineCurve,
    GeomConvert__CurveToBSplineCurve,
    GeomConvert__SplitBSplineCurve)
from OCC.wrapper.GeomLProp import GeomLProp_CLProps
from OCC.wrapper.GeomLib import GeomLib__ExtendCurveToPoint
from OCC.wrapper.GeomProjLib import GeomProjLib__Project
from OCC.wrapper.Precision import Precision__Parametric
from OCC.wrapper.ProjLib import ProjLib_ProjectedCurve
from OCC.wrapper.ShapeAnalysis import ShapeAnalysis_Curve
from OCC.wrapper.TColgp import TColgp_SequenceOfPnt
from OCC.wrapper.TopAbs import TopAbs_EDGE
from OCC.wrapper.gp import gp_Circ  # gp_Pnt2d, gp_Dir2d, gp_Ax2d,
from OCC.utils.top import downcast_shape
from OCC.utils.utilities import handle_deref_class, handle_is_instance

from parapy.core import (
    Attribute, Input, Part, child, derived, lazy_hasattr, list_of_numbers, val)
from parapy.core.exceptions import ParaPyDeprecationWarning
from parapy.core.utilities import raise_conditionally
from parapy.geom.generic import GeomBase, translate
from parapy.geom.generic.positioning import (
    AbstractPoint, OXY, Point, V0, VZ,
    XOY, orthogonal_vector)
from parapy.geom.globs import CONFIGURATION, ICN_DIR
from parapy.geom.occ.drawable import DrawableShape
from parapy.geom.occ.mixins import TransformationMixin
from parapy.geom.occ.patched.tcol import *  # @UnusedWildImport
from parapy.geom.occ.utilities import resolve_gce_status

C_CONTINUITY = (GeomAbs_C0, GeomAbs_C1, GeomAbs_C2)


def Curve_Handle_Geom_Curve_validator(value, obj, _):
    """Curve Handle_Geom_Curve should be of type __Handle_Geom_Curve__"""
    try:
        return handle_is_instance(value, obj.__Handle_Geom_Curve__)
    except NotImplementedError:
        return False


class Curve(DrawableShape, TransformationMixin):
    """Curve is the abstract base class of all Curve object and wraps
    around a OpenCascade Geom_Curve
    """

    __icon__ = os.path.join(ICN_DIR, 'curve.png')
    __Handle_Geom_Curve__ = Handle_Geom_Curve

    # 7:Vertex,6:Edge,5:Wire,4:Face,3:Shell,2:Solid,1:CompSolid,0:Compound
    TOPOLEVEL = 6
    TOPODIM = 1
    EdgeClass = None

    #: contains possible _transformation info
    _transformation = Input(None)

    #: Either a valid string from parapy.globals.X11_COLORS or a 3-integer
    #: iterable with RGB values. RGB ranges 0-255. For example [255,192,203] is
    #: a list.
    #: :type: str | collections.Sequence[int, int, int]
    color = Input("black", defaulting=True)

    @Input(validator=Curve_Handle_Geom_Curve_validator, private=True)
    def Handle_Geom_Curve(self):
        """:rtype: OCC.Geom.Handle_Geom_Curve"""
        raise NotImplementedError

    # =========================================================================
    # Curve representations
    # =========================================================================
    @property
    def _new_curve_type(self):
        """Used by ClonedCurve to decide Curve type to return. Curves can
        override this method."""
        return Curve

    # TODO (TBD): Scheduled for deletion.
    # /todo Not necessary any longer with new wrapper logic
    @Attribute
    def _Geom_Curve(self):
        """Return this curve as an OCC Geom_Curve class

        :rtype: OCC.Geom.Geom_Curve
        """
        msg = ('_Geom_Curve deprecated, use Handle_Geom_Curve instead. '
               'Object: {}.')
        warnings.warn(msg.format(self), ParaPyDeprecationWarning, stacklevel=4)
        handle = self.Handle_Geom_Curve
        cls = handle_deref_class(handle)
        simple_crv = cls.__new__(cls)
        simple_crv.this = handle.get()
        simple_crv.__handle__ = handle
        return simple_crv

    def _new_handle(self):
        """Return a new handle_geom_curve copy of type
        __Handle_Geom_Curve__

        :rtype: OCC.Geom.Handle_Geom_Curve
        """
        return self.__Handle_Geom_Curve__(self.Handle_Geom_Curve)

    @Attribute(private=True)
    def Handle_Geom2d_Curve(self):
        """
        :rtype: OCC.Geom2d.Handle_Geom2d_Curve
        """
        return GeomAPI__To2d(self.Handle_Geom_Curve, getattr(OXY, "gp_Pln"))

    @Attribute
    def curve2d(self):
        """A 2D version of this curve, located in the X, Y plane of the global
        axis system.

        :rtype: parapy.geom.occ.curve2d.Curve2d
        """
        # to suppress circular import
        from parapy.geom.occ.curve2d import ClonedCurve2d
        return ClonedCurve2d(self.Handle_Geom2d_Curve)

    @Attribute(private=True)
    def TopoDS_Shape(self):
        """
        :rtype: OCC.TopoDS.TopoDS_Edge
        """
        return BRepBuilderAPI_MakeEdge(self.Handle_Geom_Curve).Edge()

    @property
    def brep(self):
        return self.EdgeClass(TopoDS_Shape=self.TopoDS_Shape)

    @Attribute
    def vertices(self):
        return self.brep.vertices

    @Attribute
    def ordered_vertices(self):
        """
        :rtype: list[parapy.geom.occ.vertex.Vertex_]
        """
        return self.brep.ordered_vertices

    @Attribute
    def first_vertex(self):
        """
        :rtype: parapy.geom.occ.vertex.Vertex_
        """
        return self.brep.first_vertex

    @Attribute
    def last_vertex(self):
        """
        :rtype: parapy.geom.occ.vertex.Vertex_
        """
        return self.brep.last_vertex

    @Attribute(private=True)
    def TopoDS_Edge(self):
        """:rtype: OCC.TopoDS.TopoDS_Edge"""
        return downcast_shape(self.TopoDS_Shape, TopAbs_EDGE)

    @Attribute(private=True)
    def TopoDS_Wire(self):
        """
        :rtype: OCC.TopoDS.TopoDS_Wire
        """
        # It is possible to built a wire, but it's rarely necessary (will
        # have just one edge)
        return BRepBuilderAPI_MakeWire(self.TopoDS_Edge).Wire()

    @Attribute
    def _Adaptor3d_Curve(self):
        """
        :rtype: OCC.GeomAdaptor.GeomAdaptor_Curve
        """
        return GeomAdaptor_Curve(self.Handle_Geom_Curve)

    @Attribute
    def _ShapeAnalysis_Curve(self):
        """
        :rtype: OCC.ShapeAnalysis.ShapeAnalysis_Curve
        """
        return ShapeAnalysis_Curve()

    def dynamic_type(self, Handle_Geom_Curve=None):
        """Return the name of the dynamic OCC class of object
        `Handle_Geom_Curve`.

        Usage:

        >>> from parapy.geom import LineSegment, Point
        >>> crv = LineSegment(Point(1, 0, 0), Point(0, 0, 0))
        >>> print(crv.dynamic_type())
        Geom_TrimmedCurve

        :param OCC.Standard.Standard_Transient|None Handle_Geom_Curve:
        :rtype: str
        """
        handle = Handle_Geom_Curve or self.Handle_Geom_Curve
        return handle.DynamicType().Name()

    def is_dynamic_subclass_of(self, name):
        """Name is one of:

        - "Geom_BSplineCurve"
        - "Geom_BezierCurve"

        For more information,
        see `Open Cascade Documentation
        <http://opencascade.sourcearchive.com/documentation/6.3.0.dfsg.1-1/classGeom__Curve.html>`__.

        :param str name: name of class that is, or is not a subclass of this
            class.
        :rtype: bool
        """
        return self.Handle_Geom_Curve.DynamicType().SubType(name)

    @Attribute
    def downcast(self):
        """Get a more specific representation of this object"""
        h_geom_curve, class_ = Handle_Geom_Curve2ParaPy(self.Handle_Geom_Curve)
        return class_(Handle_Geom_Curve=h_geom_curve)

    # =========================================================================
    # Points on the curve
    # =========================================================================
    @Attribute
    def start(self):
        """Start point of this curve.

        :rtype: parapy.geom.Point
        """
        return self.point(self.u1)

    @Attribute
    def end(self):
        """End point of this curve.

        :rtype: parapy.geom.Point
        """
        return self.point(self.u2)

    @Attribute
    def point1(self):
        """synonym for start point

        :rtype: parapy.geom.Point
        """
        return self.start

    @Attribute
    def point2(self):
        """synonym for end point.

        :rtype: parapy.geom.Point
        """
        return self.end

    @Attribute
    def midpoint(self):
        """Point at parametric midpoint of this curve.

        :rtype: parapy.geom.Point
        """
        return self.point(self.u1 + (self.u2 - self.u1) / 2)

    @Attribute
    def sample_points(self):
        """Return sample points which will serve as linearisation.

        :rtype: list[Point]
        """
        pts = TColgp_SequenceOfPnt()
        ShapeAnalysis_Curve.GetSamplePoints(
            self.Handle_Geom_Curve, self.u1, self.u2, pts)
        return [Point(*pts.Value(i).Coord()) for i in
                range(1, pts.Length() + 1)]

    def point(self, u):
        """Return point at parameter ``u``. Usage:

        >>> from parapy.geom import Point, LineSegment
        >>> crv = LineSegment(Point(0, 0, 0), Point(1, 0, 0))
        >>> crv.point(0.3)
        Point(0.3, 0.0, 0.0)

        :param float u: u parameter of curve
        :rtype: parapy.geom.Point
        """
        return Point(*self._Adaptor3d_Curve.Value(u).Coord())

    def point_at_parameter(self, u):
        """Return point at parameter ``u``. Usage:

        >>> from parapy.geom import Point, LineSegment
        >>> crv = LineSegment(Point(0, 0, 0), Point(1, 0, 0))
        >>> crv.point_at_parameter(0.3)
        Point(0.3, 0.0, 0.0)

        :param float u: u-parameter of curve
        :rtype: parapy.geom.Point
        """
        return self.point(u)

    def point_at_length(self, length, u0=None):
        """Return point at ``length`` from parameter ``u0``. Usage:

        >>> from parapy.geom import Point, LineSegment
        >>> crv = LineSegment(Point(0, 0, 0), Point(1, 0, 0))
        >>> crv.point_at_length(0.3)
        Point(0.3, 0.0, 0.0)

        :param float length: length from u0
        :param float u0: u parameter starting point
        :rtype: parapy.geom.Point
        """
        return self.point(self.parameter_at_length(length, u0))

    def projected_point(self, point, precision=1e-7, AdjustToEnds=True):
        """Project a Point on a Curve. Return the result as a dict::

            {"point": Point,
             "u": parameter on curve (Number),
             "distance": distance between given point and compute one (Number)}

        Usage:

        >>> from parapy.geom import Point, LineSegment
        >>> crv = LineSegment(Point(0, 0, 0), Point(1, 0, 0))
        >>> pt = Point(0.3, 0.5, 0)
        >>> dct = crv.projected_point(pt)
        >>> dct['point']
        Point(0.3, 0.0, 0.0)
        >>> dct['u']
        0.3
        >>> dct['distance']
        0.5

        :param Point point: point to be projected on curve
        :param float precision:
        :param bool AdjustToEnds: point is adjusted to end of curve if distance
            is less than precision.
        :rtype: dict[str, parapy.geom.Point | float]
        :returns: {"point": Point, "u": float, "distance": float}
        """

        proj = gp_Pnt()
        distance, p = self._ShapeAnalysis_Curve.Project(
            self._Adaptor3d_Curve, gp_Pnt(*point),
            precision, proj, AdjustToEnds)
        return {"point": Point(*proj.Coord()),
                "u": p,
                "distance": distance}

    def equispaced_parameters(self, n, u1=None, u2=None, use_length=True):
        """Return ``n`` parameters. ``use_length`` == ``True`` for equal
        distance between points. Set ``use_length`` == ``False`` for equal
        paramatric distance between points. Usage:

        >>> from parapy.geom import LineSegment, Point
        >>> crv = LineSegment(Point(0, 0, 0), Point(1, 0, 0))
        >>> crv.equispaced_parameters(4)  # doctest: +ELLIPSIS
        [0.0, 0.33..., 0.66..., 1.0]

        :param int n: required number of parameters
        :param float u1: u1 parameter of curve
        :param float u2: u2 parameter of curve
        :param bool use_length: if False, uses equal parametric distance
        between points
        :rtype: list[Float]
        """
        u1 = u1 if u1 is not None else self.u1
        u2 = u2 if u2 is not None else self.u2
        if use_length:
            adaptor = self._Adaptor3d_Curve
            algo = GCPnts_UniformAbscissa(adaptor, n, u1, u2)
            return [algo.Parameter(i) for i in range(1, n + 1)]
        else:
            return list_of_numbers(u1, u2, n)

    def equispaced_points(self, n, u1=None, u2=None, use_length=True):
        """Return ``n`` equi-spaced points on the curve. Points have equal
        arc length spacing if ``use_length`` is ``True``, else equal parametric
        spacing. Start- and end-points of the spacing can be given with ``u1``
        and ``u2``, both defaulting to 0 and 1.

        Usage:

        >>> from parapy.geom import LineSegment, Point
        >>> crv = LineSegment(Point(0, 0, 0), Point(1, 0, 0))
        >>> crv.equispaced_points(4)  # doctest: +ELLIPSIS
        [Point(0.0, 0.0, 0.0), Point(0.33..., 0.0, 0.0),
         Point(0.66..., 0.0, 0.0), Point(1.0, 0.0, 0.0)]

        :param int n: required number of points
        :param float u1: u1 parameter of curve
        :param float u2: u2 parameter of curve
        :param bool use_length: if false, uses equal parametric distance
            between points
        :rtype: list[parapy.geom.Point]
        """
        u1 = u1 if u1 is not None else self.u1
        u2 = u2 if u2 is not None else self.u2
        adaptor = self._Adaptor3d_Curve
        if use_length:
            algo = GCPnts_UniformAbscissa(adaptor, n, u1, u2)
            parameter_range = (algo.Parameter(i) for i in range(1, n + 1))
        else:
            parameter_range = list_of_numbers(self.u1, self.u2, n)
        return [adaptor.Value(u).point for u in parameter_range]

    # =========================================================================
    # Position on the curve
    # =========================================================================
    @Attribute
    def position1(self):
        """Return a Position instance at start of curve. z-vector aligned
        with tangent, x-vector with normal.

        .. note:: this will only work if curvature is non-zero. See
            :py:meth:`get_position` for more options.

        :rtype: parapy.geom.Position
        :raises: RuntimeError - if start curvature is zero.
        """
        return self.get_position(self.u1)

    @Attribute
    def position2(self):
        """Return a Position instance at end of curve. z-vector aligned
        with tangent, x-vector with normal.

        .. note:: this will only work if curvature is non-zero. See
            :py:meth:`get_position` for more options.

        :rtype: parapy.geom.Position
        :raises: RuntimeError - if start curvature is zero.
        """
        return self.get_position(self.u2)

    def get_position(self, u, binormal=None):
        """Returns a position object at parameter ``u``. If the local
        curvature is zero, either plane_normal or random normal vector is
        used. You may specify a ``binormal``.

        - position.location: curve.point(u)
        - position.Vz: curve.tangent(u)
        - position.Vx: curve.normal(u[, binormal])
        - position.Vy: Vector.cross(Vx, Vz)

        :param float u: parameter on curve.
        :param binormal: optional binormal vector. You **have** to specify
            this, if the curve is not planar.
        :type binormal: None | parapy.geom.Vector
        :rtype: parapy.geom.Position
        """
        tangent = self.tangent(u)
        try:
            normal = self.normal(u, binormal=binormal)
        except ZeroCurvature:
            if self.is_planar_with_tolerance():
                normal = self.plane_normal
            else:
                msg = ("Arbitrary x-Vector of Position due to (local) zero "
                       "curvature.Consider specifying binormal "
                       "argument. Object: {}")
                logging.warning(msg.format(self))

                normal = orthogonal_vector(tangent)
        return Position(self.point(u), Orientation(x=normal, z=tangent))

    # =========================================================================
    # Parameters
    # =========================================================================
    @Attribute
    def u1(self):
        """
        Start parameter of this curve.
        :rtype: float
        """
        return self._Adaptor3d_Curve.FirstParameter()

    @Attribute
    def u2(self):
        """End parameter of this curve.

        :rtype: float
        """
        return self._Adaptor3d_Curve.LastParameter()

    @Attribute
    def u_min(self):
        """Synonym for u1 parameter of the curve

        :rtype: float
        """
        return self.u1

    @Attribute
    def u_max(self):
        """Synonym for u2 parameter of the curve

        :rtype: float
        """
        return self.u2

    @Attribute
    def du(self):
        """The total parametric length (u2 - u1)

        :rtype: float
        """
        return self.u2 - self.u1

    def parameter_at_length(self, length, u0=None, failure='raise',
                            precision=None):
        """Return parameter on curve at length. Optionally u0 defines start
        parameter for search. Defaults to :attr:`u1`. Usage:

        >>> from parapy.geom import Point, LineSegment, BSplineCurve
        >>> # case 1: parametrization matches length: u1=0.0, u2=2.0
        >>> crv = LineSegment(Point(0, 0, 0), Point(2, 0, 0))
        >>> crv.parameter_at_length(1.0)
        1.0
        >>> crv.parameter_at_length(1.0, u0=0.25)
        1.25
        >>> # case 2: parametrization does not match length: u1=0.0, u2=1.0
        >>> crv = BSplineCurve([Point(0, 0, 0), Point(2, 0, 0)])
        >>> crv.parameter_at_length(1.0)
        0.5
        >>> crv.parameter_at_length(1.0, u0=0.25)
        0.75

        :param float length: length from ``u0``.
        :param float u0: start parameter for search, defaults to :attr:`u1`.
        :rtype: float
        :param float | None precision: The precision of the result. Set to
            :py:`None` for default precision.
        :raises RuntimeError: if algorithm doesn't converge and
            :py:`failure='raise'`.
        """
        u0 = u0 if u0 is not None else self.u1

        if precision is None:
            measure = GCPnts_AbscissaPoint(self._Adaptor3d_Curve, length, u0)
        else:
            measure = GCPnts_AbscissaPoint(precision, self._Adaptor3d_Curve,
                                           length, u0)

        if not measure.IsDone():
            msg = ("Curve.parameter_at_length(): algorithm has not converged. "
                   "Make sure 'length' and 'u0' are appropriate. As a last "
                   "resort, consider setting 'failure' to 'warn' or 'ignore'. "
                   "Object: {}.")
            raise_conditionally(RuntimeError, failure, msg.format(self))
        return measure.Parameter()

    # TODO (RvD): raise if 'distance' is larger than precision?
    def parameter_at_point(self, point, precision=1e-7, AdjustToEnds=True):
        """Returns parameter at point on curve. For more information,
        see `Open Cascade Documentation
        <http://opencascade.sourcearchive.com/documentation/6.3.0.dfsg.1-1
        /classShapeAnalysis__Curve_e24d4b3948c5305a8b54ddc5e02f00da.html#
        e24d4b3948c5305a8b54ddc5e02f00da>`__. Usage:

        >>> from parapy.geom import Point, LineSegment, BSplineCurve
        >>> # case 1: parametrization matches length: u1=0.0, u2=2.0
        >>> crv = LineSegment(Point(0, 0, 0), Point(2, 0, 0))
        >>> crv.parameter_at_point(Point(1, 0, 0))
        1.0
        >>> # method can extrapolate when point falls outside u1-u2 range
        >>> crv.parameter_at_point(Point(3.0, 0, 0))
        3.0
        >>> crv.parameter_at_point(Point(2.001, 0, 0))
        2.001
        >>> # algorithm will adjust parameter to end if distance < precision
        >>> crv.parameter_at_point(Point(2.001, 0, 0), precision=2e-3)
        2.0
        >>> # you can override is, by explicitly stating AdjustToEnds=False
        >>> crv.parameter_at_point(Point(2.001, 0, 0), precision=2e-3,
        ...                        AdjustToEnds=False)
        2.001
        >>> # case 2: parametrization does not match length: u1=0.0, u2=1.0
        >>> crv = BSplineCurve([Point(0, 0, 0), Point(2, 0, 0)])
        >>> crv.parameter_at_point(Point(1, 0, 0))
        0.5

        :param parapy.geom.Point point: point on curve.
        :param float precision: point on curve.
        :param bool AdjustToEnds: parameter is set to end of curve if distance
            is less than ``precision``.
        :rtype: float
        """
        dct = self.projected_point(point, precision, AdjustToEnds=AdjustToEnds)
        return dct["u"]

    def parameter(self, *args, **kwargs):
        msg = ("Curve.parameter() has been deprecated, use "
               "Curve.parameter_at_length(). Object: {}.")
        warnings.warn(msg.format(self), ParaPyDeprecationWarning, stacklevel=2)
        return self.parameter_at_length(*args, **kwargs)

    def is_point_inside(self, point, precision=1.0e-7):
        """Does ``point`` lie on the curve within ``precision``? Usage:

        >>> from parapy.geom import Point, BezierCurve
        >>> points = [Point(0, 0, 0), Point(0, 1, 0),
        ...           Point(1, 1, 0), Point(1, 0, 0)]
        >>> crv = BezierCurve(control_points=points)
        >>> # let's see if midpoint lies inside curve
        >>> crv.is_point_inside(Point(0.5, 0.75, 0.0))
        True
        >>> crv.is_point_inside(Point(0.5, 0.751, 0.0))
        False
        >>> crv.is_point_inside(Point(0.5, 0.751, 0.0), precision=2e-3)
        True

        :param parapy.geom.Point point: point on curve.
        :param float precision: point on curve.
        :rtype: float
        """
        dct = self.projected_point(point, precision, AdjustToEnds=False)
        u = dct['u']

        adapt = self._Adaptor3d_Curve
        vec = adapt.DN(u, 1)
        precision_2d = Precision__Parametric(precision,
                                             vec.Magnitude())

        # Arranged inequality to isolate precision following the recommendation
        # from opencascade when using precision.
        return (dct["distance"] <= precision and
                self.u1 - u <= precision_2d and
                u - self.u2 <= precision_2d)

    @Attribute
    def tangent1(self):
        """unit vector at start point.

        :rtype: parapy.geom.Vector
        """
        return self.derivative(self.u1)

    @Attribute
    def tangent2(self):
        """unit vector at end point.

        :rtype: parapy.geom.Vector
        """
        return self.derivative(self.u2)

    @Attribute
    def normal1(self):
        """Return normal at start point. This will only work for planar
        curves!!! Use normal() for more control

        :rtype: parapy.geom.Vector
        """
        return self.normal(self.u1)

    @Attribute
    def normal2(self):
        """Return normal at end point.

        :rtype: parapy.geom.Vector
        """
        return self.normal(self.u2)

    @Attribute
    def direction_vector(self):
        """Unit vector from start to end of curve. Warns in case of
        zero-vector.

        :rtype: parapy.geom.Vector
        """
        pt1 = self.start
        pt2 = self.end
        if pt1 == pt2:
            warnings.warn("direction_vector: closed curve -> zero-vector")
            return V0
        else:
            return pt1.vector_to(pt2).normalized

    def derivate(self, u, order=1):
        msg = 'derivate() deprecated, use derivative() instead. Object: {}.'
        warnings.warn(msg.format(self), ParaPyDeprecationWarning, stacklevel=2)
        return self.derivative(u, order=order)

    def derivative(self, u, order=1):
        """Return **unit** derivative at u parameter. Similar to
        Curve.tangent but with optional :py:`order` control, e.g. order=1
        return first-order derivative. Error is raised if the
        requested order of derivative, `order`, is higher than the continuity
        of the curve.

        Usage:

        >>> from parapy.geom import Point, BezierCurve
        >>> points = [Point(-1, 0, 0), Point(-1, 1, 0), Point(1, 1, 0),
        ... Point(1, 0, 0)]
        >>> crv = BezierCurve(control_points=points)
        >>> #Let's find the first derivative at the turning point of the curve
        >>> crv.derivative(0.5)
        Vector(1.0, 0.0, 0.0)
        >>> #Let's find the second derivative at the turning point of the
        ... # curve, showing if the point is a minimum (second derivative <
        ... # 0) or maximum (second derivative > 0).
        >>> crv.derivative(0.5,order=2)
        Vector(0.0, -1.0, 0.0)
        >>> #Let's find another derivative
        >>> crv.derivative(0.25)
        Vector(0.832050294338, 0.554700196225, 0.0)

        :param float u: parameter on curve.
        :param int order: order of the derivative, viz. 1 is tangent.
        :rtype: parapy.geom.Vector
        """
        adapt = self._Adaptor3d_Curve
        vec = adapt.DN(u, order)

        # normalizing zero vector will cause RuntimeError
        try:
            vec.Normalize()
        except RuntimeError:
            x, y, z = vec.Coord()
            if x == 0. and y == 0. and z == 0.:
                # assume it was because of 0 vector
                pass
            else:  # the RunTime message that was before
                raise

        return Vector(*vec.Coord())

    def tangent(self, u):
        """The unit tangent vector at parameter u.

        Usage:

        >>> from parapy.geom import Point, BezierCurve
        >>> points = [Point(-1, 0, 0), Point(-1, 1, 0), Point(1, 1, 0),
        ... Point(1, 0, 0)]
        >>> crv = BezierCurve(control_points=points)
        >>> #Let's find the tangent at the turning point of the curve
        >>> crv.tangent(0.5)
        Vector(1.0, 0.0, 0.0)
        >>> #Let's find the normal at another parameter
        >>> crv.tangent(0.25)
        Vector(0.832050294338, 0.554700196225, 0.0)

        :param float u: parameter on curve.
        :rtype: parapy.geom.Vector
        """
        return self.derivative(u)

    def tangent_at_point(self, point):
        """Unit tangent vector at point.

        Usage:

        >>> from parapy.geom import Point, BezierCurve
        >>> points = [Point(-1, 0, 0), Point(-1, 1, 0),
        ...           Point(1, 1, 0),  Point(1, 0, 0)]
        >>> crv = BezierCurve(control_points=points)
        >>> # Let's first create a point on the curve
        >>> dct = crv.projected_point(Point(2, 2, 2))
        >>> # Let's now find the tangent at this point
        >>> crv.tangent_at_point(dct['point'])
        Vector(0.768321540869, -0.640064066978, 0.0)

        :param Point point: point on curve.
        :rtype: parapy.geom.Vector
        """
        return self.tangent(self.parameter_at_point(point))

    def normal(self, u, binormal=None, normalized=True):
        """The (unit) normal vector of this curve at parameter ``u``. It is
        perpendicular to the local curve tangent. The normal vector points
        towards the center of curvature. If the local curvature (viz.
        derivative
        of the tangent vector) at ``u`` is zero, the normal vector can not be
        calculated, unless the curve is planar. You may specify a ``binormal``
        which is used in the cross-product normal = tangent x binormal. Usage:

        >>> from parapy.geom import Point, BezierCurve
        >>> points = [Point(-1, 0, 0), Point(-1, 1, 0), Point(1, 1, 0),
        ... Point(1, 0, 0)]
        >>> crv = BezierCurve(control_points=points)
        >>> #Let's find the normal at the turning point of the curve
        >>> crv.normal(0.5)
        Vector(0.0, -1.0, 0.0)
        >>> #Let's find the normal at another parameter
        >>> crv.normal(0.25)
        Vector(0.554700196225, -0.832050294338, 0.0)

        :param float u: parameter at which to calculate the normal vector.
        :param binormal: optional binormal if local curvature is zero. Default
            is :py:`None`.
        :type binormal: None | parapy.geom.Vector
        :param bool normalized: normalized vector or not? Default is
            :py:`True`.
        :rtype: parapy.geom.Vector
        :raises: ZeroCurvature - local curvature is zero and curve isn't
            planar.
        """
        v = self.tangent(u)
        if binormal is None:
            try:
                return _get_normal(self._Adaptor3d_Curve, u, normalized)
            except ZeroCurvature:
                if self.is_planar_with_tolerance():
                    return self.plane_normal.cross(self.tangent(u))
                else:
                    msg = ("Normal vector couldn't be determined as the "
                           "(local) curvature is zero at parameter {}. "
                           "Consider specifying binormal. Object: {!r}")
                    raise ZeroCurvature(msg.format(u, self), obj=self)
        else:
            return binormal.normalized.cross(v)

    def normal_at_point(self, point, binormal=None):
        """See :py:meth:`~parapy.geom.occ.curve.normal`.

        :param parapy.geom.Point point: point along curve
        :param binormal: optional binormal if local curvature is zero.
            Default is :py:`None`.
        :type binormal: None | parapy.geom.Vector
        :rtype: parapy.geom.Point
        """
        return self.normal(self.parameter_at_point(point), binormal)

    def curvature(self, u, precision=1.0e-7):
        """Curvature at parameter ``u``.

        Usage:

        >>> from parapy.geom import Point, BezierCurve
        >>> points = [Point(-1, 0, 0), Point(-1, 1, 0), Point(1, 1, 0),
        ...             Point(1, 0, 0)]
        >>> crv = BezierCurve(control_points=points)
        >>> crv.curvature(0.3)
        7.68374908492

        :param float u: parameter along curve
        :param float precision:
        :rtype: float
        """
        props = GeomLProp_CLProps(self.Handle_Geom_Curve, 2, precision)
        props.SetParameter(u)
        return props.Curvature()

    def radius_of_curvature(self, u, precision=1.0e-7):
        """Radius of curvature at parameter ``u``.

        Usage:

        >>> from parapy.geom import Point, BezierCurve
        >>> points = [Point(-1, 0, 0), Point(-1, 1, 0), Point(1, 1, 0),
        ... Point(1, 0, 0)]
        >>> crv = BezierCurve(control_points=points)
        >>> crv.radius_of_curvature(0.3)
        1.0413797813198296

        :param float u: parameter along curve
        :param float precision:
        :rtype: float
        """
        c = self.curvature(u, precision=precision)
        return 1 / c

    def center_of_curvature(self, u, precision=1.0e-7):
        """Center of curvature at parameter ``u``.

        Usage:

        >>> from parapy.geom import Point, BezierCurve
        >>> points = [Point(-1, 0, 0), Point(-1, 1, 0), Point(1, 1, 0),
        ...     Point(1, 0, 0)]
        >>> crv = BezierCurve(control_points=points)
        >>> crv.center_of_curvature(0.3)
        Point(-0.120275862069, -0.310220689655, 0.0)

        :param float u: parameter along curve
        :param float precision:
        :rtype: parapy.geom.Point
        """
        pt = gp_Pnt()
        props = GeomLProp_CLProps(self.Handle_Geom_Curve, 2, precision)
        props.SetParameter(u)
        props.CentreOfCurvature(pt)
        return Point(*pt.Coord())

    # =========================================================================
    # Dimensional / topological aspects
    # =========================================================================
    @Attribute
    def length(self):
        """Total length of this curve with default precision. See
        :meth:`get_length` for more options.

        :rtype: float
        """
        return GCPnts_AbscissaPoint.Length(self._Adaptor3d_Curve)

    def get_length(self, u1=None, u2=None, precision=1e-6):
        """Length of this curve with ``precision`` and between parameters.
        ``u1`` and ``u2`` default to ``self.u1`` and ``self.u2``. Usage:

        >>> from parapy.geom import Point, BezierCurve
        >>> points = [Point(-1, 0, 0), Point(-1, 1, 0), Point(1, 1, 0),
        ... Point(1, 0, 0)]
        >>> crv = BezierCurve(control_points=points)
        >>> crv.get_length(u1=0.3, u2=0.5)
        0.585218473705

        :param None | float u1: Optional start parameter of curve
        :param None | float u2: Optional end parameter of curve
        :param None | float float precision:
        :rtype: float
        """
        if u1 is None and u2 is None:
            return GCPnts_AbscissaPoint.Length(self._Adaptor3d_Curve,
                                               precision)
        else:
            return GCPnts_AbscissaPoint.Length(
                self._Adaptor3d_Curve,
                u1 if not u1 is None else self.u1,
                u2 if not u2 is None else self.u2,
                precision)

    @Attribute
    def continuity(self):
        """ continuity of the curve

        :rtype: int
        """
        return self._Adaptor3d_Curve.Continuity()

    @Attribute
    def is_closed(self):
        """ is the curve closed?

        :rtype: bool
        """
        return bool(self._Adaptor3d_Curve.IsClosed())

    @Attribute
    def is_periodic(self):
        """ is the curve periodic?

        :rtype: int
        """
        return self._Adaptor3d_Curve.IsPeriodic()

    # =========================================================================
    # Feature recognition
    # =========================================================================
    @Attribute
    def is_straight(self):
        """Is the curve straight?

        :rtype: bool
        """
        return self.is_straight_with_tolerance()

    def is_straight_with_tolerance(self, tolerance: float = 0.0) -> bool:
        """Is this ``Curve`` straight within ``tolerance``?"""
        tangent = self.end - self.start

        # Take 2 orthogonal normals, and check if the curve is planar in
        # both directions. If so, the curve is straight.
        geom_curve = self.Handle_Geom_Curve
        normal = orthogonal_vector(tangent)
        if ShapeAnalysis_Curve.IsPlanar(
                geom_curve, gp_XYZ(*normal), tolerance):
            bi_normal = normal.cross(tangent)
            return ShapeAnalysis_Curve.IsPlanar(
                geom_curve, gp_XYZ(*bi_normal), tolerance)
        return False

    @Attribute
    def is_circular(self):
        """is the curve circular?

        :rtype: bool
        """
        return self.is_circular_with_tolerance()

    def is_circular_with_tolerance(self, tolerance: float = None) -> bool:
        """Is this ``Curve`` circular within ``tolerance``?"""
        raise NotImplementedError(f"is_circular_with_tolerance is not "
                                  f"implemented for {type(self)}")

    @Attribute
    def is_elliptical(self):
        """is the curve elliptical?

        :rtype: bool
        """
        return self.is_elliptical_with_tolerance()

    def is_elliptical_with_tolerance(self, tolerance: float = None) -> bool:
        """Is this ``Curve`` elliptical within ``tolerance``?"""
        raise NotImplementedError(f"is_elliptical_with_tolerance is not "
                                  f"implemented for {type(self)}")

    @Attribute
    def is_planar(self):
        """is the curve planar?

        :rtype: bool
        """
        return self.is_planar_with_tolerance()

    def is_planar_with_tolerance(self, tolerance=0.0):
        """Is this curve planar (within :py:`tolerance`)?

        :param float tolerance: :py:`tolerance == 0.0` means use
            default precision.
        :rtype: bool
        """
        return self._ShapeAnalysis_Curve.IsPlanar(
            self.Handle_Geom_Curve, gp_XYZ(0, 0, 0), tolerance)

    @Attribute
    def plane_normal(self):
        """If and only if your curve is planar, you can use this slot to
        determine the plane normal for you. It is the cross-product between
        the tangent and normal of the curve. In case this curve is a straight
        line, it is impossible to determine the normal vector uniquely
        (no curvature).

        :rtype: parapy.geom.Vector
        :raises: ZeroCurvature - if the curve is straight
        """
        normal = gp_XYZ()
        is_planar = ShapeAnalysis_Curve.IsPlanar(self.Handle_Geom_Curve,
                                                 normal)

        if not is_planar:
            raise RuntimeError("Your curve is not planar. Object: {self!r}")
        elif self.is_straight_with_tolerance():
            # everything zero vector
            msg = ("Plane normal could not be uniquely determined because "
                   "the line is straight. Use "
                   "normal(u, binormal=Vector(x, y, z)). Details: curve {:}.")
            raise ZeroCurvature(msg.format(self), obj=self)
        else:
            plane_normal = Vector(*normal.Coord())
            up = self.tangent1.cross(self.normal1)

            # let the normal point up (defined by tangent and normal)
            return plane_normal if up * plane_normal >= 0 else -plane_normal

    # ------------ extrema to other objects -------------
    def extremum(self, other, distance="min"):
        """Return extremum between this curve and ``other`` Point, Curve or
        Surface. The extremum, by default, minimizes the distance between a
        point on this curve and another point (on the other Curve or Surface).
        If you want to maximize the distance, set ``distance`` to ``"max"``.
        An extremum is a dict of the form::

            {"point": Point,
             "other_point": Point,
             "u": float,
             "distance": float,
             "other_u": float,      # only if ``other`` is Curve
             "other_uv": float      # only if ``other`` is Surface
             }

        Where:

        - "point": point on this curve
        - "u": parameter on this curve
        - "distance": distance between curve and ``other`` at this extremum
        - "other_point": point on ``other`` Curve / Surface (**optional**!)
        - "other_u": parameter on ``other`` Curve (**optional**!)
        - "other_uv": parameters on ``other`` Surface (**optional**!)

        :type other: AbstractPoint | Curve | Surface
        :param str distance: minimize ("min") or maximize ("max") distance?
        :rtype: dict[str, parapy.geom.Point | float]
        :raises RuntimeError: if ``other`` is not of type Point, Curve or
            Surface, or when there were no extrema found.
        """
        lst = self.extrema(other)
        if not lst:
            msg = "No extrema found between this curve and {:}."
            raise RuntimeError(msg.format(repr(other)))
        else:
            if distance == "min":
                return min(lst, key=lambda dct: dct["distance"])
            if distance == "max":
                return max(lst, key=lambda dct: dct["distance"])
            else:
                msg = "distance is either 'min' or 'max', not {:}"
                raise RuntimeError(msg.format(repr(distance)))

    def extrema(self, other):
        """List all extrema between this curve and ``other`` Point, Curve or
        Surface. An extrema minimizes or maximizes the distance between a
        point on this curve and a point (on the other Curve or Surface). An
        extrema is a dict of the form::

            [{"point": Point,
              "other_point": Point,
              "u": float,
              "distance": float,
              "other_u": float,      # only if other is Curve
              "other_uv": float      # only if other is Surface
              },
             # next extremum ...
             ]

        Where:

        - "point": point on this curve
        - "u": parameter on this curve
        - "distance": distance between curve and ``other`` at this extremum
        - "other_point": point on ``other`` Curve / Surface (**optional**!)
        - "other_u": parameter on ``other`` Curve (**optional**!)
        - "other_uv": parameters on ``other`` Surface (**optional**!)

        :type other: AbstractPoint | Curve | Surface
        :rtype: list[dict[str, parapy.geom.Point | float]]
        :raises RuntimeError: if ``other`` is not of type Point, Curve or
            Surface.
        """
        # TODO (TBD): Only seems to return minima. See #523 Author: FT.
        if isinstance(other, AbstractPoint):
            return self.point_extrema(other)
        elif lazy_hasattr(other, "Handle_Geom_Curve"):
            return self.curve_extrema(other)
        elif lazy_hasattr(other, "Handle_Geom_Surface"):
            return self.surface_extrema(other)
        else:
            msg = "{:} is not a valid Point, Curve or Surface object."
            raise RuntimeError(msg.format(repr(other)))

    def intersections(self, other, tolerance=1.0e-7):
        """List intersections between this curve and ``other``, either another
        Curve or a Surface. Each intersection is a dict of the form::

            [{"point": Point,
              "u", float,
              "other_u": float             # only if other is Curve,
              "other_uv": (float, float),  # only if other is Surface
              },
              # next intersection ..
            }

        Where:

        - "point": intersection Point
        - "u": parameter on this curve
        - "other_u":  parameter on ``other`` Curve (**optional**!)
        - "other_uv": parameters on ``other`` Surface (**optional**!)

        :type other: Point | Curve | Surface
        :param float tolerance: threshold for intersections. Default is
            1.0e-7. Only used for curve-curve and point-curve intersections.
        :rtype: list[dict]
        :raises RuntimeError: if ``other`` is not of type Curve or Surface.
        """
        if lazy_hasattr(other, "Handle_Geom_Curve"):
            return self.curve_intersections(other, tolerance=tolerance)
        elif lazy_hasattr(other, "Handle_Geom_Surface"):
            return self.surface_intersections(other)
        elif isinstance(other, Point):
            return self.point_intersections(other, tolerance=tolerance)
        else:
            msg = f"{other!r} is not a valid Point, Curve or Surface object."
            raise RuntimeError(msg)

    def intersection_points(self, other, tolerance=1.0e-7):
        """Return intersection points between curve and ``other`` curve or
        surface.

        :param Curve | Surface other: Intersection curve or shape
        :param float tolerance: threshold for curve-curve intersections.
            Default is 1.0e-7.
        :rtype: list[parapy.geom.Point]
        """
        ints = self.intersections(other, tolerance)
        return [i["point"] for i in ints]

    def intersection_point(self, other, tolerance=1.0e-7):
        """Return the intersection point between curve and ``other``, either
        another Curve, or Surface. Warns in case of multiple intersections.

        :type other: parapy.geom.Curve | parapy.geom.Surface
        :param float tolerance: threshold for curve-curve intersections.
            Default is 1.0e-7.
        :rtype: parapy.geom.Point
        :raises RuntimeError: if no intersections were found
        """
        points = self.intersection_points(other, tolerance)
        if points:
            if len(points) > 1:
                msg = ("Multiple intersections found between {} and {}. "
                       "Consider using Surface.intersection_points().")
                warnings.warn(msg.format(self, other))
            return points[0]
        else:
            msg = "No intersection found between {:} and {:}."
            raise RuntimeError(msg.format(self, other))

    def minimum_distance(self, other):
        """Return minimum distance between curve and ``other``, either a
        Point, Curve or Surface.

        Usage:

        >>> from parapy.geom import LineSegment, Point
        >>> crv = LineSegment(Point(0, 0, 0), Point(1, 0, 0))
        >>> crv.minimum_distance(Point(0.5, 0.5, 0))
        0.5

        :type other: Point | Curve | Surface
        :rtype: float
        :raises RuntimeError: if other is not valid Point, Curve or Surface.
        """
        lst = self.extrema(other)
        return min(lst, key=itemgetter("distance"))["distance"]

    def maximum_distance(self, other):
        """Return maximum distance between curve and ``other``, either a
        Point, Curve or Surface.

        :type other: Point | Curve | Surface
        :rtype: float
        """
        # TODO (TBD): Broken because of change in OCC API. Author: FT.
        lst = self.extrema(other)
        return max(lst, key=itemgetter("distance"))["distance"]

    def point_extrema(self, point):
        """Return a list of extrema found between this curve and ``point``.
        Each entry is a dictionary with information regarding the extremum:

        - "point": point on this curve
        - "other_point": other point
        - "u": parameter on this curve
        - "distance": distance between curve and ``point`` at this extremum

        :type point: AbstractPoint
        :rtype: list[dict[str, parapy.geom.Point | float]]
        :returns: [{"point", Point, "other_point": Point,
                    "u": float, "distance": float}, ...]
        """
        ext = BRepExtrema_ExtPC(point.TopoDS_Vertex, self.TopoDS_Edge)
        results = []
        if not ext.IsDone():
            return results
        for i in range(1, ext.NbExt() + 1):
            results.append({"point": Point(*ext.Point(i).Coord()),
                            "other_point": point,
                            "u": ext.Parameter(i),
                            "distance": math.sqrt(ext.SquareDistance(i))})
        return results

    def curve_extrema(self, other_curve):
        """Return list of extrema found between this curve and ``other_curve``.
        Each entry is a dictionary with information regarding the extremum:

        - "point": point on this curve
        - "other_point": point on ``other_curve``
        - "u": parameter on this curve
        - "other_u": parameter on ``other_curve``
        - "distance": distance between points

        :type other_curve: parapy.geom.Curve
        :rtype: list[dict[str, parapy.geom.Point | float]]
        :returns: [{"point", Point, "other_point": Point, "u": float,
                    "other_u": float, "distance": float}, ...]
        """
        ext = GeomAPI_ExtremaCurveCurve(self.Handle_Geom_Curve,
                                        other_curve.Handle_Geom_Curve)

        results = []
        for i in range(1, ext.NbExtrema() + 1):
            pt1, pt2 = gp_Pnt(), gp_Pnt()
            ext.Points(i, pt1, pt2)
            u1, u2 = ext.Parameters(i)
            results.append(
                {"point": Point(*pt1.Coord()),
                 "other_point": Point(*pt2.Coord()),
                 "u": u1,
                 "other_u": u2,
                 "distance": ext.Distance(i)})
        return results

    def surface_extrema(self, surface, w1=None, w2=None,
                        u1=None, u2=None, v1=None, v2=None, tolerance=1.0e-7):
        """Return list of extrema found between this curve and ``surface``.
        The algorithm minimizes or maximizes the distance between a point on
        the curve and a point on the surface. Thus, it computes start and end
        points of perpendiculars common to this curve and the surface. Each
        entry is a dictionary with information regarding the extremum:

        - "point": point on this curve
        - "other_point": point on ``surface``
        - "u": parameter on this curve
        - "other_uv": parameters on surface
        - "distance": distance between points

        :param surface: surface to find extrema to
        :type surface: parapy.geom.Surface
        :param w1: minimum u-parameter of this curve. If None, u_min is used.
        :type w1: None|float
        :param w2: maximum u-parameter of this curve. If None, u_max is used.
        :type w2: None|float
        :param u1: minimum u-parameter of the surface. If None, u_min is used.
        :type u1: None|float
        :param u2: maximum u-parameter of the surface. If None, u_max is used.
        :type u2: None|float
        :param v1: minimum v-parameter of the surface. If None, v_min is used.
        :type v1: None|float
        :param v2: maximum v-parameter of the surface. If None, v_max is used.
        :type v2: None|float
        :param float tolerance: coincident point tolerance. Used to remove
            duplicate results.
        :rtype: list[dict]
        :returns: [{"point", Point,
                    "other_point": Point,
                    "u": float,
                    "uv": (float, float),
                    "distance": float},
                    ...]

        .. caution:: this algorithm either finds minimum **or** the maximum
            extrema, typically not both. If you don't get the type of extrema
            you need, you may limit the parametric range of the curve over
            which this algorithm can search using ``w1`` and ``w2``.
        """
        if (w1 is not None or w2 is not None
            or u1 is not None or u2 is not None
            or v1 is not None or v2 is not None):
            if w1 is None:
                w1 = self.u1
            if w2 is None:
                w2 = self.u2
            if u1 is None:
                u1 = surface.u1
            if u2 is None:
                u2 = surface.u2
            if v1 is None:
                v1 = surface.v1
            if v2 is None:
                v2 = surface.v2
            ext = GeomAPI_ExtremaCurveSurface(self.Handle_Geom_Curve,
                                              surface.Handle_Geom_Surface,
                                              w1, w2, u1, u2, v1, v2)
        else:
            ext = GeomAPI_ExtremaCurveSurface(self.Handle_Geom_Curve,
                                              surface.Handle_Geom_Surface )

        results = []
        for i in range(1, ext.NbExtrema() + 1):
            pt1, pt2 = gp_Pnt(), gp_Pnt()
            ext.Points(i, pt1, pt2)
            w, u, v = ext.Parameters(i)

            pt1 = Point(*pt1.Coord())
            pt2 = Point(*pt2.Coord())
            for former_result in results:
                pt1_former = former_result["point"]
                pt2_former = former_result["other_point"]
                if (pt1.is_almost_equal(pt1_former, tolerance)
                    and pt2.is_almost_equal(pt2_former, tolerance)):
                    break
            else:
                results.append(
                        {"point": pt1,
                         "u": w,
                         "distance": ext.Distance(i),
                         "other_point": pt2,
                         "other_uv": (u, v)})
        return results

    def point_intersections(self, pt, tolerance=1e-7):
        """Return all intersections between this ``Curve`` and ``pt``, if they
        are within the ``tolerance``.

        :param Point pt:
        :param float tolerance: threshold for intersections. Default is 1.0e-7.
        :rtype: typing.List[typing.Dict[str, typing.Union[parapy.geom.Point, float]]]
        :returns: [{"point", Point, "u": float, "other_point": Point}, ...]
        """
        ext = GeomAPI_ProjectPointOnCurve(gp_Pnt(*pt), self.Handle_Geom_Curve,
                                          self.u1, self.u2)
        results = []
        for i in range(1, ext.NbPoints() + 1):
            distance = ext.Distance(i)
            if distance <= tolerance:
                pt_on_crv = Point(*ext.Point(i).Coord())
                u = ext.Parameter(i)
                inters = {"point": pt_on_crv, "other_point": pt, "u": u}
                results.append(inters)
        return results

    def curve_intersections(self, other_curve, tolerance=1.0e-7):
        """Return all intersections between curve and ``other_curve``. An
        intersection is an *extremum* where the distance between the curves
        is smaller than ``tolerance``. Each entry is a dictionary with
        information regarding the intersection:

        - "point": intersection point
        - "u": parameter on this curve (number.Number)
        - "other_u": parameter on other curve (number.Number)

        :type other_curve: Curve
        :param float tolerance: threshold for intersections. Default is 1.0e-7.
        :rtype: list[dict]
        :returns: [{"point", Point, "u": float, "other_u": float}, ...]
        """
        # OpenCascade has no direct method to calculate intersection
        # between two curves, hence we use GeomAPI_ExtremaCurveCurve()
        # for now.
        # TODO: extremum may not be able to find all intersections.
        ext = GeomAPI_ExtremaCurveCurve(self.Handle_Geom_Curve,
                                        other_curve.Handle_Geom_Curve)
        results = []
        for i in range(1, ext.NbExtrema() + 1):
            distance = ext.Distance(i)
            if distance <= tolerance:
                pt1, pt2 = gp_Pnt(), gp_Pnt()
                ext.Points(i, pt1, pt2)
                u1, u2 = ext.Parameters(i)
                results.append(
                    {"point": Point(*pt1.Coord()),
                     "other_point": Point(*pt2.Coord()),
                     "u": u1,
                     "other_u": u2})
        return results

    def surface_intersections(self, surface):
        """Return list of intersections between curve and ``surface``. Each
        entry is a dictionary with information regarding the intersection:

        - "point": intersection point
        - "u": corresponding parameter on this curve
        - "uv": corresponding parameters on ``surface``

        :type surface: parapy.geom.Surface
        :rtype: list[dict]
        :returns: [{"point", Point, "u": float, "uv": (float, float)}, ...]
        """
        ints = GeomAPI_IntCS(self.Handle_Geom_Curve,
                             surface.Handle_Geom_Surface)
        if not ints.IsDone():
            raise RuntimeError(f"intersection failed. Object: {self!r}")

        results = []
        for i in range(1, ints.NbPoints() + 1):
            pt = Point(*ints.Point(i).Coord())
            u, v, w = ints.Parameters(i)
            results.append({'point': pt, 'u': w, 'other_uv': (u, v)})
        return results

    def _transform(self, trnsf, position):
        """ Transform the Geom_Curve, not the wire like Wire_ does.
        Return a :py:`Handle_Geom_Geometry` instance, which we know is a
        :py:`Handle_Geom_Curve`

        :param OCC.gp.gp_Trsf trnsf:
        :param parapy.geom.Position position:
        :rtype: parapy.geom.Curve
        """
        geom_geometry_handle = self.Handle_Geom_Curve.Transformed(trnsf)
        # downcast geometry to curve
        handle_geom_curve = Handle_Geom_Curve(geom_geometry_handle)
        return ClonedCurve(handle_geom_curve, position=position)

    # =========================================================================
    # transformations
    # =========================================================================
    @Attribute
    def reversed(self):
        """Return a new curve that is the reversed of this curve

        :rtype: parapy.geom.Curve
        """
        h_geom_curve = self.Handle_Geom_Curve.Reversed()
        # downcast to similar type
        crv = ClonedCurve(h_geom_curve)
        # if crv.u1!=self.u1 or crv.u2!=self.u2:
        #     warnings.warn("u1, and u2 were changed, "
        #                   "probably because this is a trimmed curve")
        return crv

    # @Attribute
    # def normalized(self):
    #     """New curve with u1, u2 normalized to 0-1."""
    #     return self.reparametrize()

    @Attribute(private=True)
    def Handle_Geom_BSplineCurve(self):
        """
        :rtype: OCC.Geom.Handle_Geom_BSplineCurve
        """
        return GeomConvert__CurveToBSplineCurve(self.Handle_Geom_Curve)

    @Attribute
    def bspline(self):
        """Return a B-Spline curve object

        :rtype: parapy.geom.BSplineCurve
        """
        return self.to_bspline()

    def to_bspline(self, allow_rational=True):
        """Return a B-Spline curve object

        :param bool allow_rational:
        :rtype: parapy.geom.BSplineCurve
        """
        h = self.Handle_Geom_Curve
        if allow_rational:
            h_new = GeomConvert__CurveToBSplineCurve(h)
        else:
            h_new = GeomConvert__CurveToBSplineCurve(h, Convert_Polynomial)
        return BSplineCurve_(h_new)

    @Attribute
    def bezier(self):
        """Returns a single or a list of BezierCurve objects

        :rtype: parapy.geom.BezierCurve
        """
        builder = GeomConvert_BSplineCurveToBezierCurve(
            self.Handle_Geom_BSplineCurve)
        no = builder.NbArcs()
        if no == 0:
            raise Exception("conversion failed")
        elif no == 1:
            return BezierCurve_(builder.Arc(1))
        else:
            return [BezierCurve_(builder.Arc(i)) for i in range(1, no + 1)]

    def directed(self, vector):
        """Return a new curve based on the given ``vector`` and the
        ``direction_vector`` of this curve. If these vectors have a positive
        inner product, the original curve is returned, otherwise the reversed
        of this curve is returned. Usage:

        >>> from parapy.geom import LineSegment, Point, Vector
        >>> crv = LineSegment(Point(1, 0, 0), Point(0, 0, 0))
        >>> print(crv.start)
        Point(1, 0, 0)
        >>> crv2 = crv.directed(Vector(1,1,0))
        >>> print(crv2.start)
        Point(0.0, 0.0, 0.0)

        :param parapy.geom.Vector vector: reference vector.
        :rtype: parapy.geom.Curve
        """
        prod = Vector.dot(vector, self.direction_vector)
        if prod >= 0:
            return self
        else:
            return self.reversed

    # def reparametrize(self, u1=0, u2=1, **kwargs):
    #     """Returns a new BSpline object with new UV bounds"""
    #     FIXME: copy
        # return NormalizedCurve(curve_in=self, u1=u1, u2=u2, **kwargs)

    def _transformed(self, trsf, **info):
        """

        :param OCC.gp.gp_Trsf trsf:
        :param any info:
        :rtype: parapy.geom.Curve
        """
        new_handle = self.Handle_Geom_Curve.Transformed(trsf)
        handle, class_ = Handle_Geom_Curve2ParaPy(new_handle)
        return class_(Handle_Geom_Curve=handle,
                      _transformation=[trsf, self, info])

    # =========================================================================
    # Bounding box
    # =========================================================================
    @Attribute
    def _Bnd_Box(self):
        """
        :rtype: OCC.Bnd.Bnd_Box
        """
        # FIXME: control-points are used splines, this may be wrong.
        #        Consider using mesh and BrepBndLib
        box = Bnd_Box()
        BndLib_Add3dCurve.Add(self._Adaptor3d_Curve, 1e-8,
                              box)  # FIXME: tolerance hard-coded
        return box

    @Attribute
    def _bbox_bounds(self):
        return tuple(self._Bnd_Box.Get())


def Handle_Geom_Curve2ParaPy(Handle_Geom_Curve):
    """Tries to find most corresponding ParaPy class to Handle_Geom_Curve
    object.

    :param OCC.Geom.Handle_Geom_Curve Handle_Geom_Curve:
    :rtype: tuple[OCC.Geom.Handle_Geom_Curve, type]
    """
    dynamic_type = Handle_Geom_Curve.DynamicType()
    fn = dynamic_type.SubType
    name = dynamic_type.Name()
    if fn("Geom_BoundedCurve"):
        if name == "Geom_BSplineCurve":
            return Handle_Geom_BSplineCurve(Handle_Geom_Curve), BSplineCurve_
        elif name == "Geom_BezierCurve":
            return Handle_Geom_BezierCurve(Handle_Geom_Curve), BezierCurve_
        elif name == "Geom_TrimmedCurve":
            return Handle_Geom_TrimmedCurve(Handle_Geom_Curve), TrimmedCurve_
        assert False, "Shouldn't happen"
    elif fn("Geom_Conic"):
        if name == "Geom_Circle":
            return Handle_Geom_Circle(Handle_Geom_Curve), Circle_
        elif name == "Geom_Ellipse":
            return Handle_Geom_Ellipse(Handle_Geom_Curve), Ellipse_
        else:
            return Handle_Geom_Curve, Curve
    if fn("Geom_Line"):
        return Handle_Geom_Line(Handle_Geom_Curve), Line_
    else:
        return Handle_Geom_Curve, Curve


class ClonedCurve(Curve):
    """Can be used to make a new clone of an existing curve(s) or
    OCC.Handle_Geom_Curve(s).

    Usage::

        ClonedCurve(other_curve, *args, **kwargs)
        ClonedCurve([other_curve, other_curve, ...], *args, **kwargs)
        ClonedCurve(built_from=other_curve, **kwargs)

    Where ``other_curve`` is one of:

    * parapy.geom.Curve
    * OCC.Geom.Handle_Geom_Curve
    """

    __initargs__ = ["built_from"]
    __newargs__ = ["built_from"]

    #: "The object to clone. Can be another curve, Edge_ or Handle_Geom_Curve")
    #: :type: Curve
    built_from = Input()

    @classmethod
    def make(cls, built_from, *args, **kwargs):
        """deals with single objects"""
        if isinstance(built_from, Curve):
            class_ = built_from._new_curve_type
            h_geom_curve = built_from._new_handle()
            return class_(Handle_Geom_Curve=h_geom_curve, *args, **kwargs)
        elif handle_is_instance(built_from, Handle_Geom_Curve):
            h_geom_curve, class_ = Handle_Geom_Curve2ParaPy(built_from)
            return class_(Handle_Geom_Curve=h_geom_curve, *args, **kwargs)
        else:
            raise Exception(
                "built_from was not a valid Curve or OCC.Handle_Geom_Curve.")

    def __new__(cls, built_from, *args, **kwargs):
        """tests for iterables"""
        if hasattr(built_from, "__iter__"):
            return [cls.make(obj, *args, **kwargs) for obj in built_from]
        else:
            return cls.make(built_from, *args, **kwargs)


# =============================================================================
# Elementary Infinite Surfaces
# =============================================================================
class InfiniteCurve(Curve):
    pass
    # TODO: make dotted line in viewer
    # display_mode = "wireframe"


class Line(InfiniteCurve):
    """Create an infinite curve from a :attr:`reference` (point) and optional
    :attr:`direction`.

    Usage:

    >>> from parapy.geom import Line, Point, OXY
    >>> # line at (1, 0, 0) and default global 'z' vector (0, 0, 1)
    >>> crv = Line(Point(1, 0, 0))
    >>> crv.direction
    Vector(0, 0, 1)
    >>> # explicit direction: global 'x' vector
    >>> crv = Line(Point(1, 0, 0), Vector(1, 0, 0))
    >>> # given a Position as reference, direction defaults to reference.Vz
    >>> crv = Line(OXY.rotate90('x'))
    >>> crv.direction
    Vector(0, -1, 0)
    """

    __initargs__ = ["reference", "direction", "binormal"]
    __Handle_Geom_Curve__ = Handle_Geom_Line

    #: optional center of the line
    #: :type: Point | Position
    reference = Input(XOY, defaulting="position")

    #: optional vector as direction
    #: :type: Vector | str
    direction = Input(derived)

    #: optional plane bi-normal or 'x' direction.
    #: The default value is derived from the primary direction (tangent).
    #: :type: Vector
    binormal = Input(derived)

    #: dimension for visual inspection. Corresponds to length of curve.
    #: :type: float
    v_dim = Input(1.0)

    def _get_direction(self):
        """Direction of this line

        :rtype: parapy.geom.Vector
        """
        if isinstance(self.reference, Position):
            return self.reference.Vz
        else:
            return VZ

    def _get_binormal(self):
        """Vector orthogonal to the direction of this line

        :rtype: parapy.geom.Vector
        """
        # if isinstance(self.reference, Position):
        #     return self.reference.Vx
        # else:
        #     v = self.direction
        return orthogonal_vector(self.direction, normalize=False)

    @Attribute
    def position(self):
        pt, vz, vx = self.reference, self.direction, self.binormal
        orient = Orientation(x=vx, z=vz)
        return Position(pt, orient)

    @Attribute(private=True)
    def Handle_Geom_Curve(self):
        obj = Geom_Line(gp_Pnt(*self.location), self.direction.gp_Dir)
        return obj.handle

    @Attribute
    def center(self):
        return self.location

    @Attribute
    def _drawable_shape_vertices(self):
        """

        :rtype: tuple[parapy.geom.Point]
        """
        loc, dir, dim = (self.location, self.direction.normalized,
                         0.5 * self.v_dim)
        return loc.translate(dir.reverse, dim), loc.translate(dir, dim)

    @Attribute
    def _drawable_TopoDS_Shape(self):
        """

        :rtype: OCC.TopoDS.TopoDS_Shape
        """
        pt1, pt2 = self._drawable_shape_vertices
        return BRepBuilderAPI_MakeEdge(gp_Pnt(*pt1), gp_Pnt(*pt2)).Shape()

    @property
    def _new_curve_type(self):
        """

        :rtype: type
        """
        return Line_

    def is_circular_with_tolerance(self, tolerance: float = None) -> bool:
        return False

    def is_elliptical_with_tolerance(self, tolerance: float = None) -> bool:
        return False

    def is_planar_with_tolerance(self, tolerance=0.0):
        return True

    def is_straight_with_tolerance(self, tolerance: float = 0.0) -> bool:
        return True


class Line2P(Line):
    """A line passing through :attr:`point1` and :attr:`point2`.

    Usage:

    >>> from parapy.geom import Line2P, Point
    >>> crv = Line2P(Point(0, 0, 0), Point(2, 0, 0))
    >>> crv.reference
    Point(1.0, 0.0, 0.0)
    """
    __initargs__ = ("point1", "point2")

    #: :type: Point
    point1 = Input()

    #: :type: Point
    point2 = Input()

    @Attribute
    def reference(self):
        return self.point1.midpoint(self.point2)

    @Attribute
    def direction(self):
        return (self.point2 - self.point1).normalized


class Line_(Line):
    __initargs__ = ["Handle_Geom_Curve"]

    Handle_Geom_Curve = Input()

    #: :type: parapy.geom.Point
    location = Attribute()

    #: :type: parapy.geom.Vector
    direction = Attribute()

    def _get_location(self):
        """

        :rtype: parapy.geom.Point
        """
        gl = Handle_Geom_Line(self.Handle_Geom_Curve)
        return Point(*gl.Position().Location().Coord())

    def _get_direction(self):
        """

        :rtype: parapy.geom.Vector
        """
        gl = Handle_Geom_Line(self.Handle_Geom_Curve)
        return Vector(*gl.Position().Direction().Coord())

#==============================================================================


# Bounded Curves
#==============================================================================
def BezierCurve_control_points(pts, obj, slot):
    return 1 < len(pts) < 27


class BezierCurve(Curve):
    """Creates a Bezier curve from a list of :attr:`control_points`. First and
    last :attr:`control_points` are always end points of the curve,
    intermediate points do not have to lie on the curve. Optional
    :attr:`weights` can be given (defaults to 1).

    Usage:

    >>> from parapy.geom import Point, BezierCurve
    >>> pts = [Point(0, 0, 0), Point(0, 1, 0), Point(1, 1, 0), Point(1, 0, 0)]
    >>> crv = BezierCurve(pts)
    >>> # Weights of control points affect the curve.
    >>> weights = [[1.0, 3.0, 1.0, 1.0],
    ...            [1.0, 1.0, 3.0, 1.0]]
    >>> crvs = [BezierCurve(control_points=pts,
    ...                   weights=weights[i]) for i in range(0, len(weights))]
    """

    __initargs__ = ["control_points", "weights"]
    __icon__ = os.path.join(ICN_DIR, 'bsplinecurve.png')
    __Handle_Geom_Curve__ = Handle_Geom_BezierCurve

    #: control points, number of points must be between 2 and 27
    #: :type: collections.Sequence[Point]
    control_points = Input(validator=BezierCurve_control_points)

    #: optional weights
    #: :type: collections.Sequence[float]
    weights = Input(derived)

    def _get_weights(self):
        """
        Defaults to a non-rational b-spline curve
        :rtype: list[float]
        """
        return [1] * len(self.control_points)

    @property
    def _new_curve_type(self):
        """
        :rtype: type
        """
        return BezierCurve_

    @Attribute
    def degree(self):
        bc = Handle_Geom_BezierCurve(self.Handle_Geom_Curve)
        return bc.Degree()

    @Attribute(private=True)
    def Handle_Geom_Curve(self):
        """The OCC object of this curve

        :rtype: OCC.Geom.Handle_Geom_Curve
        """
        return Geom_BezierCurve(
            TColgp_Array1OfPnt_factory(self.control_points),
            TColStd_Array1OfReal_factory(self.weights)).handle

    def increase(self):
        """Elevate degree of bezier"""
        raise NotImplementedError("todo")

    def decrease(self):
        """decrease degree of bezier"""
        raise NotImplementedError("todo")


class BezierCurve_(BezierCurve):
    __initargs__ = ["Handle_Geom_Curve"]

    Handle_Geom_Curve = Input()

    #: :type: collections.Sequence[parapy.geom.Point]
    control_points = Attribute()

    #: :type: collections.Sequence[float]
    weights = Attribute()

    # =========================================================================
    # Implementation
    # =========================================================================
    def _get_control_points(self):
        """Return the control_points of the B-spline curve, a sequence of
        Points

        :rtype: list[parapy.geom.Point]
        """
        hbc = Handle_Geom_BezierCurve(self.Handle_Geom_Curve)
        arr = TColgp_Array1OfPnt(1, hbc.NbPoles())
        hbc.Poles(arr)
        return arr.points

    def _get_weights(self):
        """Returns the weights of the B-spline surface.

        :rtype: list[float]"""
        hbc = Handle_Geom_BezierCurve(self.Handle_Geom_Curve)
        arr = TColStd_Array1OfReal(1, hbc.NbPoles())
        hbc.Weights(arr)
        return arr.list


# def _BSplineCurve_control_points(points, obj, slot):
#     return map(convert2gp_Pnt, points)

class BSplineCurve(Curve):
    """Create a curve that is determined by a linear combination of
    :attr:`control_points`. The first and last :attr:`control_points` are by
    default the start and end points of the curve, respectively. The B-Spline
    curve can be rational or non-rational(all :attr:`weights` equal to 1).
    Usage:

    >>> from parapy.geom import Point, BSplineCurve
    >>> pts = [Point(0, 0, 0), Point(0, 1, 0), Point(1, 1, 0), Point(1, 0, 0)]
    >>> crv = BSplineCurve(pts)
    >>> crv.degree
    3
    >>> # different degree
    >>> crv = BSplineCurve(pts, degree=1)

    For more information, check `OpenCascade documentation <http://opencascade.sourcearchive.com/documentation/6.3.0.dfsg.1-1/classGeom__BSplineCurve.html>`__.
    """

    __icon__ = os.path.join(ICN_DIR, 'bsplinecurve.png')
    __Handle_Geom_Curve__ = Handle_Geom_BSplineCurve
    __initargs__ = ["control_points", "weights", "knots", "multiplicities",
                    "degree", "is_periodic"]

    #: Iterable of :py:class:`~parapy.geom.Point` objects.
    #: :type: collections.Sequence[Point]
    control_points = Input()  # preprocessor=_BSplineCurve_control_points)

    #: Optional weights, defaults to a non-rational b-spline curve, i.e.
    #: ``[1.0, 1.0, ...]``.
    #: :type: collections.Sequence[floats]
    weights = Input(derived)

    #: Optional knots. The table of knots is an increasing sequence of reals
    #: **WITHOUT** repetition. :py:attr:`multiplicities` defines the repetition
    #: of knots.
    #: :type: collections.Sequence[float]
    knots = Input(derived)

    #: Optional. Defaults to a uniform b-spline curve where
    #: ``L = len(self.control_points) + self.degree + 1``.
    #: On a non-periodic curve the first and last multiplicities should
    #: satisfy ``self.degree+1``. So, ``L = len(self.control_points) -
    #: self.degree - 1``
    #: :type: collections.Sequence[int]
    multiplicities = Input(derived)

    #: Optional degree of curve. Defaults to 1, 2 or max 3, depending on
    #: :py:attr:`control_points`.
    #: :type: int
    degree = Input(derived)

    #: is this curve periodic or does it have a start and end point? Default
    #:  is False.
    #: :type: bool
    is_periodic = Input(False)

    def _get_degree(self):
        return min(len(self.control_points) - 1, 3)

    def _get_weights(self):
        return [1.] * len(self.control_points)

    def _get_knots(self):
        c = len(self.control_points)
        d = self.degree
        L = c - d + 1
        if not L >= 2:
            raise ValueError("""This should hold: 
            len(self.control_points) - self.degree - 1 >= 0.
            In this case: NOT {a} - {b} - 1 >= 0.
            Perhaps your degree is too high?""".format(
                a=len(self.control_points), b=self.degree))
        return list_of_numbers(0., 1., L)

    def _get_multiplicities(self):
        c = len(self.control_points)
        d = self.degree
        # On a non periodic curve the first and last multiplicities
        # should be Degree+1
        mult = d + 1
        # SUM = c + d + 1 --> L = c - d + 1 --> IL = c - d - 1
        IL = c - d - 1
        return [mult] + [1] * IL + [mult]

    @Attribute
    def knot_sequence(self):
        """The knot vector. Knots **WITH** a multiplicity N greater than 1 are
        repeated N times.

        :rtype: list[float]
        """
        seq = []
        for knot, mult in zip(self.knots, self.multiplicities):
            seq = seq + [knot] * mult
        return seq

    @Attribute(private=True)
    def Handle_Geom_Curve(self):
        """The OCC object for this curve.

        :rtype: OCC.Geom.Handle_Geom_Curve
        """
        return Geom_BSplineCurve(
            TColgp_Array1OfPnt_factory(self.control_points),
            TColStd_Array1OfReal_factory(self.weights),
            TColStd_Array1OfReal_factory(self.knots),
            TColStd_Array1OfInteger_factory(self.multiplicities),
            self.degree,
            self.is_periodic).handle

    @Attribute(private=True)
    def Handle_Geom_BSplineCurve(self):
        """Simply returns :py:attr:`~BSplineCurve.Handle_Geom_Curve`.

        :rtype: OCC.Geom.Handle_Geom_BSplineCurve
        """
        return self.Handle_Geom_Curve

    @Attribute
    def bspline(self):
        """Simply returns ``self``.

        :rtype: BSplineCurve
        """
        return self

    @Attribute
    def is_rational(self):
        """:rtype: bool"""
        return self.Handle_Geom_Curve.IsRational()

    @property
    def _new_curve_type(self):
        """:rtype: :py:class:`BSplineCurve_`"""
        return BSplineCurve_

    def increase(self):
        """Elevate degree of this BsplineCurve"""
        raise NotImplementedError("todo")

    def decrease(self):
        """decrease degree of this BsplineCurve"""
        raise NotImplementedError("todo")


class BSplineCurve_(BSplineCurve):
    """Expects an implemented Handle_Geom_Curve"""

    __initargs__ = ["Handle_Geom_Curve"]

    Handle_Geom_Curve = Input()
    control_points = Attribute()
    weights = Attribute()
    knots = Attribute()
    multiplicities = Attribute()
    knot_sequence = Attribute()
    degree = Attribute()
    is_periodic = Attribute()

    # =========================================================================
    # Implementation
    # =========================================================================
    def _get_control_points(self):
        """Returns the control_points of the B-spline curve, a sequence of
        Points"""
        hgc = self.Handle_Geom_BSplineCurve
        arr = TColgp_Array1OfPnt(1, hgc.NbPoles())
        hgc.Poles(arr)
        return arr.points

    def _get_degree(self):
        hgc = self.Handle_Geom_BSplineCurve
        return hgc.Degree()

    def _get_weights(self):
        """Returns the weights of the B-spline surface."""
        hgc = self.Handle_Geom_BSplineCurve
        arr = TColStd_Array1OfReal(1, hgc.NbPoles())
        hgc.Weights(arr)
        return arr.list

    def _get_knots(self):
        """Returns the knots."""
        hgc = self.Handle_Geom_BSplineCurve
        arr = TColStd_Array1OfReal(1, hgc.NbKnots())
        hgc.Knots(arr)
        return arr.list

    def _get_knot_sequence(self):
        """Return the knots sequence.
        In this sequence the knots with a multiplicity greater than 1 are
        repeated."""
        hgc = self.Handle_Geom_BSplineCurve
        L = sum(self.multiplicities)
        arr = TColStd_Array1OfReal(1, L)
        hgc.KnotSequence(arr)
        return arr.list

    def _get_multiplicities(self):
        """Returns the multiplicities of the knots."""
        hgc = self.Handle_Geom_BSplineCurve
        arr = TColStd_Array1OfInteger(1, hgc.NbKnots())
        hgc.Multiplicities(arr)
        return arr.list

    def _get_is_periodic(self):
        hgc = self.Handle_Geom_BSplineCurve
        return hgc.IsPeriodic()


class ApproximatedCurve(BSplineCurve_):
    """Converts a 3D curve to a 3D BSpline curve. The precision of the
    *approximation* is defined by :attr:`tolerance`,
    it prescribes the maximum distance between :attr:`points` and the
    resulting curve. Defaults to a cubic B-Spline curve (:attr:`max_degree`
    =3). Usage:

    >>> from parapy.geom import Circle, ApproximatedCurve
    >>> circle = Circle(1)
    >>> obj = ApproximatedCurve(circle)

    For more information, check `Open Cascade Documentation
    <http://opencascade.sourcearchive.com/documentation/6.3.0.dfsg.1-1/classGeomConvert__ApproxCurve_61ddeb929b8d3416c4a6a660990c9527.html#61ddeb929b8d3416c4a6a660990c9527>`__.

    """

    __initargs__ = ["curve_in"]

    #: :type: Curve
    curve_in = Input()

    #: the degree of continuity, defaults to 2.
    #: :type: int
    continuity = Input(2)

    #: the highest degree which the polynomial defining the BSpline curve may
    #: have, defaults to 3.
    #: :type: int
    max_degree = Input(3)

    #: the maximum number of segments allowed in the resulting BSpline
    #: curve, defaults to 20.
    #: :type: int
    max_segments = Input(20)

    #: allowed distance between points and curve_in
    #: :type: float
    tolerance = Input(1.0e-3)  #CONFIGURATION["tolerance"], )

    @Attribute
    def is_within_tolerance(self):
        """

        :rtype: bool
        """
        return self.max_error <= self.tolerance

    @Attribute
    def max_error(self):
        """Returns the greatest distance between a point on curve_in and the
        approximated BSpline curve resulting from the approximation. (>0
        when an approximation has been done, 0 if no approximation)

        :rtype: float
        """
        return self.builder.MaxError()

    #==========================================================================
    # Representations
    #==========================================================================
    @Attribute
    def builder(self):
        """

        :rtype: OCC.GeomConvert.GeomConvert_ApproxCurve
        """
        builder = GeomConvert_ApproxCurve(self.curve_in.Handle_Geom_Curve,
                                          self.tolerance,
                                          C_CONTINUITY[self.continuity],
                                          self.max_segments,
                                          self.max_degree)
        if builder.HasResult():
            if builder.MaxError() > self.tolerance:
                warnings.warn(
                    "GeomConvert_ApproxCurve algorithm could not approximate a"
                    " curve within the given tolerance")
            return builder
        else:
            raise ValueError(
                "GeomConvert_ApproxCurve algorithm could not find a curve with"
                " the given inputs")

    @Attribute(private=True)
    def Handle_Geom_Curve(self):
        """

        :rtype: OCC.Geom.Handle_Geom_Curve
        """
        return self.builder.Curve()


class ExtendedCurve(Curve):
    """Extends the bounded curve :attr:`curve_in`. In principle,
    defining :attr:`distance` is enough for degree 1 extensions. If you want
    degree 2 or 3 extensions, provide a :attr:`Point` to :attr:`to_point`.
    The extension is build at the end of the curve if :attr:`after` is
    set to True, else at beginning of the curve.

    Usage:

    >>> from parapy.geom import ExtendedCurve, LineSegment, Point
    >>> line = LineSegment(Point(0, 0, 0), Point(1, 0, 0))
    >>> crv1 = ExtendedCurve(curve_in=line, distance=3)
    >>> #let's extend the line to a point
    >>> crv2 = ExtendedCurve(curve_in=line, to_point=Point(2, 1, 0))

    It is recommended that the extension should not be too large with respect
    to the size of :attr:`curve_in`. Also, :attr:`to_point` must not be located
    too far from one of the extremities of the :attr:`curve_in`.
    WARNING: in case of continuity 2 or 3, the specified distance is not the
    distance of the extension.

    For more information, check `Open Cascade Documentation
    <http://dev.opencascade.org/doc/refman/html/class_geom_lib.html#ae1ed27fcd55f1dfe0b3523284229b50c>`__.
    """
    # FIXME: couple distance to length of extension.

    __initargs__ = ["curve_in", "distance", "after", "continuity"]

    #: :type: Curve
    curve_in = Input()

    #: extended distance
    #: :type: float
    distance = Input()

    #: extension is build at end if True, else at beginning.
    #: :type: bool
    after = Input(True)

    #: optional continuity of the curve, default is 1
    #: :type: int
    continuity = Input(1, validator=val.OneOf([1, 2, 3]))

    #: optional point to extent to, overrides distance.
    #: :type: Point
    to_point = Input(derived)

    #: extent type is mirror
    #: :type: bool
    mirrored_extent = Input(False)

    #==========================================================================
    # Implementation
    #==========================================================================
    def _get_to_point(self):
        return self._get_point(self.distance, self.after)

    def _get_point(self, distance=None, after=True):
        """Get a point extended ``distance`` after or before the input curve.
        if ``after`` == :py:`True` it lies at the back of the input curve, else
        in front of it.

        :param float distance:
        :param bool after:
        :rtype: parapy.geom.Point
        """
        if distance is None:
            raise ValueError(
                "Specify either distance or to_point. No inputs received.")
        crv = self.curve_in
        pt = crv.end if after else crv.start
        V = crv.tangent2 if after else -crv.tangent1
        return pt + V * distance

    @Attribute
    def from_point(self):
        """If ``self.mirrored_extent`` is :py:`True` this is the mirrored
        point with which the curve is extended.

        :rtype: parapy.geom.Point | ValueError
        """
        if self.mirrored_extent:
            to_point = self.to_point
            if self.received_input("distance"):
                return self._get_point(self.distance, not self.after)
            else:
                pt1, pt2 = self.curve_in.start, self.curve_in.end
                if self.after:
                    return pt1 - (to_point - pt2)
                else:
                    return pt2 - (to_point - pt1)
        else:
            return ValueError("mirrored_extent is False")

    @Attribute(private=True)
    def Handle_Geom_Curve(self):
        """

        :rtype: OCC.Geom.Geom_Curve
        """
        to_point = self.to_point
        h_curve = self.curve_in._new_handle()
        h_curve = Handle_Geom_BoundedCurve.DownCast(h_curve)
        GeomLib__ExtendCurveToPoint(h_curve, gp_Pnt(*to_point),
                                    self.continuity, self.after)
        if self.mirrored_extent:
            GeomLib__ExtendCurveToPoint(h_curve, gp_Pnt(*self.from_point),
                                       self.continuity, not self.after)
        return h_curve


class DoubleExtendedCurve(Curve):
    """Similar to ExtendedCurve, but then on both sides of :attr:`curve_in`.
    Usage:

    >>> from parapy.geom.occ.curve import DoubleExtendedCurve
    >>> from parapy.geom import LineSegment, Point
    >>> line = LineSegment(Point(0, 0, 0), Point(1, 0, 0))
    >>> crv1 = DoubleExtendedCurve(curve_in=line,  distance_before=3,
    ...                           distance_after=2)
    >>> crv2 = DoubleExtendedCurve(curve_in=line,
    ...                            to_point_before=Point(-1, -1, 0),
    ...                            to_point_after=Point(2, 1, 0))
    """

    __initargs__ = ["curve_in", "distance", "continuity"]

    #: :type: Curve
    curve_in = Input()

    #: extended distance
    #: :type: float
    distance = Input()

    #: continuity of the curve, default is 1
    #: :type: int
    continuity = Input(1, validator=val.Range(1, 3))

    #: extended distance at start of curve
    #: :type: float
    distance_before = Input(distance)

    #: extended distance at end of curve
    #: :type: float
    distance_after = Input(distance)

    #: continuity of extension at end of curve, defaults to 1
    #: :type: int
    continuity_after = Input(continuity, validator=val.Range(1, 3))

    #: continuity of extension at start of curve, defaults to continuity_after
    #: :type: int
    continuity_before = Input(continuity_after, validator=val.Range(1, 3))

    #: optional point to extent to from end of curve, overrides distance.
    #: :type: Point
    to_point_after = Input(derived)

    #: optional point to extent to from start of curve, overrides distance.
    #: :type: Point
    to_point_before = Input(derived)

    def _get_to_point_after(self):
        """
        :rtype: parapy.geom.Point
        """
        return self.curve_in.end + (self.curve_in.tangent2 *
                                    self.distance_after)

    def _get_to_point_before(self):
        """
        :rtype: parapy.geom.Point
        """
        return self.curve_in.start - (self.curve_in.tangent1 *
                                      self.distance_before)

    @Attribute
    def _curve_after(self):
        """Intermediate result

        :rtype: parapy.geom.ExtendedCurve
        """
        return ExtendedCurve(curve_in=self.curve_in,
                             to_point=self.to_point_after,
                             continuity=self.continuity_after)

    @Attribute(private=True)
    def Handle_Geom_Curve(self):
        """

        :rtype: OCC.Geom.Handle_Geom_Curve
        """
        h_curve = self._curve_after._new_handle()
        h_curve = Handle_Geom_BoundedCurve(h_curve)
        GeomLib__ExtendCurveToPoint(h_curve, gp_Pnt(*self.to_point_before),
                                   self.continuity_before, False)
        return h_curve


class NormalizedCurve(BSplineCurve_):
    """Normalized version of :attr:`curve_in` with its parametric domain bound
    to [:attr:`u1 - :attr:`u2`]. Usage:

    >>> from parapy.geom import (NormalizedCurve, Point, LineSegment,
    ...                          TrimmedCurve)
    >>> crv1 = LineSegment(Point(0, 0, 0),Point(1, 0, 0))
    >>> crv2 = TrimmedCurve(crv1, 0.2, 0.8)
    >>> crv2.u1, crv2.u2, crv2.midpoint
    (0.2, 0.8, Point(0.5, 0.0, 0.0))
    >>> obj = NormalizedCurve(curve_in=crv2)
    >>> obj.u1, obj.u2, obj.midpoint
    (0.0, 1.0, Point(0.5, 0.0, 0.0))

    .. note:: this curve will always take the B-Spline reprensentation of
        :attr:`curve_in`. If the input curve is already of type
        :class:`BSplineCurve`, that curve is used as-is, otherwise a
        conversion is applied (accessible from :attr:`Curve.bspline`).
    """
    __initargs__ = ["curve_in", "u1", "u2"]

    #: curve that will be normalized, must be bspline curve
    #: :type: Curve
    curve_in = Input(validator=val.IsInstance(Curve))

    #: new startpoint curve, defaults to 0.
    #: :type: float
    u1 = Input(0.)

    #: new endpoint curve, defaults to 1.
    #: :type: float
    u2 = Input(1.)

    @Attribute(private=True)
    def Handle_Geom_Curve(self):
        h_geom_bsplinecurve = self.curve_in.Handle_Geom_BSplineCurve

        # make a copy, since BSplCLib__Reparametrize mutates original!
        h_geom_geometry = h_geom_bsplinecurve.Copy()
        h_geom_bsplinecurve = Handle_Geom_BSplineCurve.DownCast(
            h_geom_geometry)

        knots = TColStd_Array1OfReal(1, h_geom_bsplinecurve.NbKnots())
        h_geom_bsplinecurve.Knots(knots)
        BSplCLib__Reparametrize(self.u1, self.u2, knots)
        h_geom_bsplinecurve.SetKnots(knots)
        return h_geom_bsplinecurve


def chain_curves(curves, tol=1.0e-7):
    """Return multiple chains of connected curves.
    TODO: does not check for multi-branching.

    :param curves: Curves to chain.
    :type curves: colections.Iterable.
    :param tol: Tolerance defining when points are considered
        coincident. Defaults to ``1.0e-7``.
    :return: list of lists of curves.
    :rtype: list[list[Curve]]
    """

    if tol:
        def eq(pt1, pt2):
            return abs(pt2[0]-pt1[0])<=tol and \
                   abs(pt2[1]-pt1[1])<=tol and \
                   abs(pt2[2]-pt1[2])<=tol
    else:
        import operator
        eq = operator.eq

    # form:
    # [[curve, curve, ...], start, end]
    chains = []
    closed_chains = []

    def _try_chain(curve, chain):
        crvs, p1, p2 = chain
        p1_, p2_ = curve.start, curve.end

        flag = False
        if eq(p1_, p2):
            crvs.append(curve)
            chain[2] = p2_
            flag = chain
        elif eq(p2_, p1):
            if len(crvs) == 1:
                crvs.append(curve)
                chain[1] = p2
                chain[2] = p1_
            else:
                crvs.insert(0, curve)
                chain[1] = p1_
            flag = chain
        # reversed cases
        elif eq(p2_, p2):
            crvs.append(curve)
            chain[2] = p1_
            flag = chain
        elif eq(p1_, p1):
            if len(crvs) == 1:
                crvs.append(curve)
                chain[1] = p2
                chain[2] = p2_
            else:
                crvs.insert(0, curve)
                chain[1] = p2_
            flag = chain
        return flag

    def try_chain(curve):
        for chain in chains:
            flag = _try_chain(curve, chain)
            if flag:
                return flag
        return False

    # list to keep order
    stack = list(curves)
    while stack:
        crv = stack.pop(0)
        flag = try_chain(crv)
        if not flag:
            _, pt1, pt2 = new_chain = [[crv], crv.start, crv.end]
            if eq(pt1, pt2):
                closed_chains.append(new_chain)
            else:
                chains.append(new_chain)
        elif eq(flag[1], flag[2]):
            chains.remove(flag)
            closed_chains.append(flag)

    if len(chains) > 1:
        # merge chains
        while True:
            flag = True
            for chain1, chain2 in combinations(chains, 2):
                crvs1, p1, p2 = chain1
                crvs2, p1_, p2_ = chain2
                if eq(p1_, p2):
                    crvs1.extend(crvs2)
                    chain1[2] = p2_
                    chains.remove(chain2)
                    flag = False
                    break
                elif eq(p2_, p1):
                    chain1[0] = crvs2 + crvs1
                    chain1[1] = p1_
                    chains.remove(chain2)
                    flag = False
                    break
                # reversed cases
                elif eq(p2_, p2):
                    crvs2.reverse()
                    crvs1.extend(crvs2)
                    chain1[2] = p1_
                    chains.remove(chain2)
                    flag = False
                    break
                elif eq(p1_, p1):
                    crvs2.reverse()
                    chain1[0] = crvs2 + crvs1
                    chain1[1] = p2_
                    chains.remove(chain2)
                    flag = False
                    break
            if flag:
                break
            else:
                _, pt1, pt2 = chain1
                if eq(pt1, pt2):
                    chains.remove(chain1)
                    closed_chains.append(chain1)

    return [chain[0] for chain in chains + closed_chains]


# TODO: support the generation of a C1 continuous curve with
#  GeomConvert::C0BSplineToC1BSplineCurve
class ComposedCurve(BSplineCurve_):
    """Tries to make **one** BSpline curve from a list of (unordered) input
    curves, :attr:`built_from`. Curve has G0 continuity. If you want your
    curve to consist of multiple chains,, set :attr:`allow_multiple`` to
    :py:`True`.

    Usage:

    >>> from parapy.geom import ComposedCurve, Point, LineSegment
    >>> crv1 = LineSegment(Point(0, 0, 0), Point(1, 0, 0))
    >>> crv2 = LineSegment(Point(1, 0, 0), Point(2, 0, 0))
    >>> obj1 = ComposedCurve(built_from=[crv1, crv2])

    >>> # let's translate the coincident point.
    >>> crv2 = LineSegment(Point(1, 0.05, 0), Point(2, 0, 0))
    >>> # lower the tolerance in order to compose the curve.
    >>> obj2 = ComposedCurve(built_from=[crv1, crv2],tolerance=1.0e-1)
    """

    __initargs__ = ["built_from"]

    #: curves to compose into one BSpline curve.
    #: :type: collections.Sequence[Curve]
    built_from = Input()

    #: maximum distance between coincident points
    #: :type: float
    tolerance = Input(1.0e-7)

    #: if your curves form one connected chain and connect in order, you can
    #: set this to True.
    #: :type: bool
    ordered = Input(False)

    #: allow multiple chains?
    #: :type: bool
    allow_multiple = Input(False)

    @Attribute
    def chains(self):
        """list of list of Curve objects forming chains.

        :rtype: list[list[Curve]]
        """
        chains = self.built_from
        if self.ordered:
            if not hasattr(chains[0], "__iter__"):
                chains = [chains]
        else:
            chains = chain_curves(chains, self.tolerance)
        if not self.allow_multiple and len(chains) != 1:
            msg = ("Curves did not form a single chain, set "
                   "allow_multiple=True.: Instance {:}.")
            raise RuntimeError(msg.format(repr(self)))
        else:
            return chains

    @Attribute(private=True)
    def Handle_Geom_Curve(self):
        """The OCC handle of the first curve

        :rtype: OCC.Geom.Handle_Geom_Curve
        """
        return self._Handle_Geom_Curves[0]

    def _build_curve(self, chain):
        builder = GeomConvert_CompCurveToBSplineCurve()
        for curve in chain:
            success = builder.Add(
                Handle_Geom_BoundedCurve.DownCast(curve.Handle_Geom_Curve),
                self.tolerance, True)  # After = True
            if not success:
                msg = "Consecutive curves of {} do not touch G0."
                if self.ordered:
                    msg += " Consider ordered=False."
                raise RuntimeError(msg.format(self))
        return builder.BSplineCurve()

    @Attribute
    def _Handle_Geom_Curves(self):
        """list of BSpline_Curve objects

        :rtype: list[OCC.Geom.Handle_Geom_Curve]
        """
        return list(map(self._build_curve, self.chains))

    @Part(trickle_down=False, in_tree=False)
    def curves(self):
        return BSplineCurve_(
            quantify=len(self._Handle_Geom_Curves),
            Handle_Geom_Curve=self._Handle_Geom_Curves[child.index])


class DecomposedCurve(GeomBase):
    """Split a BSpline curve, :attr:`curve_in`, in order to obtain arcs of the
    same degree of continuity, :attr:`degree`. Usage:

    >>> from parapy.geom import (DecomposedCurve, LineSegment, Point,
    ...                         ExtendedCurve)
    >>> line = LineSegment(start=Point(0, 0, 0), end=Point(1, 0, 0))
    >>> crv = ExtendedCurve(curve_in=line, to_point=Point(2, 1, 0))
    >>> obj = DecomposedCurve(curve_in=crv, degree=2)

    For more information, check `Open Cascade documentation
    <http://opencascade.sourcearchive.com/documentation/6.3.0.dfsg.1-1/classGeomConvert__BSplineCurveKnotSplitting.html>`__.
    """

    #: :type: Curve
    curve_in = Input()

    #: the required degree of continuity, defaults to 1
    #: :type: int
    degree = Input(1, validator=val.GT(-1))

    @Part(parse=False)
    def curves(self):
        """The arcs within ``curve_in`` that have the same degree of continuity

        :rtype: list[BSplineCurve_]
        """
        builder = GeomConvert_BSplineCurveKnotSplitting(
            self.curve_in.Handle_Geom_BSplineCurve,
            self.degree)
        nbsplits = builder.NbSplits()
        knots = [builder.SplitValue(i + 1) for i in range(nbsplits)]
        return [BSplineCurve_(Handle_Geom_Curve=GeomConvert__SplitBSplineCurve(
            self.curve_in.Handle_Geom_BSplineCurve, knots[i], knots[i + 1]))
                for i in range(nbsplits - 1)]


class OffsetCurve(Curve):

    #: The curve to apply an offset on
    #: Curve
    curve_in = Input()

    #: distance which the curve is offset in :attr:`bi_normal`
    #: :type: float
    distance = Input()

    @Input
    def bi_normal(self):
        """Direction in which the Curve is offset.

        :rtype: parapy.geom.Vector
        """
        return self.curve_in.plane_normal.normalized

    @Attribute(private=True)
    def Handle_Geom_Curve(self):
        """The underlying OCC curve.

        :rtype: OCC.Geom.Handle_Geom_Curve
        """
        builder = Geom_OffsetCurve(self.curve_in.Handle_Geom_Curve,
                                   self.distance,
                                   self.bi_normal.gp_Dir)
        return builder.handle


# TODO (TBD): theAdjustPeriodic since OCCT 7.0?
# FIXME (TBD): if you trim an arc (continuity CN) and convert it to a BSpline
# /fixme Curve, it's continuity will be 0
class TrimmedCurve(Curve):
    """Trim a :attr:`basis_curve` between the limits :attr:`limit1` and/or
    :attr:`limit2`. If only one limit is defined, other limit will pin to the
    extremity of the
    :attr:`basis_curve`. Thus, to trim only the head of the curve, specify
    only :attr:`limit1`, or
    to trim only the tail of the curve, specify only :attr:`limit2`.
    Valid limits are of type:
    
    1. float: a u-parameter on :attr:`basis_curve`
    2. Point: point on (or very close to) the :attr:`basis_curve`
    3. Curve: trim at intersection with another curve
    4. Surface: trim at intersection with another surface
    
    Usage:

    >>> # trimming a circle into a quarter-circle (top-left quadrant)
    >>> from parapy.geom import Point, Circle, TrimmedCurve
    >>> crv = Circle(radius=1.0)
    >>> # using parameters (fractions of 2*pi)
    >>> TrimmedCurve(basis_curve=crv, limit1=0.5 * math.pi, limit2=math.pi)
    >>> # same, but with points
    >>> TrimmedCurve(basis_curve=crv, limit1=Point(0, 1, 0),
    ...     limit2=Point(-1, 0, 0))

    >>> # trimming a LineSegment halfway, keeping the tail
    >>> from parapy.geom import Point, LineSegment, TrimmedCurve, Plane, XOY
    >>> crv = LineSegment(start=Point(0, 0, 0), end=Point(1, 0, 0))
    >>> # trimming with u-parameter
    >>> tool = 0.5
    >>> TrimmedCurve(basis_curve=crv, limit1=tool)
    >>> # trimming with point
    >>> tool = Point(0.5, 0, 0)
    >>> TrimmedCurve(basis_curve=crv, limit1=tool)
    >>> # trimming with curve
    >>> tool = LineSegment(start=Point(0.5, -1, 0), end=Point(0.5, 1, 0))
    >>> TrimmedCurve(basis_curve=crv, limit1=tool)
    >>> # trimming with surface
    >>> tool = Plane(reference=XOY.translate(x=0.5).rotate90('y'))
    >>> TrimmedCurve(basis_curve=crv, limit1=tool)

    .. note:: if u-parameter(s) used for trimming lies outside the
        range [u1-u2] of
        :attr:`basis_curve`, a warning is given. If you do this deliberately,
        you may suppress
        the warning by setting :attr:`on_extrapolation` to False.
    .. caution: make sure another curve or a surface limit does intersect
        only once with the
        :attr:`basis_curve`, otherwise a RuntimeError is raised.
    """

    __initargs__ = ["basis_curve", "limit1", "limit2"]

    #: :type: Curve
    basis_curve = Input()

    #: Optional limit1 of curve, can be parametric value (u), a point or a
    #: plane. Defaults to basis_curve.u1.
    #: :type: float | Point | Plane
    limit1 = Input(derived)

    #: Optional limit2 of curve, can be parametric value (u), a point or a
    #: plane. Defaults to basis_curve.u2.
    #: :type: float | Point | Plane
    limit2 = Input(derived)

    #: useful for periodic basis_curve only. If set to True, the trimmed
    #: curve will have the same orientation as the basis curve. In case of
    #: False, the orientation is opposite.
    #: :type: bool
    sense = Input(True)

    #: if a limit is a :class:`Point`, :class:`Curve` or
    #: :class:`~parapy.geom.Surface`, this defines the maximum allowed gap
    #: between the limit and the projected/intersected point on the
    #: :attr:`curve`.
    tolerance = Input(1e-7)

    #: by default, this object will check that the u-parameters corresponding
    #: to a limit lie within the range [u1-u2] of :attr:`basis_curve`. If it
    #: doesn't, a warning is given. If you extrapolated deliberately, you can
    #: suppress the warning by setting this Input to 'ignore'. For a stricter
    #: policy, you can also set this slot to 'raise'.
    #: :type: str
    on_extrapolation = Input('warn',
                             validator=val.OneOf({"ignore", "warn", "raise"}))

    @limit1.getter
    def limit1(self):
        return self.basis_curve.u1

    @limit2.getter
    def limit2(self):
        return self.basis_curve.u2

    @Attribute(private=True)
    def Handle_Geom_Curve(self):
        """The OCC object that is represented by this Curve.

        :rtype: OCC.Geom.Handle_Geom_Curve
        """
        return Geom_TrimmedCurve(self.basis_curve.Handle_Geom_Curve,
                                 self._to_u(self.limit1, 'start'),
                                 self._to_u(self.limit2, 'end'),
                                 self.sense).handle

    def _to_u(self, limit, side):
        """Converts limit to valid u-parameter on curve.

        :param Number | AbstractPoint | Curve | parapy.geom.Surface limit:
            a way to represent a point on this curve, of which a u value should
            be returned.
        :param str side: either 'start' or 'end'.
        :rtype: float
        """
        curve = self.basis_curve

        if isinstance(limit, Number):
            u = limit
        elif isinstance(limit, AbstractPoint):
            tolerance = self.tolerance
            dct = curve.projected_point(
                limit, precision=tolerance, AdjustToEnds=False)
            if dct["distance"] > tolerance:
                self.__raise_no_intersections_within_tolerance(
                    limit, dct["distance"], tolerance)
            else:
                u = dct["u"]
        else:  # Curve, or Surface?
            intersections = curve.intersections(
                limit, tolerance=self.tolerance)

            if not intersections:
                self.__raise_no_intersections(limit)

            nb_intersections = len(intersections)
            if nb_intersections == 1:
                idx = 0
            else:  # nb_intersections > 1:
                intersections = sorted(intersections, key=itemgetter("u"))

                if side == 'start':
                    idx = 0
                elif side == 'end':
                    idx = -1
                else:
                    assert False

                msg = ("Found more than one intersection..., using point "
                       "closest to side {!r}. Object: {!r}.")
                warnings.warn(msg.format(side,  self))

            u = intersections[idx]["u"]

        on_extrapolation = self.on_extrapolation
        if on_extrapolation != 'ignore':
            u1, u2 = curve.u1, curve.u2
            if u < u1 or u > u2:
                msg = ("Specified limit {} corresponds to u-parameter {}, "
                       "which lies outside the u-parameter range [{}-{}] of "
                       "basis_curve {}. If this is intentional and you don't "
                       "want to see this message, consider setting "
                       "on_extrapolation='ignore'. Object: {}.")
                msg = msg.format(limit, u, u1, u2, curve, self)

                if on_extrapolation == 'warn':
                    warnings.warn(msg)
                else:  # on_extrapolation == 'raise'
                    raise RuntimeError(msg)

        return u

    def __raise_no_intersections_within_tolerance(
            self, limit, distance, tolerance):
        msg = ("No intersection found between basis_curve {!r} and limit {!r}."
               " Current distance {} > tolerance {}. If basis_curve and limit "
               "are relatively close to each other, consider increasing "
               "tolerance. Object: {!r}.")
        raise RuntimeError(
            msg.format(self.basis_curve, limit, distance, tolerance, self))

    def __raise_no_intersections(self, limit):
        msg = ("No intersection found between basis_curve {!r} and limit {!r}."
               " If basis_curve and limit are close to each other, "
               "consider adjusting tolerance. Object: {!r}.")
        raise RuntimeError(
            msg.format(self.basis_curve, limit, self))


class TrimmedCurve_(TrimmedCurve):
    __initargs__ = ["Handle_Geom_Curve"]

    Handle_Geom_Curve = Input()

    sense = Attribute(True)

    # TODO (TBD): change inheritance tree to overcome this hack to uninherit
    on_extrapolation = None

    @Attribute
    def limit1(self):
        return self.basis_curve.u1

    @Attribute
    def limit2(self):
        return self.basis_curve.u2

    @Part(parse=None, in_tree=False, trickle_down=False)
    def basis_curve(self):
        return ClonedCurve(self.Handle_Geom_Curve.BasisCurve())


class LineSegment(TrimmedCurve_):
    """Define a line segment between a :attr:`start` and :attr:`end` point.
    Usage:

    >>> from parapy.geom import LineSegment, Point
    >>> obj = LineSegment(start=Point(0, 0, 0), end=Point(1, 0, 0))
    """

    __initargs__ = ("start", "end")

    #: first point.
    #: :type: Point
    start = Input()

    #: second point.
    #: :type: Point
    end = Input()

    @Attribute(private=True)
    def Handle_Geom_Curve(self):
        """OCC object representing this curve.

        :rtype: OCC.Geom.Handle_Geom_Curve
        """
        if not self.start == self.end:
            builder = GC_MakeSegment(gp_Pnt(*self.start), gp_Pnt(*self.end))
            return resolve_gce_status(builder)
        else:
            raise Exception("start / end points overlap.")

    @Attribute
    def length(self):
        """length of curve object

        :rtype: float
        """
        return self.start.distance(self.end)

    @property
    def _new_curve_type(self):
        """

        :rtype: type
        """
        return LineSegment_

    def is_circular_with_tolerance(self, tolerance: float = None) -> bool:
        return False

    def is_elliptical_with_tolerance(self, tolerance: float = None) -> bool:
        return False

    def is_planar_with_tolerance(self, tolerance=0.0):
        return True

    def is_straight_with_tolerance(self, tolerance: float = 0.0) -> bool:
        return True


class LineSegment_(LineSegment):
    __initargs__ = ["Handle_Geom_Curve"]

    #: :type: OCC.Geom.Handle_Geom_Curve
    Handle_Geom_Curve = Input()

    #: :type: parapy.geom.Point
    start = Attribute()

    #: :type: parapy.geom.Point
    end = Attribute()

    def _get_start(self):
        return self.point(self.u1)

    def _get_end(self):
        return self.point(self.u2)


class FittedCurve(BSplineCurve_):
    """Fit a curve through :attr:`points` with given :attr:`continuity`.
    The precision of the *fit* is defined by :attr:`tolerance`,
    it prescribes the maximum distance between :attr:`points` and the
    resulting curve. The fitting algorithm takes the freedom to vary the
    :attr:`degree` of the B-Spline curve between :attr:`min_degree` and
    :attr:`max_degree` bounds. Generally, a higher value of
    :attr:`max_degree` may provide greater freedom to the fitting algorithm
    to find a better fit, but can also result in wiggles. Usually, a
    :attr:`max_degree` of 8 forms a good compromise, although you may also
    want to limit it to 3 (cubic) for smoothness. For more information, check
    `Open Cascade documentation
    <http://www.opencascade.com/doc/occt-6.9.1/refman/html
    /class_geom_a_p_i___points_to_b_spline.html>`__.

    Usage:

    >>> from parapy.geom import Point, FittedCurve
    >>> points = [Point(0, 0, 0), Point(1, 1, 0), Point(2, 0, 0)]
    >>> obj = FittedCurve(points=points, max_degree=3)

    .. note:: if you want to add tangency constraints, use
        :class:`InterpolatedCurve`.
    """

    __initargs__ = ["points"]

    #: Sequence of 3D points to fit through
    #: :type: collections.Sequence[Point]
    points = Input()

    #: minimum degree for fitting algorithm, defaults to 1
    #: :type: int
    min_degree = Input(1)

    #: maximum degree for fitting algorithm, defaults to 8
    #: :type: int
    max_degree = Input(8)

    #: C-Continuity, viz. 1 for C1-continuity, defaults to 2.  Range 0-2.
    #: :type: int
    continuity = Input(2)

    #: allowed distance between points and curve.
    #: :type: float
    tolerance = Input(1e-3)

    #: normalize the curve afterwards. Useful in cases where the resulting
    #: u-range would not be 0-1.
    #: :type: bool
    normalize = Input(False)

    @Attribute
    def builder(self):
        """:rtype: OCC.GeomAPI.GeomAPI_PointsToBSpline"""
        pts = TColgp_Array1OfPnt_factory(self.points)
        degmin = self.min_degree
        degmax = self.max_degree
        cont = C_CONTINUITY[self.continuity]
        tol = float(self.tolerance)  # RvD fix: seems to affect C++ side.
        builder = GeomAPI_PointsToBSpline(pts, degmin, degmax, cont, tol)
        if builder.IsDone():
            return builder
        else:
            msg = "fitting failed, check point spacing and tolerance."
            raise Exception(msg)

    @Attribute(private=True)
    def Handle_Geom_Curve(self):
        """:rtype: OCC.Geom.Handle_Geom_Curve"""
        h_curve = self.builder.Curve()
        if self.normalize:
            knots = TColStd_Array1OfReal(1, h_curve.NbKnots())
            h_curve.Knots(knots)
            BSplCLib__Reparametrize(0, 1, knots)
            h_curve.SetKnots(knots)
        return h_curve


# TODO: merge with FittedCurve
class InterpolatedCurve(BSplineCurve_):
    """This class is used to interpolate a B-Spline curve passing through an
    array of :attr:`points`, similar to fitted curve. You can optionally add
    tangency constraints by passing a sequence of vectors as :attr:`tangents`
    or define an :attr:`initial_tangent` and/or :attr:`final_tangent`. The
    interpolated curve has C2-continuity, except at the points where tangency
    constraints apply. The curve will then have C1-continuity at those points.
    You can make the curve periodic by setting :py:`is_periodic=True`. This
    will make the curve closed and have C1-continuity. The junction of the
    closed curve is the first Point in :attr:`points`.

    Usage:

    >>> from parapy.geom import InterpolatedCurve, Point, Vector
    >>> # no tangency constraints
    >>> obj1 = InterpolatedCurve(points=[Point(0, 0, 0), Point(1, 0, 0)])
    >>> # two points with initial- and final tangent contraints
    >>> obj2 = InterpolatedCurve(points=[Point(0, 0, 0), Point(1, 0, 0)],
    ...                          initial_tangent=Vector(0, 1, 0),
    ...                          final_tangent=Vector(0, -1, 0))
    >>> # two points with initial tangent contraint
    >>> obj3 = InterpolatedCurve(points=[Point(0, 0, 0), Point(1, 0, 0)],
    ...                          initial_tangent=Vector(0, 1, 0))

    For more information, check `Open Cascade Documentation
    <http://opencascade.sourcearchive.com/documentation/6.3.0.dfsg.1-1/classGeomAPI__Interpolate.html>`__.
    """

    __initargs__ = ["points"]

    #: Sequence of 3D points to fit through
    #: :type: collections.Sequence[Point]
    points = Input()

    #: Sequence of Vector objects. Assigns the BSpline curve to be tangential
    #: to vectors defined in the sequence, which is parallel to the sequence
    #: of points through which the curve passes. Only Truth values are
    #: handled, Enter False/None values if no tangency constraint applies to
    #: a point. However, always make the sequence as long as the points
    #: sequence: ``len(points) == len(tangents)``.
    #: :type: collections.Sequence[Vector]
    tangents = Input(None)

    #: :type: float
    tolerance = Input(1e-3)

    #: optional initial tangent.
    #: :type: Vector
    initial_tangent = Input(None)

    #: optional final tangent.
    #: :type: Vector
    final_tangent = Input(None)

    #: if you set this to True, first and last point can not be the same!
    #: :type: bool
    is_periodic = Input(False)

    #: scale tangent vectors?
    #: :type: bool
    scale = Input(True)

    #: normalize the curve afterwards. Useful in cases where the resulting
    #: u-range would not be 0-1.
    #: :type: bool
    normalize = Input(False)

    @Attribute
    def builder(self):
        """:rtype: OCC.Geom.GeomAPI_Interpolate"""
        points = self.points
        is_periodic = self.is_periodic
        tolerance = self.tolerance
        tangents = self.tangents
        initial_tangent = self.initial_tangent
        final_tangent = self.final_tangent
        scale = self.scale
        
        # periodic curves will be closed by OCC
        if is_periodic:
            if points[0].is_almost_equal(points[-1], tolerance):
                msg = ("If is_periodic is True, first {:} and last point {:} "
                       "should not coincide!")
                raise RuntimeError(msg.format(points[0], points[-1]))

        pts = TColgp_HArray1OfPnt_factory(points).handle
        builder = GeomAPI_Interpolate(pts, is_periodic, tolerance)

        if not tangents:
            # only initial and final tangents supplied, dedicated constructor
            if initial_tangent and final_tangent:
                builder.Load(gp_Vec(*initial_tangent), gp_Vec(*final_tangent),
                             scale)
            # if initial_tangent only, so use tangents approach
            elif initial_tangent:
                tangents = [None] * len(points)
                tangents[0] = initial_tangent
            # if final_tangent only, so use tangents approach
            elif final_tangent:
                tangents = [None] * len(points)
                tangents[-1] = final_tangent
        else:
            if len(tangents) != len(points):
                msg = ("Violated len(tangents) == len(points). "
                       "Received {:} != {:}.")
                raise ValueError(msg.format(len(tangents), len(points)))

            # add initial_tangent to tangents if None, else raise.
            if initial_tangent:
                tangents = list(tangents)  # make a local copy
                if tangents[0]:
                    msg = ("Double assignment of initial_tangent. Both in "
                           "initial_vector ({:}) and tangents[0] ({:}).")
                    raise ValueError(msg.format(initial_tangent, tangents[0]))
                else:
                    tangents[0] = initial_tangent

            # add initial_tangent to tangents if None, else raise.
            if final_tangent:
                tangents = list(tangents)  # make a local copy
                if tangents[-1]:
                    msg = ("Double assignment of final_tangent. Both in "
                           "final_tangent ({:}) and tangents[-1] ({:}).")
                    raise ValueError(msg.format(final_tangent, tangents[-1]))
                else:
                    tangents[-1] = final_tangent

        if tangents:
            tngnts = TColgp_Array1OfVec_factory(tangents, skip_false=True)
            flags = [True if t else False for t in tangents]
            flags = TColStd_HArray1OfBoolean_factory(flags).handle
            builder.Load(tngnts, flags, scale)

        builder.Perform()

        if builder.IsDone():
            return builder
        else:
            raise Exception("interpolation filled, check inputs")

    @Attribute(private=True)
    def Handle_Geom_Curve(self):
        """:rtype: OCC.Geom.Handle_Geom_Curve"""
        curve = self.builder.Curve()
        if self.normalize:
            knots = TColStd_Array1OfReal(1, curve.NbKnots())
            curve.Knots(knots)
            BSplCLib__Reparametrize(0, 1, knots)
            curve.SetKnots(knots)
        return curve


class UIso(Curve):
    """Computes the U isoparametric curve. You have to specify the u-parameter
    at which this iso is fixed, the curve will than range from surface.v1 to
    surface.v2. Usage:

    >>> from parapy.geom import UIso, CylindricalSurface
    >>> surface = CylindricalSurface(radius=1, height=2)
    >>> crv = UIso(surface=surface, value=0.5)
    >>> # Let's now create several curves
    >>> crvs = [UIso(surface=surface, value=(i + 1) * 0.2,
    ...            line_thickness=3) for i in range(0, 9)]
    """

    __initargs__ = ["surface", "value"]

    #: surface on which you compute the iso-curve.
    #: :type: parapy.geom.Surface
    surface = Input()

    #: u-value for this iso line.
    #: :type: float
    value = Input()

    @Attribute(private=True)
    def Handle_Geom_Curve(self):
        """:rtype: OCC.Geom.Handle_Geom_Curve"""
        return self.surface.Handle_Geom_Surface.UIso(self.value)


class VIso(Curve):
    """Computes the V iso-parametric curve. You have to specify the v-parameter
    at which this iso is fixed, the curve will than range from surface.u1 to
    surface.u2. Usage:

    >>> from parapy.geom import VIso, CylindricalSurface
    >>> surface = CylindricalSurface(radius=1,height=2)
    >>> crv = VIso(surface=surface, value=3)
    >>> # Let's now create several curves
    >>> crvs = [VIso(surface=surface, value=(i + 1) * 0.2,
    ...            line_thickness=3) for i in range(0, 9)]
    """

    __initargs__ = ["surface", "value"]

    #: surface on which you an iso-curve.
    #: :type: parapy.geom.Surface
    surface = Input()

    #: v-value for this iso line.
    #: :type: float
    value = Input()

    @Attribute(private=True)
    def Handle_Geom_Curve(self):
        return self.surface.Handle_Geom_Surface.VIso(self.value)


class Conic(Curve):
    def is_planar_with_tolerance(self, tolerance: float = None) -> bool:
        return True


class Circle(Conic):
    """Create a circle by defining its :attr:`radius`. The circle lies by
    default on the x&y plane. Use :attr:`position` to define other location
    and/or orientation. Usage:

    >>> from parapy.geom import Circle
    >>> obj = Circle(radius=1)
    """

    __icon__ = os.path.join(ICN_DIR, 'circle.png')
    __initargs__ = ["radius", "position"]

    #: radius of the circle
    #: :type: float
    radius = Input()

    @Attribute
    def length(self):
        """

        :rtype: float
        """
        return 2 * math.pi * self.radius

    @Attribute(private=True)
    def Handle_Geom_Curve(self):
        """

        :rtype: OCC.Geom.Handle_Geom_Curve
        """
        return Geom_Circle(self.position.gp_Ax2, self.radius).handle

    @property
    def _new_curve_type(self):
        """

        :rtype: type
        """
        return Circle_

    def is_circular_with_tolerance(self, tolerance: float = None) -> bool:
        return True

    def is_elliptical_with_tolerance(self, tolerance: float = None) -> bool:
        return True

    def is_straight_with_tolerance(self, tolerance: float = 0.0) -> bool:
        return False


class Circle_(Circle):
    """
    Not to the used directly by user. Wraps an existing Handle_Geom_Circle
    """

    __initargs__ = ["Handle_Geom_Curve"]

    Handle_Geom_Curve = Input()

    @Attribute
    def position(self):
        """The local coordinate system of this conic. Vz is plane normal.
        Vx is in-plane and
        corresponds to origin of u-parameter. location is center point.

        :rtype: parapy.geom.Position
        """
        return self.Handle_Geom_Curve.Position().position

    @Attribute
    def radius(self):
        """computed radius of circle

        :rtype: float
        """
        return self.Handle_Geom_Curve.Radius()


class Circle3P(Circle_):
    """Create a circle by specifying three points on its perimeter.

    Usage:

    >>> from parapy.geom import Circle3P, Point
    >>> obj = Circle3P(point1=Point(1, 0, 0), point2=Point(0, 1, 0),
    ...                point3=Point(-1, 0, 0))
    """

    __initargs__ = ["point1", "point2", "point3"]

    #: first point
    #: :type: Point
    point1 = Input()

    #: second point
    #: :type: Point
    point2 = Input()

    #: third point
    #: :type: Point
    point3 = Input()

    @Attribute(private=True)
    def Handle_Geom_Curve(self):
        """Returns a Handle_Geom_Circle

        :rtype: OCC.Geom.Handle_Geom_Curve
        """
        builder = GC_MakeCircle(gp_Pnt(*self.point1),
                                gp_Pnt(*self.point2),
                                gp_Pnt(*self.point3))
        return resolve_gce_status(builder)


class Arc(Conic):
    """Make an arc from a circle defined by :attr:`radius` and
    :attr:`position`, between :attr:`start` point and the angle :attr:`alpha`
    given in radians.

    Usage:

    >>> from math import pi
    >>> from parapy.geom import Arc
    >>> crv = Arc(radius=1, angle=pi)
    """

    __icon__ = os.path.join(ICN_DIR, 'arc.png')
    __initargs__ = ("radius", "angle", "start", "position")

    #: radius of the arc
    #: :type: float
    radius = Input()

    #: angle of the arc in radians [radians]
    #: :type: float
    angle = Input()

    #: optional start point from which angle is defined. Defaults to *regular*
    #: start point as defined by :attr:`position` input (location of center of
    #: circle, translated by :attr:`radius` in x-direction).
    #: :type: Point
    start = Input(derived)

    #: If set to True, the curve will have the same orientation as the basis
    #: circle. In case of False, the orientation is opposite.
    #: :type: bool
    sense = Input(True)

    @start.getter
    def start(self):
        return translate(self.position, 'x', self.radius).location

    @Attribute(private=True)
    def Handle_Geom_Curve(self):
        """Handle_Geom_TrimmedCurve

        :rtype: OCC.Geom.Handle_Geom_Curve
        """
        A2, R = self.position.gp_Ax2, self.radius
        Circ = gp_Circ(A2, R)
        P, Alpha, Sense = gp_Pnt(*self.start), self.angle, self.sense
        builder = GC_MakeArcOfCircle(Circ, P, Alpha, Sense)
        return resolve_gce_status(builder)

    @property
    def _new_curve_type(self):
        return Arc_

    @Attribute(private=True)
    def Handle_Geom_Circle(self):
        """the underlying circle handle

        :rtype: OCC.Geom.Handle_Geom_Circle
        """
        hgc = self.Handle_Geom_Curve
        handle_geom_curve = hgc.BasisCurve()
        return Handle_Geom_Circle(handle_geom_curve)

    @Attribute
    def _Geom_Circle(self):
        """

        :rtype: OCC.Geom.Geom_Circle
        """
        hgc = self.Handle_Geom_Circle
        gc = Geom_Circle.__new__(Geom_Circle)
        gc.this = hgc.get()
        gc.__handle__ = hgc
        return gc

    def is_circular_with_tolerance(self, tolerance: float = None) -> bool:
        return self.is_closed

    def is_elliptical_with_tolerance(self, tolerance: float = None) -> bool:
        return self.is_closed


class Arc_(Arc):
    """Wraps a given Handle_Geom_Circle"""

    __initargs__ = ["Handle_Geom_Curve"]

    Handle_Geom_Curve = Input()

    @Attribute
    def start(self):
        # cannot use super because we need to skip a level in the
        # inheritance tree
        return self.get_slot_value("start", cls=Curve)

    @Attribute
    def position(self):
        """"
        The position of the arc. The center of the position is the center of
        the arc. The orientation
        is such that x points to the first point, and the arc is in the
        xy plane.

        :rtype: parapy.geom.Position
        """
        return self._Geom_Circle.Position().position

    @Attribute
    def radius(self):
        """
z        :rtype: float
        """
        return self._Geom_Circle.Radius()

    @Attribute
    def angle(self):
        """angle of rotation [radians]

        :rtype: float
        """
        # TODO: is this always true?
        arc = self.Handle_Geom_Curve
        return arc.LastParameter() - arc.FirstParameter()


class Arc2P(Arc_):
    """Make an arc by trimming a circle, defined by a :attr:`center`
    and two points on its perimeter, :attr:`start` and :attr:`end`. These two
    points form the bounds of the arc.

    Usage:

    >>> from parapy.geom import Arc2P, Point
    >>> obj = Arc2P(center=Point(0, 0, 0),
    ...             start=Point(1, 0, 0),
    ...             end=Point(0, 1, 0))
    """

    __initargs__ = ["center", "start", "end"]

    #: optional center point
    #: :type: tuple
    center = Input()

    #: first point on the circle
    #: :type: Point
    start = Input()

    #: second point on the circle
    #: :type: Point
    end = Input()

    #: :type: bool
    sense = Attribute(True)

    @Attribute
    def angle(self):
        center = self.center
        v1 = self.start - center
        v2 = self.end - center
        return Vector.angle(v1, v2)

    @Attribute
    def radius(self):
        return self.position.distance(self.start)

    @Attribute
    def position(self):
        center = self.center
        v1 = self.start - center
        v2 = self.end - center
        w = Vector.cross(v1, v2)
        orientation = Orientation(x=v1, z=w)
        return Position(center, orientation)

    @Attribute(private=True)
    def Handle_Geom_Curve(self):
        """
        :rtype: OCC.Geom.Handle_Geom_Curve
        """
        circle = gp_Circ(self.position.gp_Ax2, self.radius)
        builder = GC_MakeArcOfCircle(circle,
                                     gp_Pnt(*self.start),
                                     gp_Pnt(*self.end),
                                     self.sense)
        return resolve_gce_status(builder)


class Arc2A(Arc_):
    """Make an arc from a circle with :attr:`radius`. Arc bounds are
    :attr:`angle1` and :attr:`angle2`, both in radians.

    Usage:

    >>> from math import pi
    >>> from parapy.geom import Arc2A
    >>> obj = Arc2A(radius=1, angle1=pi/3, angle2=pi/2)
    """

    __initargs__ = ["radius", "angle1", "angle2"]

    #: radius of the arc
    #: :type: float
    radius = Input()

    #: start angle [radians]
    #: :type: float
    angle1 = Input()

    #: end angle [radians]
    #: :type: float
    angle2 = Input()

    #: optional Position of basis circle
    #: :type: Position
    position = Input(XOY, defaulting=True)

    @Attribute(private=True)
    def Handle_Geom_Curve(self):
        """
        :rtype: OCC.Geom.Handle_Geom_Curve
        """
        circle = gp_Circ(self.position.gp_Ax2, self.radius)
        builder = GC_MakeArcOfCircle(circle, self.angle1, self.angle2,
                                     self.sense)
        return resolve_gce_status(builder)


class Arc3P(Arc_):
    """Make an arc from three points that are located on a circle's perimeter.
    The arc bounds are :attr:`point1` and :attr:`point3`.

    Usage:

    >>> from parapy.geom import Arc3P, Point
    >>> obj = Arc3P(point1=Point(-1, 0, 0), point2=Point(0, 1, 0),
    ...             point3=Point(1, 0, 0))
    """

    __initargs__ = ["point1", "point2", "point3"]


    #: first point on the circle
    #: :type: Point
    point1 = Input()

    #: second point on the circle
    #: :type: Point
    point2 = Input()

    #: third point on the circle
    #: :type: Point
    point3 = Input()

    @Attribute(private=True)
    def Handle_Geom_Curve(self):
        """Returns a Handle_Geom_TrimmedCurve

        :rtype: OCC.Geom.Handle_Geom_Curve
        """
        builder = GC_MakeArcOfCircle(gp_Pnt(*self.point1),
                                     gp_Pnt(*self.point2),
                                     gp_Pnt(*self.point3))
        return resolve_gce_status(builder)


def Ellipse_minor_radius_validator(value, obj, slot):
    return value <= obj.major_radius


class Ellipse(Conic):
    """Create an ellipse in the x&y plane. The x-direction corresponds to
    :attr:`major_radius` and the y-direction corresponds to
    :attr:`minor_radius`. An error will show if :attr:`major_radius` is less
    than :attr:`minor_radius`.

    Usage:

    >>> from parapy.geom import Ellipse
    >>> obj = Ellipse(major_radius=1, minor_radius=0.5)
    """

    __Handle_Geom_Curve__ = Handle_Geom_Ellipse
    __initargs__ = ["major_radius", "minor_radius"]

    #: major radius of the ellipse
    #: :type: float
    major_radius = Input()

    #: minor radius of the ellipse
    #: :type: float
    minor_radius = Input(validator=Ellipse_minor_radius_validator)

    @Attribute(private=True)
    def Handle_Geom_Curve(self):
        """
        :rtype OCC.Geom.Handle_Geom_Ellipse
        """
        return Geom_Ellipse(self.position.gp_Ax2, self.major_radius,
                            self.minor_radius).handle

    @Attribute
    def eccentricity(self):
        """Returns eccentricity of the ellipse. Value is between 0 and 1.

        :rtype: float
        """
        return self.Handle_Geom_Curve.Eccentricity()

    @Attribute
    def focus1(self):
        """Returns the first focus of the ellipse. This focus is on the
        positive side of the "X-axis" of the ellipse.

        :rtype: parapy.geom.Point
        """
        return self.Handle_Geom_Curve.Focus1().point

    @Attribute
    def focus2(self):
        """Returns the second focus of the ellipse. This focus is on the
        negative side of the "X-axis" of the ellipse.

        :rtype: parapy.geom.Point
        """
        return self.Handle_Geom_Curve.Focus2().point

    @Attribute
    def focal(self):
        """Returns the distance between the :attr:`focus1` and :attr:`focus2`.
        :rtype: float
        """
        return self.Handle_Geom_Curve.Focal()

    @property
    def _new_curve_type(self):
        """
        :rtype: type
        """
        return Ellipse_

    def is_circular_with_tolerance(self, tolerance: float = None) -> bool:
        if tolerance is None:
            tolerance = CONFIGURATION["tolerance"]

        return self.focal < tolerance

    def is_elliptical_with_tolerance(self, tolerance: float = None) -> bool:
        return True

    def is_straight_with_tolerance(self, tolerance: float = None) -> bool:
        return False


class Ellipse_(Ellipse):
    __initargs__ = ["Handle_Geom_Curve"]

    #: :type: Handle_Geom_Curve
    Handle_Geom_Curve = Input()

    @Attribute
    def major_radius(self):
        """
        :rtype: float
        """
        return Handle_Geom_Ellipse(self.Handle_Geom_Curve).MajorRadius()

    @Attribute
    def minor_radius(self):
        """
        :rtype: float
        """
        return Handle_Geom_Ellipse(self.Handle_Geom_Curve).MinorRadius()


class DroppedCurve(Curve):
    """Drop a curve **normally** onto a surface. Three import things to
    keep in mind:

    1. You get a generic curve back only. You .downcast slot to get a more
       specific curve out. For
       example if you've dropped a BSplineCurve, .downcast will probably
       also be a BSplineCurve.
    2. The dropping algorithm works best if your curve is already close to
       the surface since it
       uses surface normals to find the projected shape.
    3. This curve has a parametric definition on the surface, but
       BEWARE: the pcurve calculation
       strongly depends on the tolerance value and has been known to
       potentially crash Python.
       Play with tolerance (making it larger) in such cases.

    Usage:

    >>> from parapy.geom import (DroppedCurve, CylindricalSurface, Point,
    ...                          LineSegment)
    >>> srf = CylindricalSurface(2,2)
    >>> crv1 = LineSegment(start=Point(3, 0, 1), end=Point(3, 1, 1))
    >>> crv2 = DroppedCurve(curve_in=crv1, surface_in=srf)
    """

    __initargs__ = ["curve_in", "surface_in"]

    #: a curve or edge
    #: :type: Curve
    curve_in = Input()

    #: can be a surface or face
    #: :type: parapy.geom.Surface
    surface_in = Input()

    #: Too small a value has been known to potentially crash Python
    #: :type: float
    tolerance = Input(0.0001)

    @Attribute(private=True)
    def Handle_Geom_Curve(self):
        """
        :rtype: OCC.Geom.Handle_Geom_Curve
        """
        handle = GeomProjLib__Project(self.curve_in.Handle_Geom_Curve,
                                      self.surface_in.Handle_Geom_Surface)
        if handle.IsNull():
            raise Exception("DroppedCurve failed. Instance {:}".format(self))
        else:
            return handle

    @Attribute(private=True)
    def Handle_Geom2d_Curve(self):
        """
        :rtype:  OCC.Geom2d.Handle_Geom2d_Curve
        """
        # BUG: This method fails
        # See also: http://www.opencascade.com/pub/doc/Release_Notes_6.5.5.pdf
        # return GeomProjLib_Curve2d(self.curve_in.Handle_Geom_Curve,
        #                            self.curve_in.u1, self.curve_in.u2,
        #                            self.surface_in.Handle_Geom_Surface,
        #                            self.tolerance)
        # BUG: wrapper exposes no signature with tolerance.
        # return GeomProjLib_Curve2d(self.curve_in.Handle_Geom_Curve,
        #                            self.curve_in.u1, self.curve_in.u2,
        #                            self.surface_in.Handle_Geom_Surface,
        #                            self.tolerance)
        # manual approach
        acurve = GeomAdaptor_Curve(self.curve_in.Handle_Geom_Curve)
        asurface = GeomAdaptor_Surface(self.surface_in.Handle_Geom_Surface)
        ahcurve = GeomAdaptor_HCurve(acurve)
        ahsurface = GeomAdaptor_HSurface(asurface)
        HS = ahsurface.handle
        HC = ahcurve.handle
        proj = ProjLib_ProjectedCurve(HS, HC, self.tolerance)
        Type = proj.GetType()
        if Type is GeomAbs_Line:
            return proj.Line()
        elif Type is GeomAbs_Circle:
            return proj.Circle()
        elif Type is GeomAbs_Ellipse:
            return proj.Ellipse()
        elif Type is GeomAbs_Hyperbola:
            return proj.Hyperbola()
        elif Type is GeomAbs_Parabola:
            return proj.Parabola()
        elif Type is GeomAbs_BezierCurve:
            return proj.Bezier()
        elif Type is GeomAbs_BSplineCurve:
            return proj.BSpline()
        else:
            raise Exception("Projection did not give a recognized curve type")

    @Attribute
    def pcurve(self):
        """
        :rtype: Curve2d
        """
        from .curve2d import ClonedCurve2d  # to suppress circular import

        return ClonedCurve2d(self.Handle_Geom2d_Curve,
                             on_surface=self.surface_in)


class ZeroCurvature(Exception):
    def __init__(self, msg=None, obj=None):
        if msg:
            super(ZeroCurvature, self).__init__(msg)
        else:
            super(ZeroCurvature, self).__init__()
        self.obj = obj


def _get_normal(crv, u, normalized=True):
    """Get normal vector.

    :param OCC.GeomAdaptor.GeomAdaptor_Curve | OCC.Geom.Handle_Geom_Curve crv:
        crv to get normal on.
    :param float u: parameter on curve
    :rtype: parapy.geom.Vector
    """
    d1u = crv.DN(u, 1)
    d2u = crv.DN(u, 2)
    if d2u.Magnitude() == 0.0:
        raise ZeroCurvature()
    d1u.Normalize()
    nu_dot = d1u.Dot(d2u)
    d1u.Multiply(nu_dot)
    d2u.Subtract(d1u)
    if normalized:
        d2u.Normalize()
    return Vector(*d2u.Coord())


if __name__ == '__main__':
    from parapy.gui import display
    crv1 = Line(Point(1, 0, 0), Vector(1, 0, 0), v_dim=2, color="red")
    crv2 = LineSegment(Point(0, -1, 0), Point(0, 1, 0), color="green")
    basis_curve = Circle(1.0)
    crv3 = TrimmedCurve(basis_curve, limit1=0.5*math.pi, limit2=math.pi)
    pts = [Point(0, 0, 0), Point(0, 1, 0), Point(1, 1, 0), Point(1, 0, 0)]
    crv4 = BezierCurve(pts)
    pts = [Point(0, 0, 0), Point(0, 1, 0), Point(1, 1, 0), Point(1, 0, 0)]
    crv5 = BSplineCurve(pts)
    pts = [Point(0, 0, 2), Point(4, 2, 2), Point(8, 2, 2)]
    crv6 = FittedCurve(points=pts, max_degree=3)
    pts = [Point(0, 0, 0), Point(1, 0, 0)]
    crv7 = InterpolatedCurve(points=pts,
                             initial_tangent=Vector(0, 1, 0),
                             final_tangent=Vector(0, -1, 0))

    display((crv1, crv2, crv3, crv4, crv5, crv6, crv7))

