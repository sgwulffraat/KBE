#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import math
import warnings
from typing import Tuple, Union

from OCC.utils.edge import first_last_vertex
from OCC.utils.top import downcast_shape
from OCC.wrapper.BRep import (
    BRep_Tool_Curve, BRep_Tool_CurveOnSurface, BRep_Tool_Degenerated,
    BRep_Tool_IsClosed, BRep_Tool_Parameter, BRep_Tool_UVPoints)
from OCC.wrapper.BRepAdaptor import BRepAdaptor_Curve
from OCC.wrapper.BRepBuilderAPI import (
    BRepBuilderAPI_MakeEdge, BRepBuilderAPI_MakeVertex)
from OCC.wrapper.BRepLib import BRepLib__BuildCurves3d
from OCC.wrapper.Geom import Geom_TrimmedCurve
from OCC.wrapper.Geom2d import Geom2d_TrimmedCurve
from OCC.wrapper.TopAbs import TopAbs_EDGE, TopAbs_FACE
from OCC.wrapper.TopExp import TopExp__FirstVertex, TopExp__LastVertex
from OCC.wrapper.gp import gp_Pnt, gp_Pnt2d

from parapy.core import Attribute, HiddenPart, Input, lazy_hasattr
from parapy.core.part import HiddenPartNoParsing, PrivatePartNoParsing
from parapy.geom.generic import Point
from parapy.geom.occ.brep import BRep
from parapy.geom.occ.curve import ClonedCurve, Curve, LineSegment
from parapy.geom.occ.curve2d import ClonedCurve2d
from parapy.geom.occ.surface import (
    InfiniteConicalSurface, InfiniteCylindricalSurface)
from parapy.geom.occ.vertex import Vertex_

POINT_OR_VERTEX = Union[Point, Vertex_]
TUP_POINT_OR_VERTEX = (Point, Vertex_)


class Edge_(BRep, Curve):
    """Wrapper around TopoDS_Edge. Abstract."""

    TOPODIM = 1
    TOPOLEVEL = 6  # 7: Vertex, 6: Edge, 5: Wire, 4: Face, 3: Shell,
                   # 2: Solid, 1: CompSolid, 0: Compound
    BUILDERKEY = "Edge"  # self.builder.Shape()

    # =========================================================================
    # Representations
    # =========================================================================

    @Attribute(private=True)
    def TopoDS_Edge(self):
        return downcast_shape(self.TopoDS_Shape, TopAbs_EDGE)

    @Attribute
    def _Adaptor3d_Curve(self):
        """Root class for 3D curves on which geometric algorithms work.

        :rtype: OCC.BRepAdaptor.BRepAdaptor_Curve
        """
        return BRepAdaptor_Curve(downcast_shape(self.TopoDS_Shape,
                                                TopAbs_EDGE))
        # return BRepAdaptor_Curve(TopoDS__Edge(
        #     self.TopoDS_Shape.Oriented(TopAbs_FORWARD)))

    @Attribute(private=True)
    def Handle_Geom_Curve(self):
        """potentially trimmed curve handle.

        :rtype: OCC.Geom.Handle_Geom_Curve
        """
        h_geom_curve, u1, u2 = BRep_Tool_Curve(self.TopoDS_Edge)
        if (u1 != h_geom_curve.FirstParameter() or
                    u2 != h_geom_curve.LastParameter()):
            return Geom_TrimmedCurve(h_geom_curve, u1, u2).handle
        else:
            return h_geom_curve

    @PrivatePartNoParsing
    def basis_curve(self):
        """Untrimmed underlying Curve object on which this edge builds.
        Each edge of a Box, for example, return an infinite Line object.

        :rtype: parapy.geom.Curve
        """
        handle_geom_curve, _, _ = BRep_Tool_Curve(self.TopoDS_Edge)
        return ClonedCurve(handle_geom_curve)

    @PrivatePartNoParsing
    def curve(self):
        """Returns the (potentially) trimmed underlying curve
        object on which this edge builds.
        Each edge of a Box, for example, returns a
        trimmed line object (TrimmedCurve_).

        :rtype: parapy.geom.Curve
        """
        return ClonedCurve(self.Handle_Geom_Curve)

    # =========================================================================
    # Topology
    # =========================================================================

    # @PrivatePartNoParsing # don't trickle down
    # def vertices(self):
    #     """override of general method to make orientedness respected!"""
    #     it = TopExp_Explorer(self.TopoDS_Shape.Oriented(TopAbs_FORWARD),
    #                          TopAbs_VERTEX)
    #     Vertex, _owner = self.VertexClass, self._owner
    #     lst = []
    #     while it.More():
    #         lst.append(Vertex(TopoDS_Shape=it.Current(), _owner=_owner))
    #         it.Next()
    #     return lst

    @PrivatePartNoParsing  # don't trickle down
    def vertices(self):
        """override of general method to make orientedness respected!

        :rtype: list[parapy.geom.occ.vertex.Vertex_]

        .. caution:: can return one vertex only!!!
        """
        return list(self._sub_shape_generator("vertex"))

    def first_last_vertex(self, oriented=True):
        """Return first and last vertices of this Edge. If ``oriented``,
        takes :attr:`brep_orientation` of this edge ('forward' or 'reversed')
        into account.

        :param bool oriented:  If ``oriented == True`` and this edge its
            :attr:`brep_orientation` is 'forward', return the Vertex
            with :attr:`brep_orientation` 'forward' first, and the Vertex with
            :attr:`brep_orientation` 'reversed' second. If
            this edge its :attr:`brep_orientation` is 'reversed', it will return
            these vertices in the order 'reversed', 'forward'. (default: True)
        :rtype: (parapy.geom.occ.vertex.Vertex_ | None, parapy.geom.occ.vertex.Vertex_ | None)

        .. caution:: in the unlikely event of this edge missing or having
            wrongly oriented Vertices, individual vertices may be None.
        """
        v1, v2 = first_last_vertex(self.TopoDS_Edge, oriented=oriented)
        return tuple(self._safe_TopoDS2Vertices(v1, v2))

    @Attribute
    def ordered_vertices(self):
        """Return first and last vertices of this Edge. Takes orientation of
        this edge (FORWARD or REVERSED) into account.

        :rtype: (parapy.geom.occ.vertex.Vertex_ | None, parapy.geom.occ.vertex.Vertex_ | None)

        .. caution:: in the unlikely event of this edge missing or having
            wrongly oriented Vertices, result may be None.
        """
        return self.first_last_vertex(oriented=True)

    @Attribute
    def first_vertex(self):
        """First Vertex on Edge.

        :rtype: parapy.geom.occ.vertex.Vertex_ | None

        .. caution:: in the unlikely event of this edge missing or having
            wrongly oriented Vertices, result may be None.
        """
        v = TopExp__FirstVertex(self.TopoDS_Edge, True)  # True is for CumOri
        return next(self._safe_TopoDS2Vertices(v))

    @Attribute
    def last_vertex(self):
        """First Vertex on Edge. Takes orientation of this edge (FORWARD or
        REVERSED) into account.

        :rtype: parapy.geom.occ.vertex.Vertex_ | None

        .. caution:: in the unlikely event of this edge missing or having
            wrongly oriented Vertices, result may be None.

        """
        v = TopExp__LastVertex(self.TopoDS_Edge, True)  # True is for CumOri
        return next(self._safe_TopoDS2Vertices(v))

    @Attribute
    def on_faces(self):
        """list of faces on which I lie

        :rtype: list[parapy.geom.occ.face.Face_]
        """
        return self.get_ancestors("face")

    @Attribute
    def neighbours(self):
        """list of edges. This slot performs a **global** analysis through the
        owning BRep to find all Edges that connect to this edge by sharing of
        at least one vertex.

        :rtype: list[Edge_]
        """
        wire_to_compsolid = self.trace_up_owner("wire", "compsolid")
        return self.get_neighbours("vertex", wire_to_compsolid)

    @Attribute
    def opposite_edge(self):
        """Returns the single opposite edge. If this is ambiguous,
        an exception is raised. You have to retrieve this edge through a
        reference chain that at least involves an (owning) Face or Wire
        object!

        Usage:

        >>> from parapy.geom import Box
        >>> box = Box(1, 1, 1)
        >>> edge = box.faces[0].edges[0]
        >>> edge.opposite_edge
   
        And do not use it like:

        >>> from parapy.geom import Box
        >>> box = Box(1, 1, 1)
        >>> edge = box.edges[0]
        >>> edge.opposite_edge # <- ambiguous, because I'm on many faces.

        :rtype: Edge_
        """
        wire_or_face = self.trace_up_owner("wire", "face")  # not higher level!
        opposite_edges = self.opposite_edges(wire_or_face)
        if opposite_edges:
            if len(opposite_edges) == 1:
                return opposite_edges[0]
            else:
                raise Exception("Opposite edge is ambiguous because we"
                                " found %s edges. Use "
                                "opposite_edges." % (len(opposite_edges)))
        else:
            raise Exception("Couldn't find opposite edge. Is "
                            "the owning wire/face perhaps closed"
                            "with only 1, 2, or 3 edges that "
                            "are all neighbours?")

    def opposite_edges(self, owner=None):
        """``owner`` is a Wire or Face that own this edge.

        :param parapy.geom.BRep owner: Either a Face or a Wire
        :returns: list of Edge objects.
        :rtype: list[Edge_]
        """
        owner = owner or self.trace_up_owner("wire", "face")  # not higher
                                                              # level!
        shape = self.TopoDS_Shape
        f = shape.IsSame
        # find all other edges in the owning wire or face object
        other_edges = [edge for edge in owner.edges
                            if not f(edge.TopoDS_Shape)]
        # find those edge that touch me
        neighbours = self._get_neighbours(7, owner.TopoDS_Shape)  # 7 is Vertex
        # now find difference between other_edges and neighbours
        for n in neighbours:
            f = n.IsSame
            for other in other_edges:
                if f(other.TopoDS_Shape):
                    other_edges.remove(other)
        return other_edges

    @Attribute
    def is_multi_manifold(self):
        """Am I shared more than 2 times?

        :rtype: bool
        """
        return self.is_shared and len(self.on_faces) > 2

    @Attribute
    def is_seam(self):
        """am I a seam? NB: a seam edge is an edge that has
        two pcurves on one surface. Geometries
        like a cylinder or a cone have a longitudinal edge that is a seam,
        as it serves both as
        start and end boundary of the lateral face.

        :rtype: bool
        """
        #faces = self.on_faces
        #return len(faces) == 2 and \
        #   faces[0].TopoDS_Shape.IsPartner(faces[1].TopoDS_Shape) and\
        on_faces = self.on_faces
        if len(on_faces) >= 1:
            return BRep_Tool_IsClosed(self.TopoDS_Edge,
                                      self.on_faces[0].TopoDS_Face)
        else:
            return False

    @Attribute
    def is_degenerate(self):
        """Is this edge degenerate? NB: a degenerate edge
        lies on a surface singularity that
        corresponds to a single point in 3D space. The apex
        of a cone is such a point.

        :rtype: bool
        """
        return True if BRep_Tool_Degenerated(self.TopoDS_Edge) else False

    # FIXME: orientation http://opencascade.blogspot.nl/2009/02/topology-and-geometry-in-open-cascade_27.html
    def _pcurve(self, face, topods_edge=None):
        """
        :type face: parapy.geom.occ.face.Face_
        :type topods_edge: OCC.TopoDS.TopoDS_Edge
        :rtype: OCC.Geom2d.Handle_Geom2d_Curve | None
        """
        topods_edge = topods_edge or self.TopoDS_Edge
        if self._owner and self.is_seam:
            warnings.warn("This edge is a seam edge")
        topods_face = face.TopoDS_Face
        geom2d_curve, u_min, u_max = BRep_Tool_CurveOnSurface(topods_edge,
                                                              topods_face)
        if geom2d_curve.IsNull():
            return None

        if (u_min != geom2d_curve.FirstParameter() or
                    u_max != geom2d_curve.LastParameter()):
            # trim it
            return Geom2d_TrimmedCurve(geom2d_curve, u_min, u_max).handle
        else:
            return geom2d_curve

    def pcurve(self, face):
        """Return a new PCurve on particular face or None.

        :type face: parapy.geom.occ.face.Face_
        :rtype: parapy.geom.occ.curve2d.Curve2d | None
        """
        pcurve = self._pcurve(face)
        if pcurve:
            surf = face.basis_surface
            return ClonedCurve2d(pcurve, on_surface=surf)
        else:
            return None

    @PrivatePartNoParsing  # don't trickle down
    def pcurves(self):
        """
        :rtype: list[parapy.geom.occ.curve2d.Curve2d | None]
        """
        if self.is_seam:
            # I have two pcurves on this surface.
            # Use both my forward and backward orientations.
            face = self.on_faces[0]
            forward = self.TopoDS_Edge
            reversed = downcast_shape(forward.Complemented(), TopAbs_EDGE)
            return [ClonedCurve2d(self._pcurve(face, forward),
                                  on_surface=face.basis_surface),
                    ClonedCurve2d(self._pcurve(face, reversed),
                                  on_surface=face.basis_surface)]
        else:
            return [ClonedCurve2d(self._pcurve(face), on_surface=face.basis_surface) for \
                    face in self.on_faces]

    @Attribute
    def uv_points_on_faces(self):
        """Return a tuple containing the results of
        calling ``uv_points`` for each face in ``on_faces``.

        :returns: tuple. ``{Face: ((u1, v1), (u2, v2)),
            Face: ((u1, v1), (u2, v2)), ...}``
        :rtype: tuple[parapy.geom.Face, tuple[tuple[float]]]

        .. caution:: Beware that Face equality is not based on
            :py:`TopoDS_Shape.__hash__()`
        """
        on_faces = self.on_faces
        return tuple((f, self.uv_points(f)) for f in on_faces)

    def uv_points(self, face, check=True):
        """Get the UV locations of the extremities of the edge.

        :param parapy.geom.Face face: Face object.
            (specify one from ``edge.on_faces`` perhaps...)
        :returns: tuple. ((u1, v1), (u2, v2))
        :rtype: tuple[tuple[float, float], tuple[float, float]]
        """
        pt1, pt2 = gp_Pnt2d(), gp_Pnt2d()
        forward = downcast_shape(self.TopoDS_Shape, TopAbs_EDGE)
        # reversed = TopoDS__Edge(forward.Complemented())
        BRep_Tool_UVPoints(forward,
                           downcast_shape(face.TopoDS_Shape, TopAbs_FACE),
                           pt1, pt2)
        result = (pt1.X(), pt1.Y()), (pt2.X(), pt2.Y())
        if check and result == ((0.0, 0.0), (0.0, 0.0)):
            warnings.warn(
                "uv_points(): this edge does probably not lie on "
                "specified face. All zeros returned.")
        return result

    # =========================================================================
    # Transformations
    # =========================================================================
    @Attribute
    def reversed(self):
        """
        Returns a new edge that is the reversed of this edge
        Warning: edge does not lie on any face in
        the owning topology object anymore.
        http://www.opencascade.org/org/forum/thread_3680/?forum=3

        :rtype Edge_
        """
        topods_edge = self.TopoDS_Edge
        crv, u1, u2 = BRep_Tool_Curve(topods_edge)
        rev_u1 = float(crv.ReversedParameter(u1))
        rev_u2 = float(crv.ReversedParameter(u2))
        v1, v2 = first_last_vertex(topods_edge)

        u_v1 = BRep_Tool_Parameter(v1, topods_edge)
        u_v2 = BRep_Tool_Parameter(v2, topods_edge)

        if u_v1 > u_v2:  # order the vertices based on the u-parameter
            v1, v2 = v2, v1  # swap

        builder = BRepBuilderAPI_MakeEdge(
            crv.Reversed(), v2, v1, rev_u2, rev_u1)
        if builder.IsDone():
            topods_edge = builder.Edge()
            return Edge_(TopoDS_Shape=topods_edge, _owner=self._owner)
        else:
            msg = "Failed to reverse Edge. Parameters u1 {:}, u2 {:}."
            raise RuntimeError(msg.format(u2, u1))

# monkey_patch BRep class
BRep.EdgeClass = Edge_
# monkey_patch Curve class
Curve.EdgeClass = Edge_


class Edge(Edge_):
    """Create an :class:`Edge_` from :attr:`built_from`, which is either a:

    1.  curve:                   ``Edge(built_from: Curve)``
    2.  a pair of Point|Vertex:  ``Edge(built_from: (POINT_OR_VERTEX, POINT_OR_VERTEX))``

    Usage:

    >>> from parapy.geom import FittedCurve, Point, Edge, Box
    >>> # from a curve
    >>> curve = FittedCurve(points=[Point(0, 0), Point(1, 0), Point(1, 1)])
    >>> edge1 = Edge(built_from=curve)
    >>> # from 2 points
    >>> points = Point(0, 0), Point(1, 0)
    >>> edge2 = Edge(built_from=points)
    >>> # from 2 vertices
    >>> box = Box(1, 1, 1)
    >>> vertices = box.vertices[0], box.vertices[-1]  # diagonal
    >>> edge3 = Edge(built_from=vertices)

    ..note:: The option to create an Edge from 2 existing :class:`Vertex_`
        objects is useful when compounding topology where it is of key
        importance that the edge builds on the vertices of an existing topology
        (for example, for meshing purposes).

        In case of the ``box`` and ``edge3`` example above, one could compound
        both shapes to create a new topology consisting only of the original 8
        vertices of the Box.

        >>> from parapy.geom import Box, Compound, Edge
        >>> box = Box(1, 1, 1)
        >>> vertices = box.vertices[0], box.vertices[-1]  # diagonal
        >>> edge = Edge(built_from=vertices)
        >>> shape = Compound([box, edge])
        >>> len(shape.edges), len(shape.vertices)
        (13, 8)

        Compare this to creating the same edge from points leading to 10
        vertices (2 new Vertices have been created).

        >>> from parapy.geom import Box, Compound, Edge
        >>> box = Box(1, 1, 1)
        >>> points = box.vertices[0].point, box.vertices[-1].point  # diagonal
        >>> edge = Edge(built_from=points)
        >>> shape = Compound([box, edge])
        >>> len(shape.edges), len(shape.vertices)
        (13, 10)
    """
    __initargs__ = ["built_from"]

    built_from: Union[Curve, Tuple[POINT_OR_VERTEX, POINT_OR_VERTEX]] = Input()

    @built_from.validator
    def built_from(self, value):
        if hasattr(value, "__iter__"):
            v1, v2 = value  # can raise, that's okay
            return (isinstance(v1, TUP_POINT_OR_VERTEX) and
                    isinstance(v2, TUP_POINT_OR_VERTEX))
        elif lazy_hasattr(value, "Handle_Geom_Curve"):
            return True
        return False, ("type should be a Curve or "
                       "Sequence[POINT_OR_VERTEX, POINT_OR_VERTEX]")

    @Attribute
    def builder(self) -> BRepBuilderAPI_MakeEdge:
        built_from = self.built_from
        if hasattr(built_from, "__iter__"):  # (POINT_OR_VERTEX, POINT_OR_VERTEX)
            start, end = built_from
            args = self._unify_args(start, end)
        else:  # Curve
            args = (built_from.Handle_Geom_Curve,)
        builder = BRepBuilderAPI_MakeEdge(*args)
        self._check_builder(builder)
        return builder

    @staticmethod
    def _check_builder(builder: BRepBuilderAPI_MakeEdge):
        if not builder.IsDone():
            enum = builder.Error()
            msg = f"Operation failed with BRepBuilderAPI_EdgeError: {enum}"
            raise RuntimeError(msg)

    @staticmethod
    def _unify_args(arg1: POINT_OR_VERTEX, arg2: POINT_OR_VERTEX):
        """Unifies ParaPy types for BRepBuilderAPI_MakeVertex.

        - (Point, Point) -> (gp_Pnt, gp_Pnt)
        - any other combination to -> (TopoDS_Vertex, TopoDS_Vertex)

        In order to support:

        - BRepBuilderAPI_MakeVertex(gp_Pnt, gp_Pnt)
        - BRepBuilderAPI_MakeVertex(TopoDS_Vertex, TopoDS_Vertex)
        """
        if isinstance(arg1, Vertex_):
            arg1 = arg1.TopoDS_Vertex
            if isinstance(arg2, Vertex_):  # arg1: Vertex, arg2: Vertex
                arg2 = arg2.TopoDS_Vertex
            else:  # arg1: Vertex, arg2: Point
                pnt2 = gp_Pnt(*arg2)
                arg2 = BRepBuilderAPI_MakeVertex(pnt2).Vertex()
        elif isinstance(arg2, Vertex_):  # arg1: Point, arg2: Vertex
            pnt1 = gp_Pnt(*arg1)
            arg1 = BRepBuilderAPI_MakeVertex(pnt1).Vertex()
            arg2 = arg2.TopoDS_Vertex
        else:  # arg1: Point, arg2: Point
            arg1 = gp_Pnt(*arg1)
            arg2 = gp_Pnt(*arg2)
        return arg1, arg2


class EdgeSegment(Edge_):
    """Creates an edge between 2 points and/or vertices
    ``EdgeSegment(start: POINT_OR_VERTEX, end: POINT_OR_VERTEX)``. Usage:

    >>> from parapy.geom import EdgeSegment, Point
    >>> # from points
    >>> pt1, pt2 = Point(0, 0, 0), Point(1, 0, 0)
    >>> edge1 = EdgeSegment(start=pt1, end=pt2)
    >>> # from vertices
    >>> from parapy.geom import Box
    >>> box = Box(1, 1, 1)
    >>> v1, v2 = box.vertices[0], box.vertices[-1]  # diagonal
    >>> edge2 = EdgeSegment(start=v1, end=v2)

    .. note:: this class is an alternative to writing
        ``Edge(built_from=[start, end])``. See note in :class:`Edge` for use
        of vertices in topology creation / meshing.
    """

    __initargs__ = ["start", "end"]

    start: POINT_OR_VERTEX = Input()
    end: POINT_OR_VERTEX = Input()

    @Attribute
    def builder(self):
        arg1, arg2 = Edge._unify_args(self.start, self.end)
        return BRepBuilderAPI_MakeEdge(arg1, arg2)

    def is_circular_with_tolerance(self, tolerance: float = None) -> bool:
        return False

    def is_elliptical_with_tolerance(self, tolerance: float = None) -> bool:
        return False

    def is_planar_with_tolerance(self, tolerance: float = None) -> bool:
        return True

    def is_straight_with_tolerance(self, tolerance: float = None) -> bool:
        return True


class FoldedCurve(Edge_):
    """Creates a 3d curve by folding a uv-curve :attr:`curve_in` onto the
    surface :attr:`surface_in`. For example, folding a straight 2d curve
    from (0, 0) to (2pi,1) onto a cylindrical surface will result in a
    helix (a 3d curve).

    Usage:

    >>> from math import pi
    >>> from parapy.geom import (FoldedCurve, CylindricalSurface, LineSegment,
    ...                          Point)
    >>> srf = CylindricalSurface(radius=1, height=2)
    >>> crv = LineSegment(start=Point(0, 0), end=Point(2 * pi, 1))
    >>> obj = FoldedCurve(crv, srf)
    """

    __initargs__ = ["curve_in", "surface_in"]

    #: Any curve, but z coordinate zero!!!
    #: :type: parapy.geom.Curve
    curve_in = Input()

    #: surface to build this tool on
    #: :type: parapy.geom.Surface
    surface_in = Input()

    @Attribute(private=True)
    def TopoDS_Shape(self):
        """
        :rtype: OCC.TopoDS.TopoDS_Shape
        """
        builder = BRepBuilderAPI_MakeEdge(self.curve_in.Handle_Geom2d_Curve,
                                          self.surface_in.Handle_Geom_Surface)
        edge = builder.Edge()
        BRepLib__BuildCurves3d(edge)
        return edge


def _Helix_radius_validator(radius2, obj, slot):
    """
    :type radius2: float
    :type obj: Helix
    :rtype: bool
    """
    return radius2 <= obj.radius1


class Helix(FoldedCurve):
    """Creates a helix (a 3d curve) with contanst :attr:`radius`, :attr:`pitch`
    and number of :attr:`revolutions`. Axis system can be specified using
    :attr:`position`, where location lies at bottom center, z-direction
    corresponds to height of helix, x-direction defines starting point.

    >>> from parapy.geom import Helix
    >>> # constant radius
    >>> crv = Helix(radius=3, pitch=1, revolutions=5)
    >>> crv = Helix(3, 1, 5)  # shorthand

    For a tapered curve, specify :attr:`radius1` (bottom radius) and
    :attr:`radius2` (top radius) instead.

    >>> crv = Helix(pitch=1, revolutions=5, radius1=3, radius2=2)

    .. note:: respect :attr:`radius2` ``<=`` :attr:`radius1`.
    """

    __initargs__ = ["radius", "pitch", "revolutions"]

    #: Use this radius for constant radius
    #: :type: float
    radius = Input()

    #: axial distance of one revolution
    #: :type: float
    pitch = Input()

    #: the number of revolutions. Defaults to 1.
    #: :type: int
    revolutions = Input(1)

    #: bottom radius, defaults to radius. Override for tapered helix
    #: :type: float
    radius1 = Input(radius)

    #: top radius, defaults to radius1. Override for tapered helix
    #: :type: float
    radius2 = Input(radius1, validator=_Helix_radius_validator)

    @HiddenPart
    def curve_in(self):
        """
        :rtype: LineSegment
        """
        return LineSegment(Point(0, 0, 0),
                           Point(self.revolutions * 2 * math.pi,
                                 self.pitch * self.revolutions,
                                 0))

    @HiddenPartNoParsing
    def surface_in(self):
        """
        :rtype: parapy.geom.InfiniteCylindricalSurface |
            parapy.geom.InfiniteConicalSurface
        """
        r1 = self.radius1
        r2 = self.radius2
        if r1 == r2:
            return InfiniteCylindricalSurface(r1)
        else:
            height = self.pitch * self.revolutions
            # calculate height of APEX. 
            if r2 < r1:
                H = r1 / (r1 - r2) * height
            else:
                H = -r2 / (r2 - r1) * height - height
            return InfiniteConicalSurface(r1, H)
