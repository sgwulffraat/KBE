#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""There are five types of transformation classes:

1. Translated: translate over a vector
2. Rotated: rotate around an axis over an angle
3. Scaled: scale by a factor w.r.t. reference point
4. Mirrored: point, line or plane mirroring
5. Transformed: generic transformation based on Position1 and Position2

All these operations have been specialized for 3 types of objects, leading to
15 classes. Object types are:

1. Curve: Any Curve-derived object
2. Surface: Any Surface-derived object
3. Shape: Any BRep-derived object (including Edge and Face)

Each specific class has a logically concatenated name, e.g. for translating a
curve, use TranslatedCurve.
"""

import os
import warnings
from math import pi

from OCC.wrapper.BRep import BRep_Tool_Curve, BRep_Tool_Surface
from OCC.wrapper.BRepBuilderAPI import (
    BRepBuilderAPI_GTransform, BRepBuilderAPI_Transform)
from OCC.wrapper.BRepTools import BRepTools_ReShape
from OCC.wrapper.Geom import (
    Geom_TrimmedCurve, Handle_Geom_Curve_DownCast,
    Handle_Geom_Surface, Handle_Geom_Surface_DownCast)
from OCC.wrapper.ShapeFix import ShapeFix_Shape
from OCC.wrapper.TopAbs import TopAbs_EDGE, TopAbs_FACE, TopAbs_SHELL, TopAbs_WIRE
from OCC.wrapper.gp import gp_Ax1, gp_Dir, gp_GTrsf, gp_Pnt, gp_Trsf, gp_Vec
from OCC.utils.top import downcast_shape
from OCC.utils.utilities import handle_is_instance

from parapy.core import (
    Attribute, Base, DynamicType, Input, Part, ensure_iterable)
from parapy.core.utilities import raise_conditionally
from parapy.geom.generic import Vector, rotate
from parapy.geom.generic.positioning import (
    Axis, Orientation, Position, XOY, AbstractPoint, Tuple3D)
from parapy.geom.globs import ICN_DIR
from parapy.geom.occ.brep import BRep
from parapy.geom.occ.compound import Compound, Compound_, Shape
from parapy.geom.occ.curve import Curve
from parapy.geom.occ.edge import Edge_
from parapy.geom.occ.face import Face_
from parapy.geom.occ.shell import Shell_
from parapy.geom.occ.solid import Solid_
from parapy.geom.occ.surface import Handle_Geom_Surface2ParaPy, Surface
from parapy.geom.occ.tolerances import get_max_tolerances
from parapy.geom.occ.utilities import (
    SubShapeGenerator_, downcast_handle_geom_curve,
    downcast_handle_geom_surface,
    gp_Ax3_from_position, sub_shapes, topods_shape_getter)
from parapy.geom.occ.vertex import Vertex_
from parapy.geom.occ.wire import Wire_

_TOPO2CLS = [Compound_, Solid_, Solid_, Shell_, Face_, Wire_, Edge_, Vertex_]


def TOPO2CLS(topods_shape):
    """Given an OCC shape ``topods_shape``, return the ParaPy class that wraps
    it.

    :param OCC.TopoDS.TopoDS_Shape topods_shape: The shape that we want to
        find the class for that wraps it.
    :rtype: parapy.core.meta.basetype
    """
    return _TOPO2CLS[topods_shape.ShapeType()]


class _TransformBase(Base):
    """Abstract base class for all transformation classes for curves, surfaces
    and shapes"""

    # _obj_in_key = None

    @Attribute
    def built_from(self):
        """:rtype: parapy.geom.BRep"""
        return getattr(self, self._obj_in_key)

    @Attribute
    def position(self):
        """Transformed ``built_from.position``. If ``built_from`` has no
        position, defaults to ancestor ``position`` or ``XOY``.

        :rtype: parapy.geom.Position
        """
        raise NotImplementedError()

    @Attribute
    def _trsf(self):
        """The OCC transformation object.

        :rtype: OCC.gp.gp_Trsf
        """
        raise NotImplementedError()

    # ----- for CATIA API ------
    @Attribute
    def _info(self):
        """:rtype: dict[str, T]"""
        msg = ("implement in subclass, should be a dict with additional info "
               "for CATIA")
        raise NotImplementedError(msg)

    @Attribute
    def _transformation(self):
        """Contains some _transformation info for CATIA API.

        :rtype: list[OCC.gp_gpTrsf, BRep|Curve|Surface, dict[str, T]]
        """
        return [self._trsf, getattr(self, self._obj_in_key), self._info]


class _Transformed(_TransformBase):
    """mixin for all Transformed classes"""

    #: transform from this position
    #: :type: parapy.geom.Position
    from_position = Input()

    #: transform to this position
    #: :type: parapy.geom.Position
    to_position = Input()

    @Attribute
    def _trsf(self):
        """OCC transformation object.

        :rtype: OCC.gp.gp_Trsf
        """
        trsf = gp_Trsf()
        trsf.SetDisplacement(self.from_position.gp_Ax3,
                             self.to_position.gp_Ax3)
        return trsf

    @Attribute
    def _info(self):
        """Contains some _transformation info for CATIA API.

        :rtype: dict[str, str | parapy.geom.Position]
        """
        return {"operation": "transformed",
                "from_position": self.from_position,
                "to_position": self.to_position}

    # FIXME (TBD): transform built_from.position according to relative
    # /fixme transformation
    @Attribute
    def position(self):
        """Return ``self.to_position``.

        :rtype: parapy.geom.Position
        """
        return self.to_position


class _Translated(_TransformBase):
    """mixin for all Translated classes"""

    #: A vector representing the displacement.
    #: :type: parapy.geom.Vector
    displacement = Input()

    @Attribute
    def position(self):
        """The position of the Translated shape.

        :rtype: parapy.geom.Position
        """
        s = self.built_from
        if hasattr(type(s), "position"):
            pos = s.position
            return pos + self.displacement
        else:
            # default to ancestor position or XOY
            return self.get_ancestor_value("position", XOY)

    @Attribute
    def _trsf(self):
        """OCC transformation object.

        :rtype: OCC.gp.gp_Trsf
        """
        vec = self.displacement
        trsf = gp_Trsf()
        trsf.SetTranslation(vec.gp_Vec)
        return trsf

    @Attribute
    def _info(self):
        """Contains some _transformation info for CATIA API.

        :rtype: dict[str, str | parapy.geom.Vector]
        """
        return {"operation": "translated",
                "vector": self.displacement}


class _Rotated(_TransformBase):
    """Mixin for all Rotated classes"""

    #: reference point for rotating.
    #: :type: parapy.geom.Point
    rotation_point = Input()

    #: rotation vector
    #: :type: parapy.geom.Vector
    vector = Input()

    #: rotation angle in radians
    #: :type: float
    angle = Input()

    @Attribute
    def position(self):
        """Rotated ``built_from.position``. If ``built_from`` has no position,
        defaults to ancestor ``position`` or ``XOY``.

        :rtype: parapy.geom.Position
        """
        s = self.built_from
        if hasattr(type(s), "position"):
            pos = s.position
            pt, v, a = self.rotation_point, self.vector, self.angle
            return rotate(pos, v, a, ref=pt)
        else:
            # default to ancestor position or XOY
            return self.get_ancestor_value("position", XOY)

    @Attribute
    def _trsf(self):
        """OCC transformation object.

        :rtype: OCC.gp.gp_Trsf
        """
        pt = self.rotation_point
        normal = self.vector
        trsf = gp_Trsf()
        ax1 = gp_Ax1(gp_Pnt(*pt), gp_Dir(*normal))
        trsf.SetRotation(ax1, self.angle)
        return trsf

    @Attribute
    def _rotation_axis(self):
        """The rotation axis.

        :rtype: parapy.geom.Axis
        """
        return Axis(self.rotation_point, self.vector)

    @Attribute
    def _info(self):
        """Contains some _transformation info for CATIA API.

        :rtype: dict[str, str | parapy.geom.Axis | float]
        """
        return {"operation": "rotated",
                "axis": self._rotation_axis,
                "angle": self.angle}


class _Scaled(_TransformBase):
    """mixin for all Scaled classes"""

    #: reference point for scaling.
    #: :type: parapy.geom.Point
    reference_point = Input()

    #: Scaling factor > 0. For non-uniform scaling, provide tuple of three
    #: floats.
    #: :type: float | tuple[float, float, float]
    factor = Input()

    @Attribute
    def non_uniform(self):
        """Non-uniform scaling?

        :rtype: bool
        """
        factor = self.factor
        if hasattr(type(factor), "__iter__"):
            fx, fy, fz = self.factor
            if fx == fy == fz:
                return False
            else:
                return True
        else:
            return False

    @Attribute
    def position(self):
        """The scaled ``built_from.position`` with respect to
        ``reference_point``. If ``built_from`` has no position, defaults to
        ancestor ``position`` or ``XOY``.

        :rtype: parapy.geom.Position
        """
        s = self.built_from
        if hasattr(type(s), "position"):
            # scale position to reference point
            pt, f = self.reference_point, self.factor
            if hasattr(type(f), "__iter__"):
                fx, fy, fz = f
            else:
                fx = fy = fz = f
            pos = s.position
            vx, vy, vz = pos - pt  # vector
            vx *= (fx - 1)
            vy *= (fy - 1)
            vz *= (fz - 1)
            return pos + Vector(vx, vy, vz)
        else:
            # default to ancestor position or XOY
            return self.get_ancestor_value("position", XOY)

    @Attribute
    def _info(self):
        """Contains some _transformation info for CATIA API.

        :rtype: dict[str, str | parapy.geom.Axis | float]
        """
        return {"operation": "scaled",
                "reference_point": self.reference_point,
                "factor": self.factor}

    @Attribute
    def _trsf(self):
        """OCC transformation object.

        :rtype: OCC.gp.gp_GTrsf | OCC.gp.gp_Trsf
        """
        f = self.factor
        pt = self.reference_point
        if self.non_uniform:
            trsf = gp_GTrsf()
            x, y, z = pt
            fx, fy, fz = f
            trsf.SetValue(1, 1, fx)
            trsf.SetValue(2, 2, fy)
            trsf.SetValue(3, 3, fz)
            trsf.SetValue(1, 4, -x * (fx - 1))
            trsf.SetValue(2, 4, -y * (fy - 1))
            trsf.SetValue(3, 4, -z * (fz - 1))
        else:
            if hasattr(type(f), "__iter__"):  # e.g. (2.0, 2.0, 2.0)
                f, _, _ = f
            trsf = gp_Trsf()
            trsf.SetScale(gp_Pnt(*pt), f)
        return trsf


class _Mirrored(_TransformBase):
    """Mixin for all Mirrored classes"""

    #: reference point for mirror. Without vector1/vector2 this will be a
    #: point mirror
    #: :type: parapy.geom.Point | parapy.geom.Position
    reference_point = Input()

    #: set this for line mirror
    #: :type: None | parapy.geom.Vector
    vector1 = Input(None)

    #: set this and :attr:`vector1` for plane mirror
    #: :type: None | parapy.geom.Vector
    vector2 = Input(None)

    @Attribute
    def position(self):
        """Mirrored ``built_from.position``. If ``built_from`` has no
        position, defaults to ancestor ``position`` or ``XOY``.

        :rtype: parapy.geom.Position
        """
        s = self.built_from
        if hasattr(type(s), "position"):
            pos = s.position
            pt, v1, v2 = self.reference_point, self.vector1, self.vector2
            return pos.reflect(pt, v1, v2)
        else:
            # default to ancestor position or XOY
            return self.get_ancestor_value("position", XOY)

    @Attribute
    def _trsf(self):
        """OCC transformation object.

        :rtype: OCC.gp.gp_Trsf
        """
        pt, v1, v2 = self.reference_point, self.vector1, self.vector2
        trsf = gp_Trsf()
        if v1:
            if v2:
                # plane mirror
                pos = Position(pt, Orientation(v1, v2))
                trsf.SetMirror(pos.gp_Ax2)
            else:
                # line mirror
                ax = Axis(pt, v1)
                trsf.SetMirror(ax.gp_Ax1)
        else:
            # point mirror
            trsf.SetMirror(gp_Pnt(*pt))
        return trsf

    @Attribute
    def _info(self):
        """Contains some _transformation info for CATIA API.

        :rtype: dict[str, str | parapy.geom.Point | parapy.geom.Vector]
        """
        return {"operation": "mirrored",
                "reference_point": self.reference_point,
                "vector1": self.vector1,
                "vector2": self.vector2}


class _TransformedCurve(Curve):
    """Base class for all concrete curve transformations"""

    _obj_in_key = "curve_in"

    #: curve to transform
    #: :type: parapy.geom.Curve
    curve_in = Input()

    @Attribute(private=True)
    def Handle_Geom_Curve(self):
        """Handle of :attr:`curve_in`.

        :rtype: OCC.Geom.Handle_Geom_Curve
        :raises ValueError: if :attr:`curve_in` is not a valid Curve instance.
        """
        crv = self.curve_in
        if not hasattr(type(crv), "_Geom_Curve"):
            msg = "Shape {:} is not a valid Curve instance."
            raise ValueError(msg.format(repr(crv)))
        handle = crv.Handle_Geom_Curve.Transformed(self._trsf)
        return Handle_Geom_Curve_DownCast(handle)


class _TransformedSurface(Surface):
    """Base class for all concrete surface transformations"""

    _obj_in_key = "surface_in"

    #: surface to transform
    #: :type: parapy.geom.Surface
    surface_in = Input()

    @Attribute(private=True)
    def Handle_Geom_Surface(self):
        """Handle of :attr:`surface_in`.

        :rtype: OCC.Geom.Handle_Geom_Surface
        :raises ValueError: if :attr:`surface_in` is not a valid Surface
            instance.
        """
        srf = self.surface_in
        if not hasattr(type(srf), "_Geom_Surface"):
            msg = "Shape {:} is not a valid Surface instance."
            raise ValueError(msg.format(repr(srf)))
        handle = srf.Handle_Geom_Surface.Transformed(self._trsf)
        return Handle_Geom_Surface_DownCast(handle)


class _TransformedShape(Shape):
    """Base class for all concrete surface transformations"""

    _obj_in_key = "shape_in"

    #: shape to transform
    #: :type: parapy.geom.BRep
    shape_in = Input()

    @Attribute
    def TOPOLEVEL(self):
        """:rtype: int"""
        return self.shape_in.TOPOLEVEL

    @Attribute
    def TOPODIM(self):
        """Dimension of this shape.

        :rtype: int
        """
        return self.shape_in.TOPODIM

    @Attribute
    def builder(self):
        """The builder of this shape.

        :rtype: OCC.BRepBuilderAPI.BRepBuilderAPI_Transform
        """
        shp = self.shape_in
        # caution: hasattr on type to prevent evaluation.
        if not hasattr(type(shp), "TopoDS_Shape"):
            msg = "Shape {:} is not a valid BRep instance."
            raise ValueError(msg.format(repr(shp)))
        return BRepBuilderAPI_Transform(shp.TopoDS_Shape, self._trsf, True)

    @Attribute
    def TopoDS_Shape(self):
        """The underlying OCC shape.

        :rtype: OCC.TopoDS.TopoDS_Shape
        """
        return self.builder.Shape()

    @Attribute
    def _clone(self):
        """The input shape from :attr:`shape_in`.

        :rtype: parapy.geom.BRep
        """
        return self.shape_in

    @Attribute
    def _owner(self):
        """My topological owner. If None, I'm the root object of
        this topology.

        :rtype: parapy.geom.BRep | None
        """
        return self.shape_in._owner


# =============================================================================
# Concrete curve classes
# =============================================================================
class TransformedCurve(_Transformed, _TransformedCurve):
    """Transforms an existing curve. Note that this transformed curve object
    is a only a general curve, hence it does not answer any curve-specific
    messages like radius, control_points, etc. If you want the specific
    curve-type, check the :attr:`downcast` attribute, which returns a
    :class:`parapy.geom.Circle`, :class:`parapy.geom.BSplineCurve`, etc.

    Usage:

    >>> from parapy.geom import BSplineCurve, Point, OXY, ZOX, TransformedCurve
    >>> curve = BSplineCurve([Point(1, 0, 0), Point(2, 1, 0), Point(3, 0, 0)])
    >>> obj = TransformedCurve(curve_in=curve, from_position=OXY,
    ... to_position=ZOX(z=2))
    >>> # The box orientation is changed,leading to a local z-direction
    >>> # that is different than the global z-direction.
    >>> obj  # doctest: +ELLIPSIS
    <TransformedCurve root at 0x...>
    >>> obj.downcast  # doctest: +ELLIPSIS
    <BSplineCurve_ root at 0x...>
    """

    __icon__ = os.path.join(ICN_DIR, 'transform.png')
    __initargs__ = ["curve_in", "from_position", "to_position"]


class TranslatedCurve(_Translated, _TransformedCurve):
    """Translates a curve_in. Returns only a general Curve object, use
    :attr:`downcast` slot for specific curve type.

    Usage:

    >>> from parapy.geom import BSplineCurve, Point, Vector, TranslatedCurve
    >>> curve = BSplineCurve([Point(1, 0, 0), Point(2, 1, 0), Point(3, 0, 0)])
    >>> obj = TranslatedCurve(curve_in=curve, displacement=Vector(0, 0, 1))
    >>> obj  # doctest: +ELLIPSIS
    <TranslatedCurve root at 0x...>
    >>> obj.downcast  # doctest: +ELLIPSIS
    <BSplineCurve_ root at 0x...>
    """

    __icon__ = os.path.join(ICN_DIR, 'translate.png')
    __initargs__ = ["curve_in", "displacement"]


class RotatedCurve(_Rotated, _TransformedCurve):
    """Rotates a curve_in. Returns only a general Curve object, use
    :attr:`downcast` slot for specific curve type.

    Usage:

    >>> from parapy.geom import RotatedCurve, BSplineCurve, Point, Vector
    >>> from math import radians
    >>> crv = BSplineCurve([Point(0, 0, 0), Point(1, 1, 0), Point(2, 0, 0)])
    >>> obj = RotatedCurve(curve_in=crv, rotation_point=Point(0, 0, 0),
    ...                    vector=Vector(0, 0, 1), angle=radians(20))
    >>> obj  # doctest: +ELLIPSIS
    <RotatedCurve root at 0x...>
    >>> obj.downcast  # doctest: +ELLIPSIS
    <BSplineCurve_ root at 0x...>
    """

    __icon__ = os.path.join(ICN_DIR, 'rotate.png')
    __initargs__ = ["curve_in", "rotation_point", "vector", "angle"]


class ScaledCurve(_Scaled, _TransformedCurve):
    """Uniformly scales a :attr:`curve_in`. Returns only a general Curve
    object, use :attr:`downcast` slot for specific curve type.

    Usage:

    >>> from parapy.geom import BSplineCurve, Point, ScaledCurve
    >>> crv = BSplineCurve([Point(0, 0, 0), Point(1, 1, 0), Point(2, 0, 0)])
    >>> obj = ScaledCurve(curve_in=crv,
    ...                   reference_point=crv.start,
    ...                   factor=2)
    >>> obj  # doctest: +ELLIPSIS
    <ScaledCurve root at 0x...>
    >>> obj.downcast  # doctest: +ELLIPSIS
    <BSplineCurve_ root at 0x...>
    >>> # non-uniform scaling
    >>> obj = ScaledCurve(curve_in=crv,
    ...                   reference_point=crv.start,
    ...                   factor=(3, 2, 1))
    >>> obj  # doctest: +ELLIPSIS
    <ScaledCurve root at 0x...>
    >>> obj.downcast  # doctest: +ELLIPSIS
    <TrimmedCurve_ root at 0x...>
    """

    __icon__ = os.path.join(ICN_DIR, 'scale.png')
    __initargs__ = ["curve_in", "reference_point", "factor"]

    @Attribute(private=True)
    def Handle_Geom_Curve(self):
        """Handle of :attr:`curve_in`.

        :rtype: OCC.Geom.Handle_Geom_Curve
        """
        crv = self.curve_in
        if not hasattr(type(crv), "_Geom_Curve"):
            msg = "Shape {:} is not a valid Curve instance."
            raise ValueError(msg.format(repr(crv)))
        if self.non_uniform:
            topods_shape = crv.TopoDS_Shape
            builder = BRepBuilderAPI_GTransform(topods_shape, self._trsf, True)
            topods_shape = builder.Shape()
            topods_edge = downcast_shape(topods_shape, TopAbs_EDGE)
            tr_crv, u1, u2 = BRep_Tool_Curve(topods_edge)
            if u1 != tr_crv.FirstParameter() or u2 != tr_crv.LastParameter():
                tr_crv = Geom_TrimmedCurve(tr_crv, u1, u2).handle
            return tr_crv
        else:
            return super(ScaledCurve, self).Handle_Geom_Curve


class MirroredCurve(_Mirrored, _TransformedCurve):
    """Mirrors a curve, :attr:`curve_in` in three ways:
    point mirror, requiring :attr:`reference_point`
    line mirror, requiring :attr:`reference_point` and :attr:`vector1`
    plane mirror, requiring :attr:`reference_point`, :attr:`vector1` and
    :attr:`vector2`.

    Usage:

    >>> from parapy.geom import MirroredCurve, FittedCurve, Point, Vector
    >>> pts = [Point(0, 0, 0), Point(1, 1, 0), Point(2, 0, 0)]
    >>> crv1 = FittedCurve(pts)
    >>> refpnt = Point(0, 0, 1)
    >>> # point mirror
    >>> crv2 = MirroredCurve(curve_in=crv1, reference_point=refpnt)
    >>> # Line mirror
    >>> crv3 = MirroredCurve(curve_in=crv1, reference_point=refpnt,
    ...                     vector1=Vector(1, 0, 0))
    >>> # plane mirror
    >>> crv4 = MirroredCurve(curve_in=crv1, reference_point=refpnt,
    ...                     vector1=Vector(0, 1, 0),
    ...                     vector2=Vector(0, 0, 1))
    """

    __icon__ = os.path.join(ICN_DIR, 'mirror.png')
    __initargs__ = ["curve_in", "reference_point", "vector1", "vector2"]


# =============================================================================
# Concrete surface classes
# =============================================================================
class TransformedSurface(_Transformed, _TransformedSurface):
    """Transforms an existing surface. Returns only a general Surface object,
    use :attr:`downcast` slot for specific surface type.

    Usage:

    >>> from parapy.geom import (TransformedSurface, RectangularSurface, ZOX,
    ... OXY)
    >>> srf1 = RectangularSurface(1, 1)
    >>> srf2 = TransformedSurface(surface_in=srf1, from_position=OXY,
    ...                         to_position=ZOX(z=2))
    """

    __icon__ = os.path.join(ICN_DIR, 'transform.png')
    __initargs__ = ["surface_in", "from_position", "to_position"]


class TranslatedSurface(_Translated, _TransformedSurface):
    """Translates a :attr:`surface_in`. Returns only a general Surface object,
    use :attr:`downcast` slot for specific surface type.

    Usage:

    >>> from parapy.geom import TranslatedSurface, RectangularSurface, Vector
    >>> srf1 = RectangularSurface(1, 1)
    >>> srf2 = TranslatedSurface(surface_in=srf1, displacement=Vector(0, 0, 1))
    """

    __icon__ = os.path.join(ICN_DIR, 'translate.png')
    __initargs__ = ["surface_in", "displacement"]


class RotatedSurface(_Rotated, _TransformedSurface):
    """Rotates a :attr:`surface_in`. Returns only a general Surface object,
    use :attr:`downcast` slot for specific surface type.

    Usage:

    >>> from parapy.geom import (Point, Vector, RotatedSurface,
    ...                          RectangularSurface)
    >>> from math import radians
    >>> srf = RectangularSurface(1, 1)
    >>> obj = RotatedSurface(surface_in=srf, rotation_point=Point(0, 0, 0),
    ...                      vector=Vector(0, 1, 0), angle=radians(20))
    """

    __icon__ = os.path.join(ICN_DIR, 'rotate.png')
    __initargs__ = ["surface_in", "rotation_point", "vector", "angle"]


class ScaledSurface(_Scaled, _TransformedSurface):
    """Uniformly scales a :attr:`surface_in`. Returns only a general Surface
    object, use :attr:`downcast` slot for specific surface type.

    TODO: non-uniform scaling. For devlopers, use GTransform gp_GTrsf in Topo
    domain and convert back.

    Usage:

    >>> from parapy.geom import Point, RectangularSurface, ScaledSurface
    >>> srf = RectangularSurface(1, 1)
    >>> obj = ScaledSurface(surface_in=srf,
    ...                     reference_point=Point(0,0,0),
    ...                     factor=2)
    >>> # non-uniform scaling
    >>> obj = ScaledSurface(surface_in=srf,
    ...                     reference_point=Point(0,0,0),
    ...                     factor=(3, 2, 1))
    """

    __icon__ = os.path.join(ICN_DIR, 'scale.png')
    __initargs__ = ["surface_in", "reference_point", "factor"]

    @Attribute(private=True)
    def Handle_Geom_Surface(self):
        srf = self.surface_in
        if not hasattr(type(srf), "_Geom_Surface"):
            msg = "Shape {:} is not a valid Surface instance."
            raise ValueError(msg.format(repr(srf)))
        if self.non_uniform:
            topods_shape = srf.TopoDS_Shape
            builder = BRepBuilderAPI_GTransform(topods_shape, self._trsf, True)
            topods_shape = builder.Shape()
            topods_face = downcast_shape(topods_shape, TopAbs_FACE)
            handle_geom_surface = BRep_Tool_Surface(topods_face)
            return handle_geom_surface
        else:
            return super(ScaledSurface, self).Handle_Geom_Surface


class MirroredSurface(_Mirrored, _TransformedSurface):
    """Mirrors a surface, :attr:`surface_in` in three ways:
    point mirror, requiring :attr:`reference_point`
    line mirror, requiring :attr:`reference_point` and :attr:`vector1`
    plane mirror, requiring :attr:`reference_point`, :attr:`vector1` and
    :attr:`vector2`.

    Usage:

    >>> from parapy.geom import MirroredSurface, FittedSurface, Point, Vector
    >>> pts = [[Point(0, 0, 0), Point(1, 1, 0), Point(2, 0, 0)],
    ...        [Point(0, 0, 1), Point(1, 1, 1), Point(2, 0, 1)]]
    >>> srf = FittedSurface(pts)
    >>> refpnt = Point(0, 0, 1)
    >>> # point mirror
    >>> obj1 = MirroredSurface(surface_in=srf, reference_point=refpnt)
    >>> # Line mirror
    >>> obj2 = MirroredSurface(surface_in=srf, reference_point=refpnt,
    ...                        vector1=Vector(1, 0, 0))
    >>> # plane mirror
    >>> obj3 = MirroredSurface(surface_in=srf, reference_point=refpnt,
    ...                        vector1=Vector(0, 1, 0),
    ...                        vector2=Vector(0, 0, 1))
    """

    __icon__ = os.path.join(ICN_DIR, 'mirror.png')
    __initargs__ = ["surface_in", "reference_point", "vector1", "vector2"]


# =============================================================================
# Concrete shape classes
# =============================================================================
class TransformedShape(_Transformed, _TransformedShape):
    """Transforms an existing shape. Returns only a general Shape object, use
    :attr:`downcast` slot for specific shape type.

    Usage:

    >>> from parapy.geom import Box, OXY, ZOX
    >>> shape = Box(1, 1, 1)
    >>> obj = TransformedShape(shape_in=shape, from_position=OXY,
    ... to_position=ZOX(z=2))
    >>> # The box orientation is changed,leading to a local z-direction
    >>> # that is different than the global z-direction.
    """

    __icon__ = os.path.join(ICN_DIR, 'transform.png')
    __initargs__ = ["shape_in", "from_position", "to_position"]


class TranslatedShape(_Translated, _TransformedShape):
    """Translates a shape, :attr:`shape_in`, by a :attr:`displacement` and
    returns a general Shape object. Used :attr:`downcast` slot for specific
    shape type.

    Usage:

    >>> from parapy.geom import Box, Vector
    >>> shape = Box(1, 1, 1)
    >>> obj = TranslatedShape(shape_in=shape, displacement=Vector(0, 0, 1))
    """

    __icon__ = os.path.join(ICN_DIR, 'translate.png')
    __initargs__ = ["shape_in", "displacement"]


class RotatedShape(_Rotated, _TransformedShape):
    """Rotates a shape, :attr:`shape_in`, around a point,
    :attr:`rotation_point`. Returns only a general
    Shape object. Use :attr:`downcast` slot for specific shape type.

    Usage:

    >>> from parapy.geom import Point, Vector, Box, RotatedShape
    >>> from math import radians
    >>> box = Box(1, 1, 1)
    >>> obj = RotatedShape(shape_in=box, rotation_point=Point(0, 0, 0),
    ...                    vector=Vector(0, 0, 1), angle=radians(30))
    """

    __icon__ = os.path.join(ICN_DIR, 'rotate.png')
    __initargs__ = ["shape_in", "rotation_point", "vector", "angle"]


# TODO: non-uniform scaling. For developers, use GTransform gp_GTrsf in
# Topo domain and convert back.
class ScaledShape(_Scaled, _TransformedShape):
    """Uniformly scales a shape_in. Returns only a general Shape object,
    get downcast slot for specific shape type. If factor is a single number
    (> 0), uniform scaling applies. If factor is an interable of tree
    numbers, non-uniform scaling will be performed, viz. factor = [fx, fy,
    fz]. At the moment, non-uniform scaling doesn't seem to respect the
    reference_point, needs further investigation.

    Usage:

    >>> from parapy.geom import Box, ScaledShape, Point
    >>> box = Box(1, 1, 1, centered=True)
    >>> obj1 = ScaledShape(shape_in=box, reference_point=Point(0, 0, 0),
    ...                    factor=2)
    >>> # let's now do non-uniform scaling
    >>> obj2 = ScaledShape(shape_in=box, reference_point=Point(0, 0, 0),
    ...                    factor=[2, 4, 0.5])
    """

    __icon__ = os.path.join(ICN_DIR, 'scale.png')
    __initargs__ = ["shape_in", "reference_point", "factor"]

    @Attribute
    def builder(self):
        """The builder of this shape"""
        topods_shape = self.built_from.TopoDS_Shape
        if self.non_uniform:
            return BRepBuilderAPI_GTransform(topods_shape, self._trsf, True)
        else:
            return BRepBuilderAPI_Transform(topods_shape, self._trsf, True)


class MirroredShape(_Mirrored, _TransformedShape):
    """Mirrors a shape, :attr:`shape_in` in three ways:
    point mirror, requiring :attr:`reference_point`
    line mirror, requiring :attr:`reference_point` and :attr:`vector1`
    plane mirror, requiring :attr:`reference_point`, :attr:`vector1` and
    :attr:`vector2`.

    Usage:

    >>> from parapy.geom import MirroredShape, FittedCurve, Point, Vector
    >>> pts = [Point(0, 0, 0), Point(1, 1, 0), Point(2, 0, 0)]
    >>> crv = FittedCurve(pts)
    >>> refpnt = Point(0, 0, 1)
    >>> # point mirror
    >>> obj1 = MirroredShape(shape_in=crv, reference_point=refpnt)
    >>> # Line mirror
    >>> obj2 = MirroredShape(shape_in=crv, reference_point=refpnt,
    ...                      vector1=Vector(1, 0, 0))
    >>> # plane mirror
    >>> obj3 = MirroredShape(shape_in=crv, reference_point=refpnt,
    ...                      vector1=Vector(0, 1, 0),
    ...                      vector2=Vector(0, 0, 1))
    """

    __icon__ = os.path.join(ICN_DIR, 'mirror.png')
    __initargs__ = ["shape_in", "reference_point", "vector1", "vector2"]


class DelegatedShape(Shape):
    # TODO (TBD): Description of this abstract class. Author: FT.

    #: Basis shape for :attr:`shape` part.
    #: :type: parapy.geom.Curve | parapy.geom.Surface | parapy.geom.BRep
    built_from = Input()

    @Attribute
    def shapetype(self):
        """Class representing the type of this shape.

        :rtype: parapy.core.meta.basetype
        """
        s = self.built_from
        if isinstance(s, BRep):
            return s._new_shape_type
        elif isinstance(s, Curve):
            return s._new_curve_type
        elif isinstance(s, Surface):
            return s._new_surface_type
        else:
            raise RuntimeError("not expected")

    @Attribute
    def _Handle_Geom_Curve(self):
        """:rtype: OCC.Geom.Handle_Geom_Curve"""
        raise NotImplementedError()

    @Attribute
    def _Handle_Geom_Surface(self):
        """:rtype: OCC.Geom.Handle_Geom_Surface"""
        raise NotImplementedError()

    @Attribute
    def TopoDS_Shape(self):
        """:rtype: OCC.TopoDS.TopoDS_Shape"""
        raise NotImplementedError()

    @Part
    def shape(self):
        """:rtype: parapy.core.meta.basetype"""
        return DynamicType(
            type=self.shapetype,
            Handle_Geom_Curve=self._Handle_Geom_Curve,
            Handle_Geom_Surface=self._Handle_Geom_Surface,
            TopoDS_Shape=self.TopoDS_Shape)

    @property
    def TOPODIM(self):
        """Dimension of this shape.

        :rtype: int
        """
        return self.shape.TOPODIM

    @property
    def TOPOLEVEL(self):
        """Topology type: 7: Vertex, 6: Edge, 5: Wire, 4: Face, 3: Shell,
        2: Solid, 1: CompSolid, 0: Compound.

        :rtype: int
        """
        return self.shape.TOPOLEVEL


class Clone(DelegatedShape):
    """Clone a shape :attr:`built_from`. Access from :attr:`shape`."""

    __icon__ = os.path.join(ICN_DIR, 'clone.png')
    __initargs__ = ["built_from"]

    #: Shape to be cloned.
    #: :type: parapy.geom.Curve | parapy.geom.Surface | parapy.geom.BRep
    built_from = Input()

    @Attribute
    def _Handle_Geom_Curve(self):
        """:rtype: OCC.Geom.Handle_Geom_Curve"""
        return self.built_from.Handle_Geom_Curve

    @Attribute
    def _Handle_Geom_Surface(self):
        """:rtype: OCC.Geom.Handle_Geom_Surface"""
        return self.built_from.Handle_Geom_Surface

    @Attribute
    def TopoDS_Shape(self):
        """:rtype: OCC.TopoDS.TopoDS_Shape"""
        return self.built_from.TopoDS_Shape


class BaseTransformation(DelegatedShape):
    """Abstract base class for transformations.

    One at least had to implement :attr:`_gp_Trsf`.
    """

    @Attribute
    def _gp_Trsf(self):
        """The OCC transformation object.

        :rtype: OCC.gp.gp_Trsf
        """
        raise NotImplementedError()

    @Attribute
    def _Handle_Geom_Curve(self):
        """:rtype: OCC.Geom.Handle_Geom_Curve"""
        gp_trsf = self._gp_Trsf
        built_from = self.built_from
        curve = built_from.Handle_Geom_Curve
        handle = curve.Transformed(gp_trsf)
        handle = downcast_handle_geom_curve(handle)
        return handle

    @Attribute
    def _Handle_Geom_Surface(self):
        """:rtype: OCC.Geom.Handle_Geom_Surface"""
        gp_trsf = self._gp_Trsf
        built_from = self.built_from
        surface = built_from.Handle_Geom_Surface
        handle = surface.Transformed(gp_trsf)
        handle = downcast_handle_geom_surface(handle)
        return handle

    @Attribute
    def builder(self):
        """Builder object fro this transformation.

        :rtype: OCC.BRepBuilderAPI.BRepBuilderAPI_Transform
        """
        gp_trsf = self._gp_Trsf
        built_from = self.built_from
        shape = built_from.TopoDS_Shape
        return BRepBuilderAPI_Transform(shape, gp_trsf, True)

    @Attribute
    def TopoDS_Shape(self):
        """The transformed shape.

        :rtype: OCC.TopoDS.TopoDS_Shape
        """
        return self.builder.Shape()

    def modified(self, shape):
        """Retrieve modified shape from copied ``shape``, if present.

        :param parapy.geom.BRep|parapy.geom.Curve|parapy.geom.Surface shape:
            shape to check if it is modified in this transformation.
        :raises RuntimeError: If the done transformation was purely
            geometrical.
        """
        result = self.shape
        if hasattr(type(result), "_TopoDS2Shape"):
            topods_shape = shape.TopoDS_Shape
            topods_shape = self.builder.ModifiedShape(topods_shape)
            return result._TopoDS2Shape(topods_shape)
        else:
            raise RuntimeError("Transformation was purely geometrical.")


class Transformation(BaseTransformation):
    """Transform a shape :attr:`built_from` from one position,
    :attr:`from_position`, to another position, :attr:`to_position`. Access
    from :attr:`shape`.

    Usage:

    >>> from parapy.geom import Box, OXY
    >>> box = Box(1, 2, 3)
    >>> # translate 1 in global x-direction.
    >>> obj = Transformation(box, OXY, OXY.rotate90('z'))
    >>> obj.shape  # doctest: +ELLIPSIS
    <Solid_ ...>
    """

    __icon__ = os.path.join(ICN_DIR, 'transform.png')
    __initargs__ = ["built_from", "from_position", "to_position"]

    #: Shape to transform. Can be a curve, surface or BRep.
    #: :type: parapy.geom.Curve | parapy.geom.Surface | parapy.geom.BRep
    built_from = Input()

    #: :type: parapy.geom.Position
    from_position = Input()

    #: :type: parapy.geom.Position
    to_position = Input()

    @Attribute
    def _gp_Trsf(self):
        """The OCC transformation object.

        :rtype: OCC.gp.gp_Trsf
        """
        pos1, pos2 = self.from_position, self.to_position
        FromSystem1 = gp_Ax3_from_position(pos1)
        ToSystem2 = gp_Ax3_from_position(pos2)
        trsf = gp_Trsf()
        trsf.SetTransformation(FromSystem1, ToSystem2)
        return trsf


class Translation(BaseTransformation):
    """Translate a shape :attr:`built_from` along a :attr:`vector`. Access
    from :attr:`shape`.

    Usage:

    >>> from parapy.geom import Box, Vector
    >>> box = Box(1, 2, 3)
    >>> # translate 1 in global x-direction.
    >>> obj = Translation(box, Vector(1, 0, 0))
    >>> obj.shape  # doctest: +ELLIPSIS
    <Solid_ ...>
    """

    __icon__ = os.path.join(ICN_DIR, 'translate.png')
    __initargs__ = ["built_from", "vector"]

    #: Shape to translate. Can be a curve, surface or BRep.
    #: :type: parapy.geom.Curve | parapy.geom.Surface | parapy.geom.BRep
    built_from = Input()

    #: Vector for translation.
    #: :type: parapy.geom.Vector
    vector = Input()

    @Attribute
    def _gp_Trsf(self):
        """The OCC transformation object.

        :rtype: OCC.gp.gp_Trsf
        """
        vector = self.vector
        vector = gp_Vec(*vector)
        trsf = gp_Trsf()
        trsf.SetTranslation(vector)
        return trsf


class Rotation(BaseTransformation):
    """Rotate a shape :attr:`built_from` by an :attr:`angle` (in radians) with
    respect to the reference :attr:`point` of the rotation axis. The
    direction of the rotation axis is passed by a :attr:`normal` vector.
    Access from :attr:`shape`.

    Usage:

    >>> from parapy.geom import Box, Vector
    >>> from math import pi
    >>> box = Box(1, 2, 3)
    >>> # quarter circle rotation around global z axis.
    >>> obj = Rotation(box, box.center, Vector(0, 0, 1), 0.5*pi)
    >>> obj.shape  # doctest: +ELLIPSIS
    <Solid_ ...>
    """

    __icon__ = os.path.join(ICN_DIR, 'rotate.png')
    __initargs__ = ["built_from", "point", "normal", "angle"]

    #: Shape to rotate.
    #: :type: parapy.geom.Curve | parapy.geom.Surface | parapy.geom.BRep
    built_from = Input()

    #: Reference point of rotation axis.
    #: :type: parapy.geom.Point
    point = Input()

    #: Direction of rotation axis
    #: :type: parapy.geom.Vector
    normal = Input()

    #: Angle of rotation (radians).
    #: :type: float
    angle = Input()

    @Attribute
    def _gp_Trsf(self):
        """The OCC transformation object.

        :rtype: OCC.gp.gp_Trsf
        """
        pt, normal, angle = self.point, self.normal, self.angle
        gp_ax1 = gp_Ax1(gp_Pnt(*pt), gp_Dir(*normal))
        trsf = gp_Trsf()
        trsf.SetRotation(gp_ax1, angle)
        return trsf


class Scaling(BaseTransformation):
    """Scale a shape :attr:`built_from` with respect to a :attr:`point`
    uniformly by passing a single number to :attr:`factor`. For non-uniform
    scaling, pass a sequence of three numbers, viz. factor = [fx, fy, fz].
    Access from :attr:`shape`.

    Usage:

    >>> from parapy.geom import Box
    >>> from parapy.geom.occ.transform import Scaling
    >>> box = Box(1, 2, 3)
    >>> # shrink box to 50% from location vertex.
    >>> obj1 = Scaling(built_from=box, point=box.location, factor=0.5)
    >>> obj1.shape  # doctest: +ELLIPSIS
    <Solid_ ...>
    >>> # scale box non-uniformly.
    >>> obj2 = Scaling(built_from=box, point=box.location, factor=[2, 4, 0.5])
    """

    __icon__ = os.path.join(ICN_DIR, 'rotate.png')
    __initargs__ = ["built_from", "point", "factor"]

    #: Shape to scale.
    #: :type: parapy.geom.Curve | parapy.geom.Surface | parapy.geom.BRep
    built_from = Input()

    #: Reference point for scaling
    #: :type: parapy.geom.Point
    point = Input()

    #: Either a single number for uniform scaling or a sequence of three
    #: numbers, viz. factor = [fx, fy, fz], for non-uniform scaling.
    #: :type: float | collections.Sequence[float, float, float]
    factor = Input()

    #: Optional orientation for non-uniform scaling.
    #: :type: parapy.geom.Orientation | None
    orientation = Input(None)

    @Attribute
    def non_uniform(self):
        """Is the scaling non-uniform?

        :rtype: bool
        """
        return hasattr(self.factor, "__iter__")

    @Attribute
    def _gp_Trsf(self):
        """The OCC transformation object.

        :rtype: OCC.gp.gp_Trsf
        """
        point = self.point
        gp_pnt = gp_Pnt(*point)
        trsf = gp_Trsf()
        if self.non_uniform:
            factor = 1.0
        else:
            factor = self.factor
        trsf.SetScale(gp_pnt, factor)
        return trsf

    @Attribute
    def _gp_GTrsf(self):
        """The OCC transformation object for non-uniform scaling.

        :rtype: OCC.gp.gp_GTrsf
        """
        # non-uniform scaling
        Sx, Sy, Sz = self.factor
        # override scaling factors with gp_GTrsf
        gtrsf = gp_GTrsf(self._gp_Trsf)
        gtrsf.SetValue(1, 1, Sx)
        gtrsf.SetValue(2, 2, Sy)
        gtrsf.SetValue(3, 3, Sz)
        return gtrsf

    @Attribute
    def shapetype(self):
        """Class that represents the type of this scaling its result.

        :rtype: parapy.core.meta.basetype
        """
        s = self.built_from
        if isinstance(s, Curve):
            return Edge_
        elif isinstance(s, Surface):
            return Face_
        else:
            return s._new_shape_type

    @Attribute
    def TopoDS_Shape(self):
        """Shape that is the result of this scaling operation.

        :rtype: OCC.TopoDS.TopoDS_Shape
        """
        built_from = self.built_from
        shape = built_from.TopoDS_Shape
        if self.non_uniform:
            orientation = self.orientation
            gp_gtrsf = self._gp_GTrsf
            if orientation is not None:
                raise NotImplementedError
                # point = self.point
                # not in principle direction, rotate back, scale, rotate forth
                # pos1 = Position(point, XY)
                # pos2 = Position(point, orientation)
            else:
                builder = BRepBuilderAPI_GTransform(shape, gp_gtrsf, True)
                return builder.Shape()
        else:
            gp_trsf = self._gp_Trsf
            builder = BRepBuilderAPI_Transform(shape, gp_trsf, True)
            return builder.Shape()


class ModifiedShape(DelegatedShape):
    """Rebuilds a shape :attr:`built_from` by making pre-defined
    substitutions on some of its components. Sub-shapes can either be
    removed through the :attr:`remove` input, kept through the :attr:`keep`
    input or replaced with new sub-shapes using the :attr:`replace`.

    Usage:

    >>> from parapy.geom import ModifiedShape, SplitSurface, Plane, Cylinder
    >>> cyl = Cylinder(1, 1, centered=True)
    >>> faces = (cyl.top_face, cyl.bottom_face)
    >>> # leave a shape with 1 face.
    >>> obj1 = ModifiedShape(cyl, remove=faces)
    >>> len(obj1.faces)
    1
    >>> # leave a shape with 2 faces.
    >>> obj2 = ModifiedShape(cyl, keep=faces)
    >>> len(obj2.faces)
    2
    >>> plane = Plane() #defaults to normal in z-direction
    >>> split_faces = SplitSurface(cyl.lateral_face, plane)
    >>> # leave a shape with 4 faces.
    >>> obj3 = ModifiedShape(cyl, replace=[cyl.lateral_face, split_faces])
    >>> len(obj3.faces)
    4

    .. caution:: the type of :attr:`shape`, may not be appropriate. For
        example, removing a face from a solid, might turn it into an open
        shell. However, the returned :attr:`shape` object will in fact still
        be a Solid. Access ``shape.shells[0]`` for a true shell in that case.
    """

    __initargs__ = ["built_from"]
    __icon__ = os.path.join(ICN_DIR, 'replace.png')

    #: Substitutions will be applied to this shape.
    #: :type: parapy.geom.BRep
    built_from = Input()

    #: Sub-shape(s) from :attr:`built_from` that should be kept in the new
    #: shape. Either this or :attr:`remove`, not both. Note that all
    #: sub-shapes in this sequence should be of the same type.
    #: :type: collections.Sequence[parapy.geom.BRep] | parapy.geom.BRep | None
    keep = Input(None)

    #: Sub-shape(s) from :attr:`built_from` that should be removed from the new
    #: shape. Either this or :attr:`keep`, not both.
    #: :type: collections.Sequence[parapy.geom.BRep] | parapy.geom.BRep | None
    remove = Input(None)

    #: Request replacement of old sub-shape from ``built_from`` with a new
    #: sub-shape. Format: ``((old_shape, new_shape), (old_shape, new_shape))``.
    #: :type: collections.Sequence[(BRep, collections.Sequence[BRep])] | collections.Sequence[(BRep, BRep)] | (BRep, BRep) | None
    replace = Input(None)

    @Attribute
    def shapetype(self):
        """Class that represents the type of this scaling its result.

        :rtype: parapy.core.meta.basetype
        """
        return TOPO2CLS(self.TopoDS_Shape)

    @Attribute
    def _builder_and_TopoDS_Shape(self):
        """The shape that represents this modification and the builder that
        was used to construct this shape.

        :rtype: tuple[OCC.BRepTools.BRepTools_ReShape, OCC.TopoDS.TopoDS_Shape]
        """
        built_from = self.built_from.TopoDS_Shape
        rem = self.remove
        keep = self.keep
        rep = self.replace

        if keep and rem:
            msg = "specify either sub-shapes to keep or to remove, not both"
            raise RuntimeError(msg)

        builder = BRepTools_ReShape()

        if keep:
            keep = ensure_iterable(keep)
            topods_shapes = list(map(topods_shape_getter, keep))
            st = topods_shapes[0].ShapeType()
            if not all(obj.ShapeType() == st for obj in topods_shapes[1:]):
                msg = "not all sub-shapes inside keep are of the same type."
                raise RuntimeError(msg)
            set_ = set(topods_shapes)
            rem = [s for s in sub_shapes(built_from, st) if s not in set_]

        elif rem:
            rem = ensure_iterable(rem)
            rem = list(map(topods_shape_getter, rem))

        if rem:
            for topods_shape in rem:
                builder.Remove(topods_shape)

        if rep:
            if not hasattr(rep[0], "__iter__"):
                rep = [rep]
            for old_shape, new_shape in rep:
                if hasattr(new_shape, "__iter__"):
                    new_shape = Compound(new_shape)
                builder.Replace(old_shape.TopoDS_Shape,
                                new_shape.TopoDS_Shape)

        TopoDS_Shape = builder.Apply(built_from)
        # if built_from was solid (and compsolid), and user has given remove
        # value, we'll assume a shell result.
        if built_from.ShapeType() == 2 and rem:
            # it's a shell now
            shells = tuple(sub_shapes(TopoDS_Shape))
            if len(shells) == 1 and shells[0].ShapeType() == 3:
                # yes, indeed, 1 shell inside this solid
                TopoDS_Shape = shells[0]
            else:
                msg = "Expected to find a single (open) shell inside original"
                warnings.warn(msg)
        return builder, TopoDS_Shape

    @Attribute
    def builder(self):
        """The builder that constructed this shape.

        :rtype: OCC.BRepTools.BRepTools_ReShape
        """
        return self._builder_and_TopoDS_Shape[0]

    @Attribute
    def TopoDS_Shape(self):
        """The OCC BRep that represents the modified shape.

        :rtype: OCC.TopoDS.TopoDS_Shape
        """
        return self._builder_and_TopoDS_Shape[1]

    # TODO: move to BRepBuilder-derived classes.
    def modified(self, shape, failure='raise'):
        """Return a list of sub-shapes that are the modified version of
        original ``shape`` input. If nothing was modified, return an empty
        list (consider methods :meth:`partner`, :meth:`generated` or
        :meth:`is_deleted`).

        :param shape: original sub-shape before this operation.
        :type shape: parapy.geom.occ.brep.BRep
        :param str failure: either 'raise', 'warn' or 'ignore'
        :rtype: list[parapy.geom.BRep]
        """
        old_topods_shape = shape.TopoDS_Shape
        new_topods_shape = self.builder.Value(old_topods_shape)
        if new_topods_shape.IsNull():
            # was deleted
            return []
        elif new_topods_shape.IsPartner(old_topods_shape):
            # nothing happened
            return []
        elif new_topods_shape.ShapeType() == 0:
            # new shape is a compound
            old_st = old_topods_shape.ShapeType()
            # TODO (TBD): make function to expand a Compound into
            # /todo non-Compound shapes.
            new_shapes = SubShapeGenerator_(new_topods_shape, old_st)
            return self._TopoDS2Shapes(new_shapes, old_st, failure=failure)
        else:
            TopoDS2Shape = self._TopoDS2Shape
            try:
                return [TopoDS2Shape(new_topods_shape)]
            except KeyError:  # not found in result shape
                old_st = old_topods_shape.ShapeType()
                new_st = new_topods_shape.ShapeType()

                if (self.builder.IsRecorded(old_topods_shape) and
                        (new_st + 1 == old_st)):
                    # this should only happen when shells and wires are
                    # involved. Hard to think of an exception that will
                    # produce valid output.
                    assert new_st == TopAbs_SHELL or new_st == TopAbs_WIRE
                    # but the old shape was set for a modification, maybe its
                    # sub-shapes ended up in the replacement, but not the item
                    # registered for replacement
                    return [TopoDS2Shape(s) for s in sub_shapes(
                        new_topods_shape, downcast=True)]
                else:
                    raise

    # TODO: move to BRepBuilder-derived classes.
    def is_deleted(self, shape):
        """Is ``shape`` deleted in the modified shape?

        :type shape: parapy.geom.BRep
        :rtype: bool
        """
        topods_shape = shape.TopoDS_Shape
        new_topods_shape = self.builder.Value(topods_shape)
        return bool(new_topods_shape.IsNull())


class FixedShape(DelegatedShape):
    """Fix a shape :attr:`built_from`. Access from :attr:`shape`.

    Usage:

    >>> from parapy.geom import Box, FixedShape
    >>> a = Box(1, 2, 3)
    >>> b = FixedShape(a, min_tolerances=1.0e-7, max_tolerances=1.0e-7)
    >>> b.shape  # doctest: +ELLIPSIS
    <Solid_ root.shape at 0x...>
    """

    __icon__ = os.path.join(ICN_DIR, 'fix.png')
    __initargs__ = ("built_from", "min_tolerances", "max_tolerances")

    #: Shape to fix.
    #: :type: parapy.geom.BRep
    built_from = Input()

    #: Sets minimal allowed tolerance.
    #: :type: float | None
    min_tolerances = Input(None)

    #: Sets maximal allowed tolerance.
    #: :type: float | None
    max_tolerances = Input(None)

    #: Either "raise", "warn", "ignore". Defaults to "raise"
    #: :type: str
    failure = Input("raise")

    @Attribute
    def builder(self):
        """The builder object that constructed this :class:`FixedShape`.

        :rtype: OCC.ShapeFix.ShapeFix_Shape
        """
        S = self.built_from.TopoDS_Shape
        t1, t2 = self.min_tolerances, self.max_tolerances
        SF = ShapeFix_Shape(S)
        if t1 is not None:
            SF.SetMinTolerance(t1)
        if t2 is not None:
            SF.SetMaxTolerance(t2)
        SF.Perform()
        status = True  # TODO: use ShapeExtend_Status
        if not status:
            msg = "ShapeFix_Shape signalled a bad status."
            raise_conditionally(RuntimeError, msg, self.failure)
        return SF

    @Attribute
    def TopoDS_Shape(self):
        """The BRep representing the fixed shape.

        :rtype: OCC.TopoDS.TopoDS_Shape
        """
        return self.builder.Shape()

    @Attribute
    def tolerances_before(self):
        """The maximum tolerances found on faces, edges, vertices **before**
        fixing the shape (the tolerances on the shape in :attr:`built_from`).

        :rtype: tuple[float]
        """
        return get_max_tolerances(self.built_from.TopoDS_Shape)

    @Attribute
    def tolerances_after(self):
        """The maximum tolerances found on faces, edges, vertices **after**
        fixing the shape (the tolerances on the shape in :attr:`TopoDS_Shape`).

        :rtype: tuple[float]
        """
        return get_max_tolerances(self.TopoDS_Shape)


# def gp_Trsf_SetValues(trsf, arr):
#     for i, row in enumerate(arr, start=1):
#         for j, val in enumerate(arr, start=1):
#             trsf.SetValue(i, j, val)
#
#
def gp_Trsf_values(trsf):
    """The transformation matrix represented by ``trsf``.

    :type trsf: OCC.gp.gp_Trsf
    :rtype: list[list[float]]
    """
    return [[trsf.Value(i, j) for j in range(1, 5)] for i in range(1, 4)]


class ClonedSurface(Surface):
    """Can be used to make a new clone of an existing surface or wrap an
    OCC.Handle_Geom_Surface.

    Ways to use this class::

        ClonedSurface(other_surface, *args, **kwargs)
        ClonedSurface([other_surface, other_surfacer, ...], *args, **kwargs)
        ClonedSurface(built_from=other_surface, **kwargs)

    Where ``other_surface`` is one of:

    * parapy.geom.Surface
    * OCC.Geom.Handle_Geom_Surface

    Usage:

    >>> from parapy.geom import RectangularSurface, translate
    >>> srf = RectangularSurface(width=2., length=3.)
    >>> srf_clone = ClonedSurface(srf, position=translate(srf.position, x=4))
    >>> srf.position
    Position(Point(0, 0, 0))
    >>> srf_clone.position
    Position(Point(4, 0, 0))
    >>> srf2 = RectangularSurface(width=1., length=2.)
    >>> srf_clones = ClonedSurface([srf, srf2],
    ...                            position=translate(srf.position, x=4))
    >>> srf_clones  # doctest: +ELLIPSIS
    [<RectangularTrimmedSurface_ ...>, <RectangularTrimmedSurface_ ...>]
    >>> srf_clones[0].position
    Position(Point(4, 0, 0))

    """

    __initargs__ = ["built_from"]
    __newargs__ = ["built_from"]

    #: The object to clone.
    #: :type: parapy.geom.Surface
    built_from = Input()

    @classmethod
    def make(cls, built_from, *args, **kwargs):
        """deals with single objects"""
        if isinstance(built_from, Surface):
            class_ = built_from._new_surface_type
            h_geom_surface = built_from._new_handle()
            return class_(Handle_Geom_Surface=h_geom_surface, *args, **kwargs)
        elif handle_is_instance(built_from, Handle_Geom_Surface):
            h_geom_surface, class_ = Handle_Geom_Surface2ParaPy(built_from)
            return class_(Handle_Geom_Surface=h_geom_surface, *args, **kwargs)
        else:
            raise Exception("curve_in was not a valid Curve, Edge or "
                            "Handle_Geom_Curve.")

    def __new__(cls, built_from, *args, **kwargs):
        """tests for iterables"""
        if hasattr(built_from, "__iter__"):
            return [cls.make(obj, *args, **kwargs) for obj in built_from]
        else:
            return cls.make(built_from, *args, **kwargs)


def transform(position, from_position, to_position):
    """Transform ``position`` by applying the transformation
    from ``from_position`` to ``to_position`` as seen relative to the global
    coordinate system.

    :param parapy.geom.Position position: position to transform
    :param parapy.geom.Position from_position:
    :param parapy.geom.Position to_position:
    :rtype: parapy.geom.Position
    """
    # transformation expressed in the ``from_position`` basis
    trsf = get_transformation(from_position, to_position)
    return transform_position(position, from_position, trsf)


def get_basis_change_trsf(from_position, to_position):
    """Return a transformation :class:`~OCC.gp.gp_Trsf` object that expresses a
    change of basis ``from_position`` to ``to_position``.

    :param parapy.geom.Position from_position:
    :param parapy.geom.Position to_position:
    :rtype: OCC.gp.gp_Trsf
    """
    relative_trsf = gp_Trsf()
    relative_trsf.SetTransformation(from_position.gp_Ax3, to_position.gp_Ax3)
    return relative_trsf


def get_transformation(from_position, to_position):
    """Return a transformation :class:`~OCC.gp.gp_Trsf` object that transforms
    a ``from_position`` to a ``to_position``.

    :param parapy.geom.Position from_position:
    :param parapy.geom.Position to_position:
    :rtype: OCC.gp.gp_Trsf
    """
    relative_trsf = gp_Trsf()
    relative_trsf.SetDisplacement(from_position.gp_Ax3, to_position.gp_Ax3)
    return relative_trsf


def rebase_trsf(trsf, from_position, to_position):
    """Bring ``trsf``, which was defined relative to ``from_position``, to
    ``to_position``.

    :param OCC.gp.gp_Trsf trsf: the transformation
    :param parapy.geom.Position from_position: Position in which ``trsf``
        was defined.
    :param parapy.geom.Position to_position: The Position to which we should
        bring ``trsf``.
    :rtype: OCC.gp.gp_Trsf
    """
    # the matrix that changes from from_position basis to standard
    # coordinate system (XOY). All ParaPy positions live in XOY, so any
    # transformations need to be expressed relative to that.
    mat_c = get_basis_change_trsf(to_position, from_position)

    # transformation relative to to_position basis: Inverted(C) * A * C
    trsf_in_to_position_basis = mat_c.Inverted()
    trsf_in_to_position_basis.Multiply(trsf)
    trsf_in_to_position_basis.Multiply(mat_c)
    return trsf_in_to_position_basis


def transform_point(point:Tuple3D, trsf_reference, trsf):
    """Return a transformed ``point`` by applying ``trsf``,
    which was defined relative to ``trsf_reference``.

    :param parapy.geom.Position point: point to transform
    :param parapy.geom.Position trsf_reference: position to which ``trsf`` is
        relatively defined
    :type OCC.gp.gp_Trsf trsf: transformation which, relative to ``trsf_pos``
        should be applied to ``pos``.
    :rtype: parapy.geom.Position
    """
    #: :type: OCC.gp.gp_Ax3
    # set position on the same location as from_position to make sure
    # any rotation to it is done around `point`'s location
    from_ax3 = trsf_reference.gp_Ax3
    to_ax3 = from_ax3.Transformed(trsf)
    moved_pos_ = to_ax3.position

    # now we need to move it back to the correct position
    real_pos = moved_pos_.location + trsf_reference.vector_to(point)
    return moved_pos_.translate_to(real_pos)


def transform_position(position, trsf_reference, trsf):
    """Return a transformed ``position`` by applying ``trsf``,
    which was defined relative to ``trsf_reference``.

    :param parapy.geom.Position position: position to transform
    :param parapy.geom.Position trsf_reference: position to which ``trsf`` is
        relatively defined
    :type OCC.gp.gp_Trsf trsf: transformation which, relative to ``trsf_pos``
        should be applied to ``pos``.
    :rtype: parapy.geom.Position
    """
    #: :type: OCC.gp.gp_Ax3
    # set position on the same location as from_position to make sure
    # any rotation to it is done around Position's location
    position_moved_to_from = trsf_reference.rotate_to(position.orientation)
    from_ax3 = position_moved_to_from.gp_Ax3
    to_ax3 = from_ax3.Transformed(trsf)
    moved_pos_ = to_ax3.position

    # now we need to move it back to the correct position
    real_pos = moved_pos_.location + trsf_reference.vector_to(position)
    return moved_pos_.translate_to(real_pos)


if __name__ == '__main__':
    from parapy.gui import display
    from parapy.geom import OXY, Circle, Point, Box

    crv = Circle(1)
    clo = Clone(crv, color="red")
    trf = Transformation(crv, OXY, OXY.rotate90('y'))
    trl = Translation(crv, Vector(0, 0, 1), color="blue")
    rot = Rotation(crv, Point(1, 0, 0), Vector(0, 0, 1), 0.5*pi, color="green")
    scl = Scaling(crv, Point(1, 0, 0), (2.0, 1, 1), color="orange")
    display([crv, clo, trf, trl, rot, scl])

    # trsf = gp_Trsf()
    # trsf.SetRotation(gp_Ax1(), pi*0.5)
    # trsf.SetScale(gp_Pnt(0, 0, 0), 2.0)
    # for row in gp_Trsf_values(trsf):
    #    print row

    # trsf.SetValues(2.0, 0.0, 0.0, -0.0,
    #                0.0, 2.0, 0.0, -0.0,
    #                0.0, 0.0, 2.0, -0.0,
    #                0, 0)

    # print gp_Pnt(1, 1, 0).Transformed(trsf).Coord()

    box = Box(1, 2, 3)
    lst = (box.top_face, box.front_face, box.right_face)
    obj1 = ModifiedShape(box, remove=lst)
    print(obj1.partner(box.left_face))
    print(obj1.is_deleted(box.right_face))

    obj2 = FixedShape(box, min_tolerances=1.0e-7, max_tolerances=1.0e-7)

    display((obj1, obj2))
