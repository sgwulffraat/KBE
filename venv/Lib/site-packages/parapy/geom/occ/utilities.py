#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import io
import warnings
from functools import partial
from operator import attrgetter

from OCC.wrapper.BRep import BRep_Tool_Tolerance
from OCC.wrapper.TopAbs import (
    TopAbs_COMPOUND, TopAbs_EDGE, TopAbs_FACE, TopAbs_VERTEX, TopAbs_WIRE)
from OCC.wrapper.TopExp import TopExp__MapShapes, TopExp__MapShapesAndAncestors
from OCC.wrapper.TopTools import (
    TopTools_IndexedDataMapOfShapeListOfShape,
    TopTools_IndexedMapOfShape)
from OCC.wrapper.gp import gp_Ax3, gp_Dir, gp_Pnt
from OCC.utils.top import _map_all_shapes, downcast_shape, sub_shapes
from OCC.utils.utilities import (
    ANCESTOR_SUB_SHAPE_TYPE_MAP, AncestorMap_,
    DYNAMIC_CRV_TYPE_TO_DOWNCAST_FUNCTION,
    DYNAMIC_SRF_TYPE_TO_DOWNCAST_FUNCTION,
    IndexedDataMapOfShapeListOfShapeGenerator_,
    IndexedMapOfShapeGenerator_,
    SUB_ANCESTOR_SHAPE_TYPE_MAP,
    SubShapeGenerator_, TOPABS_NAMES,
    TopTools_HSequenceOfShapeGenerator,
    TopTools_ListOfShape2list,
    TopTools_ListOfShapeGenerator_,
    TopoDS_Compound_Iterator,
    TopoDS_Shape_Downcast, ancestor_edges,
    ancestor_faces, ancestors,
    downcast_handle_geom_curve,
    downcast_handle_geom_surface,
    dynamic_transient_type,
    iterate_TopTools_ListOfShape,
    iterate_TopTools_SequenceOfShape,
    make_TopTools_HSequenceOfShape,
    make_TopTools_ListOfShape,
    make_TopoDS_Compound, unique_shape_generator_,
    unpack_single_shape_compound,
    wire_edge_generator)

from parapy.core.exceptions import ParaPyDeprecationWarning
from parapy.core.utilities import (
    iflatten, is_color, is_string, lazy_hasattr,
    type_hasattr)
from parapy.geom import Vector
from parapy.geom.occ.globs import (Name2TopAbs, TobAbs2TopoDS, TopAbs2Class)

# TODO (TBD): Refactor parapy so these can be used from OCC.utils. Author: FT.
# we get these from OCC.utils, temporary placeholder to fool auto import
DYNAMIC_CRV_TYPE_TO_DOWNCAST_FUNCTION  # candidate for removal
DYNAMIC_SRF_TYPE_TO_DOWNCAST_FUNCTION  # candidate for removal
ANCESTOR_SUB_SHAPE_TYPE_MAP  # candidate for removal
dynamic_transient_type
downcast_handle_geom_curve
downcast_handle_geom_surface
TopoDS_Compound_Iterator
TopoDS_Shape_Downcast  # not tested in OCC.utils
make_TopoDS_Compound
TopTools_HSequenceOfShapeGenerator
unique_shape_generator_
TopTools_ListOfShapeGenerator_
TopTools_ListOfShape2list
IndexedMapOfShapeGenerator_
IndexedDataMapOfShapeListOfShapeGenerator_
SubShapeGenerator_
downcast_topods_shape = downcast_shape
sub_shapes
AncestorMap_
iterate_TopTools_ListOfShape  # not tested in OCC.utils
iterate_TopTools_SequenceOfShape
make_TopTools_ListOfShape
ancestors  # candidate for removal
ancestor_edges
ancestor_faces
unpack_single_shape_compound
wire_edge_generator
TOPABS_NAMES
SUB_ANCESTOR_SHAPE_TYPE_MAP

NON_EDGE_AGGREGATES = frozenset((TopAbs_VERTEX, TopAbs_EDGE))
NON_FACE_AGGREGATES = frozenset((TopAbs_VERTEX, TopAbs_EDGE, TopAbs_WIRE,
                                 TopAbs_FACE))


def gp_Ax3_from_position(position):
    """Given a ``position``, returns its :class:`gp_Ax3` object.

    :type position: parapy.geom.generic.positioning.Position
    :rtype: OCC.gp.gp_Ax3
    """
    return gp_Ax3(gp_Pnt(*position.location),
                  gp_Dir(*position.Vz),
                  gp_Dir(*position.Vx))


# ------ factories ----
TopTools_HSequenceOfShape_factory = make_TopTools_HSequenceOfShape

# =============================================================================
# Generators/Iterators
# =============================================================================


# returns ParaPy objects
def SubShapeGenerator(shape, name):
    """Return a generator that yields unique ParaPy objects (subclassed).

    >>> from parapy.geom import Box
    >>> box = Box(1, 1, 1)
    >>> list(SubShapeGenerator(box, "shell"))  # doctest: +ELLIPSIS
    [<Shell_ ...>]

    :param parapy.geom.BRep shape: ParaPy geometry
    :param str name: "vertex", "edge", etc.
    :rtype: collections.Iterator[parapy.geom.BRep]
    :raises KeyError: if name not in :py:`globals.Name2TopAbs.keys()`
    """
    topods_shape = shape.TopoDS_Shape
    owner = shape._owner or shape

    # converters
    TopAbs_ShapeEnum = Name2TopAbs[name]
    class_ = getattr(shape, TopAbs2Class[TopAbs_ShapeEnum])
    # TopoDS_cast = TobAbs2TopoDS[TopAbs_ShapeEnum]

    # Create maps
    if TopAbs_ShapeEnum == TopAbs_COMPOUND:
        # bug where with the other method, only the compound itself
        # is returned, not the contained compounds
        for shape in _map_all_shapes(topods_shape):
            if shape.ShapeType() == TopAbs_ShapeEnum:
                yield class_(TopoDS_Shape=shape, _owner=owner)
    else:
        Map = TopTools_IndexedMapOfShape()
        TopExp__MapShapes(topods_shape, TopAbs_ShapeEnum, Map)

        # Generator
        for i in range(1, Map.Extent() + 1):
            yield class_(TopoDS_Shape=Map(i), _owner=owner)


# downcasts shapes and deals with ParaPy objects
class AncestorMap(object):
    """Wraps OCC's mechanism to map shapes and ancestors. This is useful
    to find all faces on which an edge lies, etc. Usage:

    >>> from parapy.geom import Box
    >>> box = Box(1, 1, 1)
    >>> amap = AncestorMap(box, "edge", "face")
    >>> # either iterate over this map to get sub-shape - ancestors pairs.
    >>> for edge, on_faces in amap:
    ...     print(edge, tuple(on_faces))  # doctest: +ELLIPSIS
    <Edge_ ...> (<Face_ ...>, <Face_ ...>)
    <Edge_ ...> (<Face_ ...>, <Face_ ...>)
    <Edge_ ...> (<Face_ ...>, <Face_ ...>)
    <Edge_ ...> (<Face_ ...>, <Face_ ...>)
    <Edge_ ...> (<Face_ ...>, <Face_ ...>)
    <Edge_ ...> (<Face_ ...>, <Face_ ...>)
    <Edge_ ...> (<Face_ ...>, <Face_ ...>)
    <Edge_ ...> (<Face_ ...>, <Face_ ...>)
    <Edge_ ...> (<Face_ ...>, <Face_ ...>)
    <Edge_ ...> (<Face_ ...>, <Face_ ...>)
    <Edge_ ...> (<Face_ ...>, <Face_ ...>)
    <Edge_ ...> (<Face_ ...>, <Face_ ...>)
    >>> # or use getitem to access ancestors of a specific shape
    >>> tuple(amap[box.edges[0]])  # doctest: +ELLIPSIS
    (<Face_ ...>, <Face_ ...>)
    """

    __slots__ = ["map", "shape_enum1", "shape_enum2",
                 "class1", "class2", "cast1", "cast2", "shape", "cache"]

    def __init__(self, shape, shape_type1, shape_type2):
        """Create an :class:`AncestorMap`.

        :param parapy.geom.BRep shape: the shape to explore, a ParaPy
            BRep-derived object.
        :param str shape_type1: "vertex", "edge", etc.
        :param str shape_type2: "vertex", "edge", etc.
        """
        msg = ("AncestorMap has been deprecated, use "
               "OCC.utils.utilities.AncestorMap_ instead.")
        warnings.warn(msg, ParaPyDeprecationWarning)
        self.shape = shape
        self.shape_enum1 = shape_enum1 = Name2TopAbs[shape_type1]
        self.shape_enum2 = shape_enum2 = Name2TopAbs[shape_type2]
        self.cast1 = TobAbs2TopoDS[shape_enum1]
        self.cast2 = TobAbs2TopoDS[shape_enum2]
        self.class1 = getattr(shape, TopAbs2Class[shape_enum1])
        self.class2 = getattr(shape, TopAbs2Class[shape_enum2])
        self.init_map()

    def init_map(self):
        """Initialize the :class:`AncestorMap` instance.

        :return:
        """
        self.cache = {}
        self.map = map = TopTools_IndexedDataMapOfShapeListOfShape()
        TopExp__MapShapesAndAncestors(self.shape.TopoDS_Shape,
                                      self.shape_enum1, self.shape_enum2, map)

    def __getitem__(self, sub_shape):
        """``sub_shape`` is BRep (ParaPyObject). Return generator of ancestor.

        shapes::

            (ancestor_shape, ancestor_shape, ...)

        :rtype: collections.Iterator[parapy.geom.BRep]
        """
        cache = self.cache
        sub_shape = sub_shape.TopoDS_Shape
        if sub_shape in cache:
            for anc_shape in cache[sub_shape]:
                yield anc_shape
        else:
            self.cache[sub_shape] = val = []
            owner, cast, class_ = self.shape, self.cast2, self.class2
            toptools_listofshape = self.map.FindFromKey(sub_shape)

            for v in toptools_listofshape:
                anc_shape = class_(TopoDS_Shape=cast(v), _owner=owner)
                val.append(anc_shape)
                yield anc_shape

    def __iter__(self):
        """Returns a generator::

            (shape, (ancestor_shape, ancestor_shape, ...),
             shape, (...))

        :rtype: collections.Iterator[tuple[parapy.geom.BRep, tuple[parapy.geom.BRep]]]
        """
        owner, cast, class_ = self.shape, self.cast1, self.class1
        Map = self.map
        for i in range(1, Map.Extent() + 1):
            shape = class_(TopoDS_Shape=cast(Map.FindKey(i)), _owner=owner)
            yield (shape, self[shape])


def resolve_gce_status(builder):
    """Resolve the status of a Geom Curve builder.

    :type builder: OCC.GC.GC_Root | T
    :rtype: OCC.Geom.Handle_Geom_Curve
    :raises RuntimeError: When construction using ``builder`` failed.
    """
    if builder.IsDone():
        return builder.Value()
    else:
        from parapy.geom.occ.globs import GCE_ERROR
        status = builder.Status()
        if status in GCE_ERROR:
            raise RuntimeError("construction failed:", repr(status), ":",
                                GCE_ERROR[status])
        else:
            raise RuntimeError("construction failed: reason unknown")


def is_curve_aggregate(obj):
    """Is ``obj`` an aggregate of curves? In other words: is it a topology
    consisting of more than one edge? Usage:

    >>> from parapy.geom import Box
    >>> box = Box(1, 2, 3)
    >>> is_curve_aggregate(box)
    True
    >>> is_curve_aggregate(box.shells[0])
    True
    >>> is_curve_aggregate(box.faces[0])
    True
    >>> is_curve_aggregate(box.wires[0])
    True
    >>> is_curve_aggregate(box.edges[0])
    False
    >>> is_curve_aggregate(box.edges[0].vertices[0])
    False

    :type obj: parapy.geom.BRep
    :rtype: bool
    """
    if obj.TOPOLEVEL in NON_EDGE_AGGREGATES:
        return False
    elif len(obj.edges) == 1:
        return False
    else:
        return True


def is_face_aggregrate(obj):
    """Is ``obj`` an aggregate of faces? In other words: is it a topology
    consisting of more than one face? Usage:

    >>> from parapy.geom import Box
    >>> box = Box(1, 2, 3)
    >>> is_face_aggregrate(box)
    True
    >>> is_face_aggregrate(box.shells[0])
    True
    >>> is_face_aggregrate(box.faces[0])
    False
    >>> is_face_aggregrate(box.wires[0])
    False
    >>> is_face_aggregrate(box.edges[0])
    False
    >>> is_face_aggregrate(box.edges[0].vertices[0])
    False

    :type obj: parapy.geom.BRep
    :rtype: bool
    """
    if obj.TOPOLEVEL in NON_FACE_AGGREGATES:
        return False
    elif len(obj.faces) == 1:
        return False
    else:
        return True


def display_shape_tolerances(shape, transparent_shape=True,
                             vertices=True, edges=True, faces=True,
                             threshold=1.0e-7):
    """Visualize the tolerances of a given ``shape``.

    :type shape: parapy.geom.BRep
    :param bool transparent_shape: Should the base shape be displayed
        transparently? (default: True) If set to False, only the shapes
        will be drawn of which the tolerances are shown.
    :param bool vertices: Should the tolerance of vertices be shown?
        (default: True)
    :param bool edges: Should the tolerance of edges be shown? (default: True)
    :param bool faces: Should the tolerance of faces be shown? (default: True)
    :param float threshold: Only tolerance values above this level will be
        shown. (default: 1e-7)
    """
    from OCC.gui.tolerances import display_tolerances

    topo_ds = shape.TopoDS_Shape
    display_tolerances(topo_ds, transparent_shape=transparent_shape,
                       vertices=vertices, edges=edges, faces=faces,
                       threshold=threshold)


def is_shape_like(obj):
    return type_hasattr(obj, 'TopoDS_Shape')


def is_vertex_like(obj):
    return type_hasattr(obj, 'TopoDS_Vertex')


def is_edge_like(obj):
    return type_hasattr(obj, 'TopoDS_Edge')


def is_wire_like(obj):
    return type_hasattr(obj, 'TopoDS_Wire')


def is_face_like(obj):
    return type_hasattr(obj, 'TopoDS_Face')


def is_shell_like(obj):
    return type_hasattr(obj, 'TopoDS_Shell')


def is_solid_like(obj):
    return type_hasattr(obj, 'TopoDS_Solid')


def is_curve_like(obj):
    return type_hasattr(obj, 'Handle_Geom_Curve')


def is_circle_like(obj):
    return is_curve_like(obj) and type_hasattr(obj.Handle_Geom_Curve, 'Circ')


def is_surface_like(obj):
    return type_hasattr(obj, 'Handle_Geom_Surface')


def is_plane_like(obj):
    return is_surface_like(obj) and type_hasattr(obj.Handle_Geom_Surface,
                                                 'Pln')


def _vector_is_atomic(obj):
    return isinstance(obj, Vector) or is_string(obj)


iflatten_vector = partial(iflatten, is_atomic=_vector_is_atomic)
iflatten_color = partial(iflatten, is_atomic=is_color)  # includes str check
topods_shape_getter = attrgetter("TopoDS_Shape")


def extract_shape_algo_errors_warnings(builder, msg_fail="{}", msg_warn="{}"):
    """Extract and notify errors and warnings in a Pythonic way caused by
    algorithms that use the ``HasErrors``, ``DumpErrors`` protocol for
    these messages.

    :param OCC.BOPAlgo.BOPAlgo_Options | OCC.BRepAlgoAPI.BRepAlgoAPI_Algo builder: builder
        which will be checked for errors or warnings.
    :param str msg_fail: Format string used to generate a 'fail' message.
        Leave one '{}' in it for the errors.
    :param str msg_warn: Format string used to generate a warning message.
        Leave one '{}' in it for the errors.
    """
    # warnings first, to leave room for the possibility of having both
    # warnings and errors.
    if builder.HasWarnings():
        s = io.BytesIO()
        builder.DumpWarnings(s)
        errors = s.getvalue().decode('ascii')

        warnings.warn(msg_warn.format(errors))

    if builder.HasErrors():
        s = io.BytesIO()
        builder.DumpErrors(s)
        errors = s.getvalue().decode('ascii')

        raise RuntimeError(msg_fail.format(errors))


def is_curve_in_plane(curve, plane, tolerance=1.e-7):
    """Is `curve` entirely in `plane` within `tolerance`?

    :param parapy.geom.Curve curve:
    :param parapy.geom.Plane plane:
    :param float tolerance:
    :rtype: bool
    """
    if lazy_hasattr(curve, "edges") and len(curve.edges) > 1:
        # we are probably a multi-edged wire. Duck-typing to avoid circular
        # import
        curve_in_plane = partial(is_curve_in_plane, plane=plane,
                                 tolerance=tolerance)
        return all(map(curve_in_plane, curve.edges))

    if curve.is_straight_with_tolerance(tolerance=tolerance):
        # infinite amount of normals, so we use the endpoints
        return (plane.point_in_plane(curve.start, tolerance=tolerance) and
                plane.point_in_plane(curve.end, tolerance=tolerance))
    else:
        # There's are only 2 possible (opposite) plane normals
        return (curve.is_planar_with_tolerance(tolerance=tolerance) and
                curve.plane_normal.is_parallel(plane.normal, tol=tolerance))


def yield_curves_in_plane(curves, plane, tolerance=1e-7):
    """Generate all `curves` that lie in `plane` within `tolerance`.

    If you only want the first of these `curves` that lie in `plane` or
    `None`, use::

        next(yield_curves_in_plane(curves, plane), None)

    :param typing.Iterable[parapy.geom.Curve] curves: curves to check
    :param parapy.geom.Plane plane: plane on which `curves` should lie
    :param float tolerance:
    :rtype: typing.Iterator[parapy.geom.Curve]
    """
    is_in_plane = partial(is_curve_in_plane, plane=plane, tolerance=tolerance)
    return filter(is_in_plane, curves)


def curves_in_plane(curves, plane, tolerance=1e-7):
    """Return a list of all `curves` that lie in `plane` within `tolerance`.

    :param typing.Iterable[parapy.geom.Curve] curves: curves to check
    :param parapy.geom.Plane plane: plane on which `curves` should lie
    :param float tolerance:
    :rtype: typing.Iterator[parapy.geom.Curve]
    """
    return list(yield_curves_in_plane(curves, plane, tolerance=tolerance))


def vertex_at_point(shape, pt):
    """Return the vertex of `shape` at `pt`, or None if it cannot be found.
    This function uses the tolerance of the vertex to decide if `pt` falls
    within it.

    :param parapy.geom.occ.brep.BRep shape: shape of which the vertices will
        be checked
    :param parapy.geom.Point pt: point around which the vertex should lie.
    :rtype: parapy.geom.occ.vertex.Vertex_ | None
    """
    for vertex in shape.vertices:
        v_tol = BRep_Tool_Tolerance(vertex.TopoDS_Vertex)
        if vertex.point.distance(pt) < v_tol:
            return vertex
    return None
