#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import os
import sys
from collections import OrderedDict
from dataclasses import fields, is_dataclass
from itertools import groupby
from operator import attrgetter
from typing import Set

import wx
import wx.propgrid as wxpg
from wx import TheClipboard, TextDataObject, MessageBox

from parapy.core import (
    Attribute, Input, Part, apply_to_all, ensure_iterable, getslot)
from parapy.core.abstract import ParaPyObject
from parapy.core.abstractbase import AbstractBase
from parapy.core.decorators import Action
from parapy.core.exceptions import MissingRequiredInput, ValidationError
from parapy.core.utilities import _get_slot, is_iterable, running_IPython
from parapy.gui import wx34
from parapy.gui.clipboard import Clipboard
from parapy.gui.events import EVT_REFRESH, create_refresh_event
from parapy.gui.globs import CONFIGURATION, ICN_DIR
from parapy.gui.logger import logger
from parapy.gui.menus import DisplayContextMenu
from parapy.gui.toggle_bitmap_button import ToggleBitmapButton
from parapy.gui.utilities import (
    truncate, yield_mro_sorted_methods, yield_mro_sorted_slots)
from parapy.gui.widgets import PGEditorType, WIDGET_FACTORY, Widget
from parapy.gui.wx_utils import popup

# singleton
Nothing = object()

# make PGProperty hashable
wxpg.PGProperty.__eq__ = lambda self, other: self.IsSameAs(other)
wxpg.PGProperty.__hash__ = lambda self: self.GetName().__hash__()

# used to store attribute names with their values in properties
PROPATTR_WIDGET = 'widget'
PROPATTR_PREV_INVALID_VALUE = 'prev_invalid_value'
WIDGET_ERROR_STATES = {Widget.ERROR, Widget.MISSING}


def _make_button(parent, string, icon, cls=wx.BitmapButton):
    """
    :rtype: wx.BitmapButton | ToggleBitmapButton
    """
    if isinstance(icon, str):
        filename = os.path.join(ICN_DIR, icon)
        icon = wx.Bitmap(filename, wx.BITMAP_TYPE_ANY)
    sz = 28 if sys.platform == 'linux' else 24
    button = cls(parent, wx.ID_ANY, icon, wx.DefaultPosition,
                 wx.Size(sz, sz), wx.BU_AUTODRAW)
    tip = wx.ToolTip(string)
    button.SetToolTip(tip)
    return button


# TODO (TBD): To avoid letting the window hang, do this in a new thread
# /todo With a timer, show a busybox after 0.5 seconds if the thread didn't
# /todo complete yet. When the thread completes, raise an event. Catch the
# /todo event in the main event loop and hide the busybox, if it was shown.
class DataPanel(wx.Panel):
    """This panel lists slot values and allows user to interact with these.

    >>> import wx
    >>> from parapy.core import Base
    >>> from parapy.gui.data import DataPanel
    >>>
    >>> app = wx.GetApp() or wx.App(False)
    >>> frame = wx.Frame(None)
    >>> obj = Base()
    >>> panel = DataPanel(frame, obj)

    .. note:: this Panel posts a EVT_REFRESH if user demands evaluation of a
        slot or changes a value. It expects some callback function that
        registers to this event and is in charge of refreshing this panel
        :meth:`refresh`.
    """

    LABEL = "Property View"
    UNEVALUATED_LABEL = "<double-click to evaluate>"
    REQUIRED_VALUE_LABEL = "<fill out required value>"

    INHERITED = True
    PRIVATE = False
    #: nb to characters to truncate long repr() at when displaying slot
    #: values. Put to None, to suppress truncation.
    REPR_LIMIT = 99
    #: should GUI print / log error to console?
    LOG_EXCEPTIONS = CONFIGURATION["log_exceptions_in_data_panel"]
    #: should GUI show a popup with exceptions if they occur?
    POPUP_EXCEPTIONS = CONFIGURATION["popup_exceptions_in_data_panel"]

    # in order of appearance in grid
    _GROUP_LABEL_TO_TYPE = [("Actions", Action),
                            ("Inputs", Input),
                            ("Attributes", Attribute),
                            ("Parts", Part)
                            ]

    _REGISTERED_EDITOR_CLASSES = set()  # type: Set[PGEditorType]

    def __init__(self, parent, obj, globals={}, autodisplay=True):
        wx.Panel.__init__(self, parent)  # , style=wx.BORDER_SUNKEN)

        #: root object
        self.root = obj
        #: current object
        self.obj = None
        #: path to current object, e.g. ("wing", 0, "rib", 1)
        self.path = ()
        #: globals dict from module starting the gui. Used for eval / set-self.
        self.globals = globals
        #: context menu on right-click.
        self.context_menu = DataContextMenu(self)
        #: collapse status
        self.collapse = False
        #: show inherited slots?
        self.inherited = self.INHERITED
        #: shows private slots?
        self.private = self.PRIVATE
        #: A cache with a ``path`` mapping to the state, like scroll
        #: positions and the selection at that time. A `None` state
        #: denotes that there is no cache value.
        #: The cache represents a navigation session ('nav session'). When
        #: navigating down and back up through the property grids, the
        #: session remains, and state of the grid is restored. Skipping steps
        #: in the tree, or getting set from outside will start a new session,
        #: and previous editable states will be removed.
        #: :type: list[tuple[tuple[str | int], str | None]
        self._state_cache = []
        #: :type: list[Widget]
        self._widgets = []
        #: :type: dict[T, Widget]
        self._key_to_widget = {}

        self.EXPAND_ALL_BITMAP = wx.Bitmap(os.path.join(ICN_DIR, "expand_all.png"), wx.BITMAP_TYPE_ANY)
        self.COLLAPSE_ALL_BITMAP = wx.Bitmap(os.path.join(ICN_DIR, "collapse_all.png"), wx.BITMAP_TYPE_ANY)

        box = wx.StaticBox(self, wx.ID_ANY, self.LABEL)
        sizer = wx.StaticBoxSizer(box, wx.VERTICAL)
        sizer_buttons = wx.BoxSizer(wx.HORIZONTAL)
        sizer_path = wx.BoxSizer(wx.HORIZONTAL)

        sty = wxpg.PG_DEFAULT_STYLE
        self.grid = wxpg.PropertyGrid(self, style=sty)

        staticbox = sizer.GetStaticBox()
        icon = wx.ArtProvider.GetBitmap(wx.ART_GO_DIR_UP, wx.ART_MENU)
        self.button_up = _make_button(staticbox, "go to parent object", icon)
        icon = wx.ArtProvider.GetBitmap(wx.ART_GO_HOME, wx.ART_MENU)
        self.button_root = _make_button(staticbox, "go to root object", icon)
        self.button_inherited = _make_button(staticbox, "show inherited slots", "inherited.png", cls=ToggleBitmapButton)
        self.button_private = _make_button(staticbox, "show private slots", "private_attributes.png", cls=ToggleBitmapButton)
        self.button_collapse_all = _make_button(staticbox, "collapse / expand grid", self.COLLAPSE_ALL_BITMAP)
        self.button_evaluate = _make_button(staticbox, "evaluate all slots", "controls.png")
        self.button_refresh = _make_button(staticbox, "refresh the grid", "refresh.png")

        self.text_repr = wx.TextCtrl(
            staticbox, wx.ID_ANY, "Click an object in the tree",
            wx.DefaultPosition, wx.DefaultSize,
            wx.TE_NO_VSCROLL|wx.TE_READONLY)
        self.text_repr.SetForegroundColour(
            wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOWTEXT))
        self.text_repr.SetBackgroundColour(wx.WHITE)

        # self.text_path = wx.TextCtrl(self, style=wx.TE_READONLY, value="Click an object in the tree")
        # self.text_path.SetForegroundColour(wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOWTEXT))
        # self.text_path.SetBackgroundColour(wx.WHITE)

        self.text_static_path = wx.StaticText(staticbox, wx.ID_ANY, "path",
                                              wx.DefaultPosition,
                                              wx.DefaultSize, 0)
        self.text_static_path.Wrap(-1)
        self.text_path = wx.TextCtrl(staticbox, wx.ID_ANY, wx.EmptyString,
                                     wx.DefaultPosition, wx.DefaultSize,
                                     wx.TE_NO_VSCROLL | wx.TE_READONLY)
        self.text_path.SetForegroundColour(
            wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOWTEXT))
        self.text_path.SetBackgroundColour(wx.WHITE)

        border = 5
        sizer_buttons.Add(self.button_up, 0, wx.ALL, border)
        sizer_buttons.Add(self.button_root, 0, wx.ALL, border)
        sizer_buttons.Add(self.button_inherited, 0, wx.ALL, border)
        sizer_buttons.Add(self.button_private, 0, wx.ALL, border)
        sizer_buttons.Add(self.button_collapse_all, 0, wx.ALL, border)
        sizer_buttons.Add(self.button_evaluate, 0, wx.ALL, border)
        sizer_buttons.Add(self.text_repr, 1, wx.ALL | wx.EXPAND, border)
        sizer_buttons.Add(self.button_refresh, 0, wx.ALL, border)

        sizer_path.Add(self.text_static_path, 0, wx.ALIGN_CENTER_VERTICAL | wx.ALL, border)
        sizer_path.Add(self.text_path, 1, wx.ALL, border)

        sizer.Add(sizer_buttons, 0, wx.EXPAND, border)
        if sys.platform == 'linux':
            # on linux the icons need a bit more space below them
            sizer.AddSpacer(4*border)

        sizer.Add(self.grid, 1, wx.EXPAND)
        sizer.Add(sizer_path, 0, wx.EXPAND, 0)

        self.text_repr.Bind(wx.EVT_CONTEXT_MENU, self.on_right_click_text_repr)

        self.button_up.Bind(wx.EVT_BUTTON, self.on_button_up)
        self.button_root.Bind(wx.EVT_BUTTON, self.on_button_root)
        self.button_inherited.Bind(
            wx.EVT_TOGGLEBUTTON, self.on_button_inherited)
        self.button_private.Bind(wx.EVT_TOGGLEBUTTON, self.on_button_private)
        self.button_collapse_all.Bind(
            wx.EVT_BUTTON, self.on_button_collapse_all)
        self.button_evaluate.Bind(wx.EVT_BUTTON, self.on_button_evaluate_all)
        self.button_refresh.Bind(wx.EVT_BUTTON, self.on_button_refresh)

        self.grid.Bind(wxpg.EVT_PG_CHANGING, self.on_property_value_changing)
        self.grid.Bind(wxpg.EVT_PG_DOUBLE_CLICK, self.on_double_click)
        self.grid.Bind(wxpg.EVT_PG_RIGHT_CLICK, self.on_right_click)

        self.Bind(EVT_REFRESH, self.refresh_event_handler)

        self.SetSizer(sizer)
        self.Layout()

        self.button_inherited.SetValue(self.inherited)
        self.button_private.SetValue(self.private)

        if autodisplay:
            # display root obj
            self.display((), obj)

    def on_button_inherited(self, evt):
        inherited = not self.inherited
        self.inherited = inherited
        self.button_inherited.SetValue(inherited)
        obj = self.obj
        if isinstance(obj, AbstractBase):
            self.populate(obj)

    def on_button_private(self, evt):
        private = not self.private
        self.private = private
        self.button_private.SetValue(private)
        obj = self.obj
        if isinstance(obj, AbstractBase):
            self.populate(obj)

    def on_button_collapse_all(self, evt):
        if self.collapse:
            self.grid.ExpandAll()
            self.collapse = False
            self.button_collapse_all.SetBitmap(self.COLLAPSE_ALL_BITMAP)
        else:
            self.grid.CollapseAll()
            self.collapse = True
            self.button_collapse_all.SetBitmap(self.EXPAND_ALL_BITMAP)

    @property
    def wxpg_properties(self):
        return list(self.grid.Properties)

    def evaluate_all(self):
        obj = self.obj

        if not isinstance(obj, AbstractBase):
            return

        widgets = self.sorted_widgets_by_compute_status()

        for widget in widgets:
            attr = widget.key
            new_state, value = self._compute(obj, attr, eager=True)
            self.update_widget(widget, new_state, value)

    def on_button_evaluate_all(self, evt):
        self.evaluate_all()

    def on_button_refresh(self, evt):
        self.post_refresh_event()

    def display(self, path, obj=Nothing, reset_nav_session=True):
        """Show property grid for given path and obj. By default it will
        start a new 'scroll session', which manages the scroll position.
        """
        if reset_nav_session:
            self._invalidate_state_caches_downstream()
        else:
            self._cache_state()  # cache the previous path

        self.path = path
        if obj is Nothing:
            obj = getslot(self.root, path, parse=False)
        if obj is not self.obj:
            self.populate(obj)
            self.obj = obj
        else:  # obj is self.obj
            self.post_refresh_event()

        if not reset_nav_session:
            self._restore_state()  # applies on the current path

    @staticmethod
    def can_display(obj):
        return (isinstance(obj, (ParaPyObject, dict)) or
                is_dataclass(obj) or
                is_iterable(obj))

    def display_child(self, key, reset_nav_session=False):
        widget = self.get_widget(key)
        if widget.state in WIDGET_ERROR_STATES:
            self._popup_exception(widget.value)
        elif widget.inspectable:
            path = self.path + (key,)
            child = _get_slot(self.obj, key)  # TODO (TBD): remove _get_slot

            if self.can_display(child):
                self.display(path, obj=child,
                             reset_nav_session=reset_nav_session)

    def invalidate(self, key):
        obj = self.obj
        if isinstance(obj, AbstractBase):
            delattr(self.obj, key)
        self.post_refresh_event()

    def bind_self(self, obj):
        self.globals['self'] = obj
        print("Bound 'self' to {:}. Try:\nIn[1]: self".format(repr(obj)))

    def clear(self):
        self.obj = None
        self._widgets[:] = []
        self._key_to_widget.clear()
        self.grid.Clear()

    def refresh(self, preserve_error_states=False):
        # no need to refresh, it's atomic data
        if not isinstance(self.obj, AbstractBase):
            return

        widgets = self.sorted_widgets_by_compute_status(
            skip_error_state=preserve_error_states)

        state_value_pairs = list(map(self._compute_widget, widgets))
        for w, (s, v) in zip(widgets, state_value_pairs):
            self.update_widget(w, s, v)

    def refresh_event_handler(self, evt):
        try:
            preserve_error_states = evt.preserve_error_states
        except AttributeError:
            preserve_error_states = False
        self.refresh(preserve_error_states=preserve_error_states)

    def _invalidate_state_caches_downstream(self, start=0):
        """Remove all state caches for paths longer or equal than
        ``start``.
        """
        del self._state_cache[start:]

    def _cache_state(self):
        path = self.path
        path_len = len(path)

        # update state caches for all paths from root, up to (not
        # including) self.path. It ensures each of these paths has
        # a cache, and that caches for paths that are not a prefix of
        # self.path are invalidated.
        grid_states = self._state_cache
        for i in range(path_len):
            current_path = path[:i]
            try:
                cache_path, _ = grid_states[i]
            except IndexError:  # if it is not there, create empty cache
                grid_states.append((current_path, None))
            else:  # there is a cache already
                if current_path != cache_path:
                    # There is a cached sibling-branch: 'invalidate' it by
                    # converting it to a cache for current_path, initialized
                    # to None
                    grid_states[i] = (current_path, None)

        # Cache the editable state for self.path. If the related state
        # cache was already in use for a sibling-branch, also remove
        # any states that appear downstream from me (since they will
        # refer to paths for which we want to invalidate the state cache).
        new_state = self.grid.SaveEditableState()
        path_state = (path, new_state)
        try:
            cache_path, _ = grid_states[path_len]
        except IndexError:
            grid_states.append(path_state)
        else:
            if cache_path != path:
                # we took a different branch than before: re-use the entry
                # and update it for the new path, but invalidate any caches
                # downstream from me
                self._invalidate_state_caches_downstream(start=path_len + 1)
            grid_states[path_len] = path_state

    def _restore_state(self):
        path = self.path
        path_len = len(path)
        try:
            old_path, state = self._state_cache[path_len]
        except IndexError:  # does not exist
            pass
        else:
            if old_path == path:
                if state:
                    self.grid.RestoreEditableState(state)
            else:
                # we tried to restore an editable state for self.path,
                # but a value for a sibling branch was cached. This denotes
                # that we went there previously from our common parent, and
                # we should invalidate any caches in the sibling-branch
                self._invalidate_state_caches_downstream(start=path_len)

    def populate(self, obj):
        self.clear()

        self.obj = obj
        self.text_path.SetValue(pretty_path(self.path))
        repr_obj = truncate(repr(obj), self.REPR_LIMIT)
        self.text_repr.SetValue(repr_obj)

        # first initialize widgets
        self._make_widgets()
        # then compute underlying parapy model
        self._compute_widgets()
        # then add wxpg_properties to grid
        self._add_widgets_to_grid()

        self.grid.FitColumns()

    def _make_widgets(self):
        obj = self.obj
        if isinstance(obj, AbstractBase):
            self._make_widgets_abstract_base(obj)
        elif (isinstance(obj, (ParaPyObject, dict)) or
              is_dataclass(obj) or
              hasattr(obj, "__iter__")):
            self._make_widgets_non_abstract_base(obj)
        else:
            # one slot showing 'not' 'supported'.
            msg = "don't know how to display properties of {}."
            repr_obj = truncate(repr(obj), self.REPR_LIMIT)
            self._log_exception(msg.format(repr_obj))

    def _add_widgets_to_grid(self):
        if isinstance(self.obj, AbstractBase):
            self._add_widgets_to_grid_abstract_base()
        else:
            self._add_widgets_to_grid_non_abstract_base()

    def _compute_widgets(self):
        if not isinstance(self.obj, AbstractBase):
            return

        widgets = self.sorted_widgets_by_compute_status()
        state_value_pairs = list(map(self._compute_widget, widgets))
        for w, (s, v) in zip(widgets, state_value_pairs):
            self._make_wxpg_property_from_widget(w, s, v)

    def _make_widgets_abstract_base(self, obj):
        grid, inherited, private = self.grid, self.inherited, self.private

        cls = type(obj)

        for base, actions in yield_mro_sorted_methods(
                cls, Action.__ppmembername__):
            # don't show inherited slots if requested
            if not (inherited or base is cls):
                continue

            for attr, action in actions:  # type: (str, Action)
                if not action.in_context(Action.Context.INSPECTOR):
                    continue
                widget = self._make_widget(obj, attr)
                # evaluate here immediately
                self._make_wxpg_property_from_widget(
                    widget, Widget.EVALUATED, None)

        for base, slots in yield_mro_sorted_slots(cls, "_slots"):
            # don't show inherited slots if requested
            if not (inherited or base is cls):
                continue

            for attr, slot in slots:
                # don't show private slots if requested, could be Action
                if not private and slot.private:
                    continue

                self._make_widget(obj, attr)

    def _make_widgets_non_abstract_base(self, obj):
        if isinstance(obj, ParaPyObject):
            # Can be a point, axis, Position, etc.
            gen = ((k, getattr(obj, k)) for k in sorted(obj._tree_attrs))
        elif isinstance(obj, (dict, OrderedDict)):
            gen = obj.items()  # we do not sort and keep OrderedDict order
        elif is_dataclass(obj):
            gen = ((f.name, getattr(obj, f.name)) for f in fields(obj))
        elif hasattr(obj, "__iter__"):
            gen = ((i, value) for i, value in enumerate(obj))
        else:
            raise ValueError(repr(obj))

        for key, value in gen:
            widget = self._make_widget(obj, key)
            # evaluate here immediately
            self._make_wxpg_property_from_widget(
                widget, Widget.EVALUATED, value)

    def _add_widgets_to_grid_abstract_base(self):
        """Add a list of class slots as a group to the grid."""
        grid = self.grid
        for label, widgets in self.sorted_widgets_by_category():
            if not widgets:  # make sure it does not create a category
                continue
            prop_category = wxpg.PropertyCategory(label)
            grid.Append(prop_category)
            for widget in widgets:
                prop = widget.wxpg_property
                grid.AppendIn(prop_category, prop)
                # expand property if required (can only be done after
                # property has been added to the grid)
                if hasattr(prop, "autoexpand") and prop.autoexpand:
                    grid.Expand(prop)

    def _add_widgets_to_grid_non_abstract_base(self):
        grid = self.grid
        widgets = self.widgets
        for widget in widgets:
            grid.Append(widget.wxpg_property)

    def _make_wxpg_property(self, obj, key, state, value):
        widget = self._make_widget(obj, key)
        return self._make_wxpg_property_from_widget(widget, state, value)

    def _make_wxpg_property_abstractbase(self, obj, attr):
        widget = self._make_widget(obj, attr)
        state, value = self._compute(obj, attr, eager=widget.autocompute)
        return self._make_wxpg_property_from_widget(widget, state, value)

    def _make_wxpg_property_from_widget(self, widget, state, value):
        new_prop = self._update_widget(widget, state, value, create=True)
        new_prop.SetAttribute(PROPATTR_WIDGET, widget)
        return new_prop

    def _make_widget(self, obj, key):
        grid = self.grid
        widget = WIDGET_FACTORY.create_widget(grid, obj, key)
        editor_classes = widget.editor()
        if editor_classes:
            editor_classes = ensure_iterable(editor_classes)
            apply_to_all(self._register_editor_class, editor_classes)
        self._widgets.append(widget)
        self._key_to_widget[key] = widget

        return widget

    def _register_editor_class(self, cls: PGEditorType):
        """Register a (Widget) propgrid editor class.

        :type cls:
        """
        # takes care of not registering same class twice (will crash wx)
        cache = self._REGISTERED_EDITOR_CLASSES
        if cls not in cache:
            # wxpg.PropertyGrid.DoRegisterEditorClass(cls, type(cls).__name__)
            self.grid.RegisterEditor(cls)
            cache.add(cls)

    @property
    def widgets(self):
        """All widgets currently displayed in grid. For ParaPy objects,
        widgets are sorted by order of occurence in the source code and then
        against MRO. So for::

            class Foo(Base):
                width = Input()
                length = Input()

            class Bar(Foo):
                height = Input()
                volume = Input()

        Order for instances of Bar, will be: height, volume, width, length.

        :rtype: list[Widget]
        """
        return self._widgets

    def get_widget(self, key):
        return self._key_to_widget[key]

    def sorted_widgets_by_compute_status(self, skip_error_state=False):
        """Autocompute widgets first, then regular widgets. Stable sort that
        maintains original order of :attr:`widgets` (by source & MRO).

        :rtype: list[Widget]
        """
        head = []
        tail = []
        for w in self.widgets:
            if skip_error_state and w.state in WIDGET_ERROR_STATES:
                continue
            if not hasattr(w, "autocompute"):  # ButtonWidget for actions
                continue
            if w.autocompute:
                head.append(w)
            else:
                tail.append(w)

        head.extend(tail)
        return head

    def sorted_widgets_by_category(self):
        """Return categorical label, widgets pairs. Stable sort that
        maintains original order of :attr:`widgets` (by source & MRO).
        """
        widgets = self.widgets
        key = attrgetter("slot.__ppmembername__")
        widgets = sorted(widgets, key=key)
        widgets_by_membername = {k: list(v) for k, v in groupby(widgets, key=key)}

        for label, slot_type in self._GROUP_LABEL_TO_TYPE:
            member_name = slot_type.__ppmembername__
            widgets = widgets_by_membername.get(member_name, [])
            yield label, widgets

    def _compute_widget(self, widget):
        return self._compute(widget.obj, widget.key, eager=widget.autocompute)

    def _compute(self, obj, attr, eager=False):
        if obj.get_slot_status(attr):
            value = getattr(obj, attr)
            state = Widget.EVALUATED
        elif eager:
            try:
                value = getattr(obj, attr)
            except Exception as e:
                value = e

                if (isinstance(e, MissingRequiredInput) and
                        e.instance is obj and
                        e.slot_name == attr):
                    state = Widget.MISSING
                else:
                    state = Widget.ERROR

                    fmt = "evaluation of slot '{:}' on instance {:} failed"
                    msg = fmt.format(attr, repr(obj))
                    self._log_exception(msg, exc_info=True)
            else:
                state = Widget.EVALUATED
        else:
            value = None
            state = Widget.UNEVALUATED
        return state, value

    def on_button_up(self, evt):
        self.level_up()

    def level_up(self, reset_nav_session=False):
        self.display(self.path[:-1], reset_nav_session=reset_nav_session)

    def on_button_root(self, evt=None):
        self.display_root()

    def display_root(self, reset_nav_session=False):
        # if we skip more than one step, a new session is started anyway
        reset_nav_session = reset_nav_session or len(self.path) > 1
        self.display((), reset_nav_session=reset_nav_session)

    def post_refresh_event(self, preserve_error_states=False):
        event = create_refresh_event(self)
        event.preserve_error_states = preserve_error_states
        wx.PostEvent(self, event)

    def update_widget(self, widget, state, value):
        cur_prop = widget.wxpg_property
        new_prop = self._update_widget(widget, state, value)

        if new_prop is not cur_prop:
            widget.wxpg_property = new_prop
            new_prop.SetAttribute(PROPATTR_WIDGET, widget)
            self.grid.ReplaceProperty(cur_prop, new_prop)
            if hasattr(new_prop, "autoexpand") and new_prop.autoexpand:
                self.grid.Expand(new_prop)

    def _update_widget(self, widget, state, value, create=False):
        if create:
            # there currently is no property for this widget in the
            # property grid, so we need to create it
            widget_update = widget.do_create_wxpg_property
        else:
            widget_update = widget.do_update

        try:
            return widget_update(state, value)
        except Exception:
            msg = ("Error while creating a property from Widget {!r} for "
                   "state {!r} with value {!r}. Reverting to fallback "
                   "property.")
            self._log_exception(msg.format(widget, state, value),
                                exc_info=True)
            return widget.do_create_wxpg_property(state, value, fallback=True)

    def on_double_click(self, evt):
        """On double click on a property, replace the property with a new
        property for the corresponding slot, which is now forced to evaluate.
        """
        prop = self._get_evt_property(evt)
        if prop is None:
            return

        widget = prop.GetAttribute(PROPATTR_WIDGET)

        obj, key = widget.obj, widget.key

        if widget.evaluable and isinstance(obj, AbstractBase):
            if widget.state is Widget.UNEVALUATED:
                new_state, value = self._compute(obj, key, eager=True)

                if new_state in WIDGET_ERROR_STATES:
                    # if not error state, update done in post_refresh_event()
                    self._popup_exception(value)

                # general refresh required because other slots may have been
                # touched. However, preserve error state in the refresh to
                # not have this widget (potentially now in error state) lose
                # it error view at refresh(). However, the refresh will also
                # keep the error states of other slots. Corner case: when
                # this slot led to side effects, viz. the *setting* of other
                # slots, other slots in error state may actually have become
                # valid. The risk of inconsistency in the view is however
                # accepted (side-effecting is not recommended practice) and
                # user can always hit the general refresh button.
                self.post_refresh_event(preserve_error_states=True)

                # ATTENTION: if current widget is in error state, refresh
                # didn't update it yet, so do it now. We only update
                # the widget when all pending Events (including refresh) are
                # finished (using .CallAfter) to avoid crash of wxPython
                if new_state in WIDGET_ERROR_STATES:
                    wx.CallAfter(self.update_widget, widget, new_state, value)

                return

        self.display_child(key)

    def on_right_click(self, evt):
        prop = self._get_evt_property(evt)
        if prop is None:
            return

        widget = prop.GetAttribute(PROPATTR_WIDGET)
        if widget.state is Widget.UNEVALUATED:
            return

        key, value = widget.key, widget.value

        path = self.path + (key,)
        enable_draw_items = widget.state not in WIDGET_ERROR_STATES

        menu = self.init_context_menu(value, key, path,
                                      enable_draw_items=enable_draw_items)
        self.PopupMenu(menu)

    def on_right_click_text_repr(self, evt):
        key = None  # not relevant: inspect / invalidate are invalidated
        menu = self.init_context_menu(self.obj, key, self.path,
                                      enable_slot_items=False)
        self.PopupMenu(menu)

    def init_context_menu(self, obj, key, path,
                          enable_draw_items=True, enable_slot_items=True):
        """Return right-click context menu.

        :param obj: obj on which is right-clicked
        :param key: child key of this object as seen from ``obj`` which
            contains this slot. When ``enable_slot_items`` is ``False``,
            this value can be safely set to ``None``.
        :param path: full path from root object
        :param bool enable_draw_items: enable display / hide items?
        :param bool enable_slot_items: enable inspect / invalidate items?
        :rtype: DataContextMenu
        """
        menu = self.context_menu
        menu._set_okp(obj, key, path)
        custom_item_ids = {menu.invalidate_item_id, menu.inspect_item_id}
        for item in menu.MenuItems:
            item_id = item.GetId()
            if item_id in custom_item_ids:
                item.Enable(enable_slot_items)
            else:
                item.Enable(enable_draw_items)
        return menu

    def on_property_value_changing(self, evt):
        user_value = evt.GetPropertyValue()
        prop = self._get_evt_property(evt)

        if not prop:
            return

        widget = prop.GetAttribute(PROPATTR_WIDGET)
        obj, attr = widget.obj, widget.name

        try:
            value = widget.do_wx_to_py_value(user_value)
        except Exception as e:
            msg = str(e)
            self._log_exception_from_user_value(evt, msg, prop, user_value)
            evt.Veto()
            return  # do not proceed with next steps

        try:
            setattr(obj, attr, value)
        except Exception as e:
            # ValidationError could come from anywhere, make sure it came
            # from the current widget (and not a precedent slot).
            if (isinstance(e, ValidationError)
                    and e.obj is obj and e.slot is widget.slot):
                msg = "Validation error: {}".format(e.message or str(e))
            else:
                msg = "Error: {}".format(e)

            self._log_exception_from_user_value(evt, msg, prop, user_value)
            evt.Veto()

        # setting value (successful or not) may have triggered other slots
        self.post_refresh_event()

    def _log_exception(self, msg, **kwargs):
        if self.LOG_EXCEPTIONS:
            logger.warning(msg, **kwargs)

    def _popup_exception(self, e):
        if self.POPUP_EXCEPTIONS:
            try:
                title = type(e).__name__
            except Exception:
                title = "Exception"
            popup(title, str(e), cancel_button=False)

    def _log_exception_from_user_value(self, evt, msg, prop, user_value):
        """Logs error to console and control showing of popup.

        :type evt: wx.propgrid.PropertyGridEvent
        :type msg: str
        """
        self._log_exception(msg)

        flags = self._get_pg_vfb_flags(prop, user_value)
        wx34.SetValidationFailureBehavior(evt, flags)
        evt.SetValidationFailureMessage(msg)

    def _get_pg_vfb_flags(self, prop, user_value):
        flags = wxpg.PG_VFB_DEFAULT

        if self.POPUP_EXCEPTIONS:
            # did it already contain an invalid value?
            was_invalid = prop.GetFlags() & wxpg.PG_PROP_INVALID_VALUE
            if was_invalid:
                # get the user value from when it was previously invalid
                prev_user_value = prop.GetAttribute(
                    PROPATTR_PREV_INVALID_VALUE)
                if prev_user_value == user_value:
                    if not self.grid.IsEditorFocused():
                        # we clicked out of the property grid, and want
                        # to mimick behavior of what wx does when we select
                        # a different property: we do not show a popup
                        # We only override behavior in this case because if we
                        # would always disable the message box on equal
                        # invalid value, pressing enter/return would not
                        # generate a pop-up each time
                        flags &= ~wxpg.PG_VFB_SHOW_MESSAGEBOX

                # TODO (TBD): Find a fix for the code below. Currently it
                #  wouid cause the whole property to stay marked red until it
                #  is invalidated or a good value is set. However,
                #  this behavior is only happening when setting an invalid
                #  value twice.
                # else:
                #     # Need to reset invalid state, otherwise wx will not show
                #     # a popup after the first invalid value after we click
                #     # somewhere else in the grid
                #     prop.SetFlagRecursively(wxpg.PG_PROP_INVALID_VALUE, False)
        else:  # we do not want to popup anyway
            flags &= ~wxpg.PG_VFB_SHOW_MESSAGEBOX
            # when hitting TAB, no visual cue, use flag below?
            # flags += wxpg.PG_VFB_STAY_IN_PROPERTY

        # store the user value so we can compare it next time
        prop.SetAttribute(PROPATTR_PREV_INVALID_VALUE, user_value)

        return flags

    def _get_evt_property(self, evt):
        """:rtype: wx.propgrid.PGProperty"""
        prop = evt.GetProperty()
        if not prop:
            return None
        obj = self.obj
        if isinstance(obj, AbstractBase):
            # check to see if category was clicked.
            if not prop.GetName() in obj._slots:
                return None
        return prop


class DataContextMenu(DisplayContextMenu):
    key = None

    def __init__(self, parent=None, obj=None, path=None,
                 add_default_items=True):
        super(DataContextMenu, self).__init__(
            parent=parent, obj=obj, path=path,
            add_default_items=add_default_items)

    def append_default_items(self, standard=False):

        self.append_default_display_items(standard=standard)
        self.append_separator(standard=standard)

        if running_IPython():
            self.append_item(
                "Bind to self (IPython)", icon="inspect.gif",
                handler=self.on_bind_self, standard=standard)

        item = self.append_item(
            "Inspect", icon="inspect.gif", handler=self.on_inspect,
            standard=standard)
        self.inspect_item_id = item.GetId()

        self.append_separator(standard=standard)
        item = self.append_item(
            "Invalidate", icon="trash.png", handler=self.on_invalidate,
            standard=standard)
        self.invalidate_item_id = item.GetId()

        self.append_item(
            "Copy value to clipboard", icon="base.png",
            handler=self.on_copy_to_clipboard, standard=standard)

    # ------------- event handlers --------------
    def on_inspect(self, evt):
        self.parent.display_child(self.key)

    def on_copy_to_clipboard(self, evt):
        try:
            text_val = str(self.obj)
        except Exception as e:
            msg = f"Cannot copy object to clipboard: failed converting " \
                  f"the object at {self.path} to string. " \
                  f"(encapsulated error: {e})"
            logger.warning(msg)
            return

        with Clipboard() as c:
            c.write(text_val)

    def on_invalidate(self, evt):
        self.parent.invalidate(self.key)

    # ------------- private methods -------------
    def _set_okp(self, obj, key, path):
        """Eases setting of three attributes at once."""
        self.obj = obj
        self.key = key
        self.path = path


def pretty_path(path):
    return "".join("[" + str(t) + "]" if isinstance(t, int) else "." + str(t)
                   for t in path) or "."
