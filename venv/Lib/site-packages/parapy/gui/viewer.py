#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""The Viewer object can draw and erase objects. Moreover, it can listen and
respond to changes in style and shape. In can not detect topology changes in
the product tree. This capability is introduced by the TreeViewerPanel object.
"""

import os
import weakref
from _weakrefset import WeakSet
from contextlib import contextmanager
from functools import partial
from typing import Set, Tuple, Union

import wx
from OCC.gui.events import (
    EVT_LEFT_CLICK_BACKGROUND as EVT_LEFT_CLICK_BACKGROUND_OCC,
    EVT_LEFT_CLICK_OBJECT as EVT_LEFT_CLICK_OBJECT_OCC,
    EVT_RIGHT_CLICK_BACKGROUND as EVT_RIGHT_CLICK_BACKGROUND_OCC,
    EVT_RIGHT_CLICK_OBJECT as EVT_RIGHT_CLICK_OBJECT_OCC,
    create_left_click_object_event as occ_create_left_click_object_event)
from OCC.gui.viewer import Viewer as OCC_Viewer
from OCC.gui.viewer_and_toolbar import ToolBarPanel

from parapy.config import CONFIGURATION as CONF
from parapy.core import Attribute, Base, Input
from parapy.core.abstract import DrawableParaPyObject
from parapy.core.globs import Undefined
from parapy.core.utilities import lazy_hasattr, is_iterable  # noqa
from parapy.geom import Point, Vector
from parapy.geom.generic.utilities import plane_line_intersection
from parapy.geom.occ.utilities import is_shape_like
from parapy.gui.camera import MinimalCamera
from parapy.gui.dialogs import (
    AppearanceDialog, BackgroundGridDialog, ObjectSelectionDialog)
from parapy.gui.events import (
    EVT_RIGHT_CLICK_OBJECT, create_left_click_background_event,
    create_left_click_object_event, create_right_click_background_event,
    create_right_click_object_event, create_tooltip_event)
from parapy.gui.globs import ICN_DIR
from parapy.gui.logger import logger
from parapy.gui.utilities import truncate
from parapy.gui.viewer_patch import apply_patch
from parapy.utilities import deprecated

apply_patch()


class UnmanagedDisplayObject(object):
    def __init__(self, obj):
        self.obj = obj

    def __repr__(self):
        # str.format() does not allow hex style like this.
        return "<%s %s at 0x%x>" % (type(self).__name__, repr(self.obj),
                                    id(self))


# TODO (RvD): Get rid of all self._dct_pp_occ.get(obj, None) stuff.
class Viewer(wx.Panel):
    """The Viewer object can draw and erase objects. Moreover, it can listen
    and respond to changes in style and shape. In can not detect topology
    changes in the product tree. This capability is introduced by the
    :class:`~parapy.gui.tree_viewer.TreeViewerPanel` class.
    """
    GRID_SHOW = CONF.getboolean("gui.viewport.grid", "show")
    GRID_XORIG = CONF.getfloat("gui.viewport.grid", "xorig")
    GRID_YORIG = CONF.getfloat("gui.viewport.grid", "yorig")
    # TODO (RvD): expose option in config.ini.
    GRID_ZORIG = 0.0
    # TODO (RvD): expose this in dialog
    GRID_ANGLE = CONF.getfloat("gui.viewport.grid", "angle")
    GRID_WIDTH = CONF.getfloat("gui.viewport.grid", "width")
    GRID_LENGTH = CONF.getfloat("gui.viewport.grid", "length")
    GRID_XSTEP = CONF.getfloat("gui.viewport.grid", "xstep")
    GRID_YSTEP = CONF.getfloat("gui.viewport.grid", "ystep")

    #: print str of selected objects to console
    PRINT_SELECTION_IN_CONSOLE = CONF.getboolean("gui",
                                                 "print_selection_in_console")
    #: nb to characters to truncate long repr() at when displaying slot
    #: values. Put to None, to suppress truncation.
    REPR_LIMIT = 5 * 79
    #: open the grid dialog on right-click of background
    SHOW_GRID_DIALOG_ON_RIGHT_CLICK_BACKGROUND = True
    #: open the appearance dialog on right-click of background
    SHOW_APPEARANCE_DIALOG_ON_RIGHT_CLICK_OBJECT = True

    #: Show tooltip when hovering over objects in viewer
    SHOW_TOOLTIP = CONF.getboolean("gui.viewport.tooltip", "show")

    #: Delay in milliseconds after which the tooltip is shown
    TOOLTIP_DELAY = CONF.getfloat("gui.viewport.tooltip", "delay")

    #: Maximum width in pixels of the object tooltip window. Set to a very
    #: large value to avoid wrapping the tooltip message
    TOOLTIP_MAXIMUM_WIDTH = 500

    ColorType = Union[str, int, Tuple[int, int, int]]

    def __init__(self, parent):
        wx.Panel.__init__(self, parent)

        #: :type: OCC.gui.viewer.Viewer
        self._occ_viewer = occ_viewer = OCC_Viewer(self)
        #: :type: OCC.gui.viewer_and_toolbar.ToolBarPanel
        self.toolbar = ToolBarPanel(self)
        #: :type: AppearanceDialog
        self.dlg_appearance = None
        #: :type: BackgroundGridDialog
        self.dlg_background_grid = None
        #: :type: dict[parapy.core.base.DrawableBase, ViewWrapper]
        self.listeners = {}
        #: dictionary: {ParaPyObject : Handle_AIS_InteractiveObject}
        self._dct_pp_occ = {}
        #: dictionary: {Handle_AIS_InteractiveObject : ParaPyObject}
        self._dct_occ_pp = {}
        #: dictionary: {DrawableShape: previous style}
        self.style_updates = {}
        #: dictionary: {DrawableShape: previous Handle_AIS_InteractiveObject}
        self.shape_updates = {}
        #: has this viewer ever displayed?
        self._has_displayed = False

        self._manipulations = WeakSet()

        occ_viewer.Bind(EVT_RIGHT_CLICK_BACKGROUND_OCC,
                        self.OnRightClickBackground)
        occ_viewer.Bind(EVT_RIGHT_CLICK_OBJECT_OCC,
                        self._on_occ_right_click_object)
        occ_viewer.Bind(EVT_LEFT_CLICK_BACKGROUND_OCC,
                        self.OnLeftClickBackground)
        occ_viewer.Bind(EVT_LEFT_CLICK_OBJECT_OCC, self.OnLeftClickObject)
        occ_viewer.Bind(wx.EVT_MOUSE_EVENTS, self._on_occ_mouse_events)
        occ_viewer.Bind(wx.EVT_LEFT_UP, self._on_occ_left_up)

        self.Bind(wx.EVT_WINDOW_DESTROY, self.on_destroy)
        self.Bind(EVT_RIGHT_CLICK_OBJECT, self.on_right_click_object)

        self.init_appearence_dialog()
        self.init_background_grid_dialog()
        self.init_toolbar()
        self.init_layout()

        self._tooltip_timer = wx.Timer(self)
        self.Bind(wx.EVT_TIMER, self._on_tooltip_timer)

    def _on_occ_left_up(self, evt):
        # TODO might be better to move this (or similar) behaviour
        #  to OCC.gui.viewer.Viewer
        if evt.controlDown:
            occ_viewer = self._occ_viewer
            # might not be needed, but the occ-viewer seems to do the same:
            mouse_pos = evt.Position
            occ_viewer.move_to(*mouse_pos)
            if (occ_viewer._dragged or
                    not next(occ_viewer.yield_detected(), False)):
                evt.Skip()  # background click or dragging
                return

            occ_viewer.left_m_down = False  # done by occ-viewer
            choices = self.detected
            with ObjectSelectionDialog(self, viewer=self, show_buttons=False,
                                       choices=choices) as dlg:
                self._position_dialog(dlg, mouse_pos)
                code = dlg.ShowModal()

                if code == wx.ID_OK:
                    selected = dlg.get_values()
                    for obj in selected:
                        self.select(obj, shift=evt.shiftDown)

                    # emulate the occ-viewer selection event
                    nb_selected = occ_viewer.nb_selected
                    if nb_selected > 0:
                        multiple = nb_selected > 1
                        evt = occ_create_left_click_object_event(
                            evt.Position, occ_viewer.yield_selected(),
                            multiple=multiple)
                        wx.PostEvent(occ_viewer, evt)

                # need to update the selection, otherwise the selected objects
                # will not show visually that they are selected anymore
                occ_viewer.update_selected(True)
        else:
            evt.Skip()

    def on_destroy(self, evt=None):
        self._remove_all_local()

    def init_layout(self):
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(self._occ_viewer, 1, wx.EXPAND, 0)
        sizer.Add(self.toolbar, 0, wx.EXPAND, 0)
        self.SetSizer(sizer)
        self.Layout()

    def init_toolbar(self):
        toolbar = self.toolbar
        toolbar.bind_viewer(self._occ_viewer)

        # add 2 buttons to the toolbar
        toolbar.btn_delete_all = toolbar.add_tool(
            "delete", os.path.join(ICN_DIR, "trash.png"), "delete all")
        toolbar.btn_refresh = toolbar.add_tool(
            "refresh", os.path.join(ICN_DIR, "refresh.png"), "refresh")

        toolbar.Bind(wx.EVT_TOOL, lambda _: self.remove_all(),
                     id=toolbar.btn_delete_all.GetId())
        toolbar.Bind(wx.EVT_TOOL, lambda _: self.refresh(),
                     id=toolbar.btn_refresh.GetId())

        toolbar.wx_toolbar.Realize()

    def init_appearence_dialog(self):
        self.dlg_appearance = AppearanceDialog(self)

    def init_background_grid_dialog(self):
        self.dlg_background_grid = BackgroundGridDialog(
            self, self.GRID_SHOW, self.GRID_XORIG, self.GRID_YORIG,
            self.GRID_ZORIG, self.GRID_WIDTH, self.GRID_LENGTH,
            self.GRID_XSTEP, self.GRID_YSTEP)

    def _position_dialog(self, dlg, pos):
        """Implements the functionality of
        wxPropertyGrid::GetGoodEditorDialogPosition. pos is expected to be
        in local window xy_coordinates. Returns Screen xy_coordinates
        """
        x, y = pos
        w_pnl, h_pnl = self.GetSize()
        w_dlg, h_dlg = dlg.GetSize()
        if x + w_dlg > w_pnl:
            x = w_pnl - w_dlg
        if y + h_dlg > h_pnl:
            y = h_pnl - h_dlg
        x, y = self.ClientToScreen((x, y))
        dlg.Move((x, y))

    def OnLeftClickBackground(self, evt):
        pos = evt.pos
        evt = create_left_click_background_event(self, pos)
        wx.PostEvent(self, evt)

    def OnRightClickBackground(self, evt):
        pos = evt.pos

        if self.SHOW_GRID_DIALOG_ON_RIGHT_CLICK_BACKGROUND:
            dlg = self.dlg_background_grid
            self._position_dialog(dlg, pos)

            exit_code = dlg.ShowModal()
            # Let's check if user clicked OK, RESET, or pressed CANCEL, etc.
            if exit_code == wx.ID_OK:
                show, xorig, yorig, zorig, width, length, xstep, ystep = \
                    dlg.get_values()
                if show:
                    self._occ_viewer.activate_grid(xorig, yorig, zorig, width,
                                                   length, xstep, ystep)
                else:
                    self._occ_viewer.deactivate_grid()
            dlg.Hide()

        evt = create_right_click_background_event(self, pos)
        wx.PostEvent(self, evt)

    def _on_tooltip_timer(self, evt):
        self._post_tooltip_event()

    def _post_tooltip_event(self):
        detected = self.detected
        if detected:
            evt = create_tooltip_event(self, detected=detected)
            wx.PostEvent(self, evt)

    def show_tooltip_obj(self, obj):
        msg = obj.tooltip if lazy_hasattr(obj, 'tooltip') else None
        if msg:
            self.show_tooltip(msg)

    def show_tooltip(self, msg):
        # set on MainWindow else get problem with AIS shape
        parent = self.GetTopLevelParent()
        tooltip = wx.TipWindow(parent, msg,
                               maxLength=self.TOOLTIP_MAXIMUM_WIDTH)
        # if mouse goes out of a 1x1 square in (0, 0), the tooltip
        # disappears, i.e., the tooltip disappears as soon as the mouse
        # moves.
        tooltip.SetBoundingRect(wx.Rect(0, 0, 1, 1))

    def _on_occ_mouse_events(self, evt):
        # Any mouse event (zoom, mouse clicks) should stop the timer
        self._tooltip_timer.Stop()
        # The tooltip appears if the mouse does not move for given delay
        # If the mouse is only hovering, then we can start the timer
        if evt.EventType == wx.wxEVT_MOTION:
            self._tooltip_timer.Start(milliseconds=self.TOOLTIP_DELAY,
                                      oneShot=wx.TIMER_ONE_SHOT)
        evt.Skip()  # to propagate event to OCC_Viewer

    def OnLeftClickObject(self, evt):
        pos, selected, multiple = evt.pos, evt.selected, evt.multiple

        # convert to ParaPy objects
        selected = tuple(self._convert_occ_pp(selected))

        if self.PRINT_SELECTION_IN_CONSOLE:
            nb = len(selected)
            tail = truncate(repr(selected),
                            self.REPR_LIMIT)
            print("Selected {} object{}: {}".format(
                nb, '' if nb == 1 else 's', tail))

        evt = create_left_click_object_event(self, pos, selected, multiple)
        wx.PostEvent(self, evt)

    # TODO (TBD): Add visual cues in dialog for dissimilar styling values
    def _on_occ_right_click_object(self, evt):
        pos, selected, multiple = evt.pos, tuple(evt.selected), evt.multiple
        selected = tuple(self._convert_occ_pp(selected))

        evt = create_right_click_object_event(self, pos, tuple(selected),
                                              multiple)
        wx.PostEvent(self, evt)

    def on_right_click_object(self, evt):
        # this ensures that the behavior can be toggled at runtime
        # alternative would be to bind/unbind event handlers
        if self.SHOW_APPEARANCE_DIALOG_ON_RIGHT_CLICK_OBJECT:
            self.show_appearance_dialog(evt.pos, evt.selected)
        else:
            evt.Skip()

    # TODO (TBD): Add visual cues in dialog for dissimilar styling values
    def show_appearance_dialog(self, pos, selected):
        dlg = self.dlg_appearance
        self._position_dialog(dlg, pos)
        context = self._occ_viewer

        # NOTE: by the double conversion we probably lost the
        # power to style 'unmanaged' display objects. However, putting
        # this as an event handler allows us to be Skipped by other
        # events, which would improve usability
        ais_objs = list(map(self._dct_pp_occ.get, selected))

        # merge values of multiple objects
        get_style = context.get_style
        style = get_style(ais_objs[0])
        for ais in ais_objs[1:]:
            style_ = get_style(ais)
            for k, v in style_.items():
                if style[k] != v:
                    style[k] = None

        dlg.set_values(**style)

        exit_code = dlg.ShowModal()

        if exit_code == wx.ID_OK:
            settings = dlg.get_values_changed()
            if settings:
                for ais in ais_objs:
                    context.apply_style(ais, update=False, **settings)
                self.update()

        elif exit_code == wx.ID_RESET:
            for obj in selected:
                if obj:
                    self._reset_style(obj, context, update=False)
            self.update()

        dlg.Hide()

    def reset_style(self, obj, update=True):
        self._reset_style(obj, self._occ_viewer, update=update)

    def _reset_style(self, obj, context, update=True):
        ais = self._get_ais(obj)
        listener = self.listeners.get(obj, None)
        if listener is None:
            context.reset_style(ais, update=update)
        else:
            context.reset_style(ais, update=False)
            style = listener._display_style
            if style:
                self._occ_viewer.apply_style(ais, update=update, **style)

    def refresh(self, update=False, fit=False, update_indiv=False):
        """update Base object style, update children"""
        context = self._occ_viewer

        # Children updates
        for obj, old_ais in self.shape_updates.items():
            # print "updating shape of '%s'" % obj.refchain
            if old_ais is None:  # was removed, need to re-display
                self._display_obj(obj, context, update=update_indiv)
            else:  # was displayed, we need to update
                self._update_shape(obj, old_ais, context, update=update_indiv)
        self.shape_updates.clear()

        # Style update
        for obj, old_style in self.style_updates.items():
            # print "style of '%s' changed" % obj.refchain
            self._update_style(obj, old_style, context, update=update_indiv)
        self.style_updates.clear()

        if fit:
            self.fit_all()
        elif update:
            self.update()
            self._update_selector()

    # TODO (TBD): optimize display_context, make input
    def _update_shape(self, obj, old_ais, context, update=False):
        """Update a DrawableShape's AIS_InteractiveObject. This involves
        removing obj from all caches and redrawing it it currently displayed.

        :type context: OCC.AIS.AIS_InteractiveContext
        """
        if obj in self.listeners:
            # if old_ais is None, previous evaluation failed
            if old_ais:
                # new_handle = listener._Handle_AIS_InteractiveObject
                if context.is_displayed(old_ais):
                    self._remove_obj(obj, context)  # do not update twice
                    self._display_obj(obj, context, update=update)
                else:
                    self._remove_obj(obj, context, update=update)

    # TODO (TBD): re-consider update override logic.
    def _update_style(self, obj, old_style, context, reset=False,
                      update=False):
        listener = self.listeners.get(obj, None)
        if listener is not None:
            new_style = listener._display_style
            # keep styling keys if key is new or value changed
            if old_style:
                new_style = dict((k, v) for k, v in new_style.items() if
                                 k not in old_style or v != old_style[k])
            ais = self._dct_pp_occ[obj]

            if reset:
                context.reset_style(ais, update=update)

            # easy out
            if not new_style:
                return

            context.apply_style(ais, update=update, **new_style)

    def _ais_to_pp(self, ais, on_fail='wrap', default_value=Undefined):
        ais_to_pp = self._dct_occ_pp
        try:
            return ais_to_pp[ais]
        except KeyError:
            logger.warning(f"Failed to find ParaPy object related to: {ais!r}")
            if on_fail == 'wrap':
                return UnmanagedDisplayObject(ais)
            elif on_fail == 'ignore':
                return None
            elif on_fail == 'default':
                return default_value
            elif on_fail == 'raise':
                raise
            else:
                raise ValueError(f"Unknown setting for on_fail: {on_fail}! "
                                 f"Valid options are 'wrap', 'ignore', "
                                 f"'default' or 'raise'. Object: {self!r}")

    def _convert_occ_pp(self, iterable, on_fail='wrap',
                        default_value=Undefined, double=False):
        """Convert an ``iterable`` of Handle_AIS_InteractiveObject into ParaPy
        objects.

        >>> iterable = [<Handle_AIS_InteractiveObject ...>, ...]
        >>> list(self._convert_occ_pp(iterable))
        [<DrawableParaPyObject ...>, ...]
        >>> list(self._convert_occ_pp(iterable), double=True)
        [(<DrawableParaPyObject ...>, <Handle_AIS_InteractiveObject ...>), ...]

        :param collections.Iterable[
        OCC.wrapper.AIS.Handle_AIS_InteractiveObject] iterable: objects
            to convert
        :param str on_fail: Defines what should happen when it is not possible
            to convert the result to a ParaPy object. When set to `'wrap'`,
            the object will be wrapped in an :class:`UnmanagedDisplayObject`.
            When set to `'default'`, `default_value` will be returned instead.
            The other options `raise` and `ignore` speak for themselves.
            (Default: `'wrap'`)
        :param bool double: Include the converted AIS object in the result?
            (Default: `False`)
        :param default_value: The value to be returned when
            `on_fail=='default'` and conversion fails. (Default: `Undefined`)
        :rtype: collections.Iterable[T] | collections.Iterable[(T,
        OCC.wrapper.AIS.Handle_AIS_InteractiveObject)]
        :raises KeyError: if `on_fail=='raise'` and conversion failed
        :raises ValueError: if `on_fail` has an unsupported value
        """
        ais_to_pp = partial(self._ais_to_pp, on_fail=on_fail,
                            default_value=default_value)

        if double:
            for ais in iterable:
                pp = ais_to_pp(ais)
                if pp is None and on_fail == 'ignore':
                    continue
                else:
                    yield pp, ais
        else:
            pp_objs = map(ais_to_pp, iterable)
            if on_fail == 'ignore':
                yield from filter(lambda x: x is not None, pp_objs)
            else:
                yield from pp_objs

    def display(self, objects, update=False, fit=False, update_indiv=False):
        """objects is an iterable of multiple objects"""
        context = self._occ_viewer

        f_display = self._display_obj
        for obj in objects:
            f_display(obj, context, update=update_indiv)

        if objects and not fit and not self._has_displayed:
            fit = True
            self._has_displayed = True

        if fit:
            self.fit_all()
        elif update:
            self.update()

    def _display_obj(self, obj, context, update=False, fit=False):
        """Method to display single DrawableParaPyObject in viewer. will
        re-use a cache if available, otherwise will create a new
        Handle_AIS_InteractiveObject and intercept any errors for geometry or
        display_style.

        :type context: OCC.gui.viewer.Viewer | None
        """
        if not isinstance(obj, DrawableParaPyObject):
            raise RuntimeError("Object {:} isn't drawable".format(repr(obj)))

        # if cache, do not recompute
        dct_pp_occ = self._dct_pp_occ
        ais = dct_pp_occ.get(obj, None)

        if ais is None:
            # print "GUI: new to shape to draw:", ob
            if isinstance(obj, Base):  # dependency tracking required
                listeners = self.listeners
                listener = listeners.get(obj)  # it might already be there
                if listener is None:  # if not, create a new wrapper
                    listener = ViewWrapper(viewer=self, obj=obj)
                    self.listeners[obj] = listener

                ais = listener._Handle_AIS_InteractiveObject
                if ais is None:
                    return  # there is an exception, don't cache

                style = listener._display_style
                if style:
                    self._occ_viewer.apply_style(ais, update=False, **style)
            else:  # no dependency tracking needed.
                try:
                    ais = obj._Handle_AIS_InteractiveObject
                except Exception as e:
                    msg = ("GUI: failure on '_Handle_AIS_InteractiveObject' "
                           "for object {:}\n.Message: '{:}'")
                    print(msg.format(repr(obj), e))
                    return
                else:
                    color = obj.color
                    self._occ_viewer.apply_style(ais, update=False,
                                                 color=color)

        # redisplaying already displayed shape, is fine.
        context.display(ais, update=update, fit=fit)

        # safe to cache it
        dct_pp_occ[obj] = ais
        self._dct_occ_pp[ais] = obj

    def hide(self, objects, update=False, fit=False, update_indiv=False):
        """Hide objects."""
        dct_pp_occ = self._dct_pp_occ

        f_hide = self._occ_viewer.hide
        for obj in objects:
            ais = dct_pp_occ.get(obj, None)
            if ais is not None:
                f_hide(ais, update=False, fit=False)
        if fit:
            self.fit_all()
        elif update:
            self.update()

    def deselect_all(self, update=True):
        self._occ_viewer.deselect_all(update=update)

    def hide_selected_objects(self, update=False, fit=False):
        self._occ_viewer.hide_selected_objects(update=update, fit=fit)

    def hide_all(self, update=True):
        # wraps OCC.Viewer.hide_selected_objects() with cache management
        self._occ_viewer.hide_all(update)

    def remove(self, objects, update=False, fit=False, update_indiv=False):
        """stop tracking object(s) completely, they were deleted,
        objects is one object or an iterable of multiple objects
        """
        context = self._occ_viewer
        for obj in objects:
            self._remove_obj(obj, context, update=update_indiv)
        if fit:
            self.fit_all()
        elif update:
            self.update()

    def _remove_obj(self, obj, context, update=False, fit=False):
        """
        :type context: OCC.gui.viewer.Viewer | None
        """
        ais = self._dct_pp_occ.pop(obj, None)
        if ais is not None:
            self._dct_occ_pp.pop(ais, None)
            context.remove(ais, update=update, fit=fit)
        self.listeners.pop(obj, None)

    def unregister_listeners(self):
        for listener in self.listeners.values():
            listener.unregister()

    def remove_all(self, update=True):
        # remove all objects, it's like a full reset
        # self.unhighlight_all(update=False)
        self._occ_viewer.remove_all(update)
        self._remove_all_local()

    def _remove_all_local(self):
        self.unregister_listeners()
        self.listeners.clear()
        self._dct_occ_pp.clear()
        self._dct_pp_occ.clear()
        self.shape_updates.clear()
        self.style_updates.clear()

    def highlight(self, obj: DrawableParaPyObject, color: ColorType = None,
                  fill_color: ColorType = None, display_mode: str = None,
                  ensure_visible: bool = False, update: bool = True) -> bool:
        """Highlight ``obj`` in 3d Viewer with custom ``color``. Return
        `False` if ``obj`` hasn't been displayed before or if it
        is `in_viewer` but hidden and `ensure_visible` is `False`,
        else `True`.

        :param obj: object to highlight
        :param color: highlighting color or `None` to use the default color.
            (Default: `None`)
        :param fill_color: The color the faces should get on highlighting
            (does not work with an edges-only `display_mode` like `wireframe`)
        :param str display_mode: How should the object be displayed on
            highlighting? In addition to 'wireframe' and 'shaded', there is
            also a 'default' display mode which defaults to the currently
            active Viewer display_mode. (Default: `None` which implies
            'wireframe')
        :param ensure_visible: If set to `True` will display the object if
            it is hidden. (Default: `False`)
        :param update: update viewer immediately? (Default: `True`)
        """
        ais_handle = self._dct_pp_occ.get(obj, None)
        if ais_handle:
            return self._occ_viewer.highlight(
                ais_handle, color=color, ensure_visible=ensure_visible,
                fill_color=fill_color, display_mode=display_mode,
                update=update)
        else:
            return False

    def unhighlight(self, obj: DrawableParaPyObject,
                    update: bool = True) -> bool:
        """Unhighlight ``obj`` in 3d Viewer. Returns `False` if ``obj`` hasn't
        been displayed before or wasn't highlighted, else `True`.

        :param obj: object to unhighlight
        :param update: update viewer immediately? (Default: `True`)
        """
        ais_handle = self._dct_pp_occ.get(obj, None)
        if ais_handle:
            return self._occ_viewer.unhighlight(ais_handle, update=update)
        else:
            return False

    def select(self, obj, *args, **kwargs):
        ais_handle = self._dct_pp_occ.get(obj, None)
        if ais_handle:
            self._occ_viewer.select(ais_handle, *args, **kwargs)

    def unhighlight_all(self, update=True):
        # FIXME: This leaves a wireframe representation hanging in the viewer
        self._occ_viewer.unhighlight_all(update=update)

    def fit_all(self):
        self._occ_viewer.fit_all()

    def update(self):
        self._occ_viewer.update()

    def _update_selector(self):
        """Update what is selected/detected under the mouse.
        This makes sure :attr:`detected` and :attr:`selected` are up-to-date
        after, for instance, changing the contents of the Viewer.

        .. note:: Unless you modify the contents of the Viewer through the
            `raw` :class:`~OCC.gui.viewer.Viewer` class, there should be no
            need to call this method directly.
        """
        self._occ_viewer.update_selector()

    @property
    def detected(self):
        """List all detected objects under the mouse in viewer.

        :rtype: list[DrawableParaPyObject]
        """
        return list(self.yield_detected())

    @property
    def selected(self):
        """List all selected objects in viewer.

        :rtype: list[DrawableParaPyObject]
        """
        return list(self.yield_selected())

    @property
    def displayed(self):
        """List all displayed objects in viewer.

        :rtype: list[DrawableParaPyObject]
        """
        return list(self.yield_displayed())

    def yield_detected(self):
        """Yield currently detected objects under the mouse in viewer.

        :rtype: collections.Iterable[DrawableParaPyObject]
        """
        detected_ais = self._occ_viewer.yield_detected()
        return self._convert_occ_pp(detected_ais)

    def _get_ais(self, obj):
        pp2occ = self._dct_pp_occ
        try:
            return pp2occ[obj]
        except KeyError:
            raise RuntimeError(f"Object {obj!r} has never been drawn "
                               f"before. Display it first! "
                               f"Object: {self!r}")

    def _conform_modes(self, modes):
        for mode in modes:
            if isinstance(mode, (str, int)):
                yield mode, None
            elif is_iterable(mode) and len(mode) == 2:
                yield mode
            else:
                raise ValueError(f"When specifying modes as an "
                                 f"iterable, each item should "
                                 f"consist from either a str/int or a "
                                 f"(str/int, obj) combination. "
                                 f"Got: {mode}. Object: {self!r}")

    @contextmanager
    def selection_mode(self, modes, force=False, restore_default=True):
        """A context in which one or multiple `modes` are activated and
        closed afterwards.

        .. note:: If you want to apply one selection mode `<mode>` on
        an object `obj`, you need to call it as if there would be multiple
        modes to apply (put a tuple in a list):

        `selection_mode([(<mode>, <obj>)])`

        :param modes: Either a string or int defining a mode, or an iterable
            of `str` and `int`, or `(Union[str, int], obj`)` tuples, where
            `obj` is the object on which the mode will be applied. Multiple
            modes applied to an object will stack.
        :param force:
        :param restore_default: Tries to restore the default selection mode.
            If, before the context, objects are in `default` selection mode,
            this mode will be restored after the context. If they would have
            another mode, for instance 'vertices' activated, that mode will
            be restored (it will not be forced to be 'default')
        """
        if isinstance(modes, (str, int)):
            self.activate_selection_mode(modes, force=force)
            try:
                yield  # wait for end of context
            finally:
                self.deactivate_selection_mode(modes)
                if restore_default:
                    self.activate_selection_mode()
        elif is_iterable(modes):
            to_restore = []
            try:
                for mode, obj in self._conform_modes(modes):
                    self.activate_selection_mode(mode=mode, obj=obj,
                                                 force=force)
                    to_restore.append((mode, obj))

                yield

            finally:
                for mode, obj in to_restore:
                    self.deactivate_selection_mode(mode=mode, obj=obj)
                if restore_default:
                    self.activate_selection_mode()
        else:
            raise TypeError(f"modes should be either a string or an "
                            f"iterable of str/int or (str/int, obj) tuples! "
                            f"Got: {modes}. Object: {self!r}")

    def activate_selection_mode(self, mode: Union[str, int] = "default",
                                obj: DrawableParaPyObject = None,
                                force: bool = False):
        """Activate a (sub-shape) selection mode for one or all objects
        currently in the viewer. Multiple modes can be activated at the
        same time.

        When calling this method without arguments, it resets the viewer to
        the default setting.

        :param mode: A string ('vertices', 'edges', ...., 'compounds' or
            'default') specifying the mode to be activated. Here
            'default' is the normal 'whole shape' selection mode.
            Alternatively specify an int, which will correspond to how it
            works in opencascade.
        :param obj: Object to activate the selection mode on. When not set,
            it will apply the selection mode on all objects currently
            displayed in the viewer.
        :param force:
        """
        ais_obj = None if obj is None else self._get_ais(obj)
        self._occ_viewer.activate_selection_mode(mode=mode, obj=ais_obj,
                                                 force=force)

    def deactivate_selection_mode(self, mode: Union[str, int] = None,
                                  obj: DrawableParaPyObject = None):
        """Deactivate a (sub-shape) selection mode for one or all objects
        currently in the viewer.

        When calling this method without arguments, it removes all selection
        modes, including the 'default' one, making all objects non-selectable.

        :param mode: A string ('vertices', 'edges', ...., 'compounds' or
            'default') specifying the mode to be deactivated. Here
            'default' is the normal 'whole shape' selection mode.
            Alternatively specify an int, which will correspond to how it
            works in opencascade.
        :param obj: Object to activate the selection mode on. When not set,
            it will deactivate the selection mode on all objects currently
            displayed in the viewer.
        """
        ais_obj = None if obj is None else self._get_ais(obj)
        self._occ_viewer.deactivate_selection_mode(mode=mode, obj=ais_obj)

    def get_active_selection_modes(self, obj) -> Set[str]:
        """Get the selection modes currently active on `obj`.

        .. note:: Currently only returns the modes as the names used
            by activate/ deactivate selection mode. Special modes not covered
            by these names, that would have been specified using integers,
            will appear as `None` in te end-results.
        """
        ais_obj = self._get_ais(obj)
        return self._occ_viewer.get_active_selection_modes(ais_obj)

    def yield_displayed(self):
        """Yield currently displayed objects in viewer.

        :rtype: collections.Iterable[DrawableParaPyObject]
        """
        displayed_ais = self._occ_viewer.yield_displayed()
        return self._convert_occ_pp(displayed_ais)

    def yield_hidden(self):
        """Yield currently displayed objects in viewer.

        :rtype: collections.Iterable[DrawableParaPyObject]
        """
        hidden_ais = self._occ_viewer.yield_hidden()
        return self._convert_occ_pp(hidden_ais)

    def yield_selected(self):
        """Yield currently selected objects in viewer.

        :rtype: collections.Iterable[DrawableParaPyObject]
        """
        selected_ais = self._occ_viewer.yield_selected()
        return self._convert_occ_pp(selected_ais)

    def yield_selected_with_owner(self):
        shape_and_owner = self._occ_viewer.yield_selected_with_owner()
        ais_to_pp = partial(self._ais_to_pp)
        for shape, owner in shape_and_owner:
            pp_owner = ais_to_pp(owner)
            if shape is not None:
                if is_shape_like(pp_owner):
                    # actually it is weird if a shape comes back, and pp_owner
                    # is not shape_like
                    if pp_owner.TopoDS_Shape.IsPartner(shape):
                        # no one needs a Solid instead of a Box
                        pp_shape = pp_owner
                    else:
                        pp_shape = pp_owner._TopoDS2Shape(shape)

                    yield pp_shape, pp_owner
                else:
                    logger.warning(f"Encountered a ParaPy object with "
                                   f"a selectable shape that is not a shape "
                                   f"itself. This should not happen... "
                                   f"Owner: {pp_owner!r}, Shape: {shape!r}. "
                                   f"Object: {self!r}")
                    yield pp_owner, pp_owner
            else:
                yield pp_owner, pp_owner

    @property
    def selected_with_owner(self):
        return list(self.yield_selected_with_owner())

    def is_displayed(self, obj: DrawableParaPyObject) -> bool:
        """Return `True` if ``obj`` is currenty displayed."""
        ais_handle = self._dct_pp_occ.get(obj, None)
        if ais_handle:
            return self._occ_viewer.is_displayed(ais_handle)
        else:
            return False

    def is_hidden(self, obj: DrawableParaPyObject) -> bool:
        """Return `True` if ``obj`` is currently in the GUI, but hidden."""
        ais_handle = self._dct_pp_occ.get(obj, None)
        if ais_handle:
            return self._occ_viewer.is_hidden(ais_handle)
        else:
            return False

    def in_viewer(self, obj: DrawableParaPyObject) -> bool:
        """Return `True` if `obj` is registered in this Viewer.

        .. note:: this can be `False` when one bypasses the parapy Viewer
            to display the shape by using the :attr:`_occ_viewer` directly.
            If this is the case, check if the used AIS object is in the
            :attr:`_occ_viewer`.
        """
        return obj in self._dct_pp_occ

    def is_highlighted(self, obj: DrawableParaPyObject) -> bool:
        """Return `True` if `obj` is in the GUI and highlighted."""
        ais_handle = self._dct_pp_occ.get(obj, None)
        if ais_handle:
            return self._occ_viewer.is_highlighted(ais_handle)
        return False

    def save_image(self, filename):
        """Dump the full contents of the view at the same scale in the
        file ``filename``. The file name extension must be one of
        'gif', 'bmp', 'jpg', 'png', 'pgf', 'ps', 'emf', 'svg', 'eps', 'tex',
        'pdf'. Returns False when the dump has failed.

        :param str filename: full pathname to image file.
        :rtype: bool
        """
        self._occ_viewer.save_image(filename)

    def get_camera(self):
        """Get the current camera.

        :rtype: parapy.gui.camera.MinimalCamera
        """
        return MinimalCamera.copy_from_camera(self._occ_viewer.camera)

    def set_camera(self, camera, update=True):
        """Set the Viewer its camera to ``camera``.

        :param MinimalCamera | OCC.gui.camera.Camera camera: camera to set
        :param bool update: Should we update the Viewer?
        """
        if isinstance(camera, MinimalCamera):
            camera = camera.occ_camera
        self._occ_viewer.set_camera(camera, update=update)

    def screen_to_world_point(self, x, y):
        """Project screen coordinates ``(x, y)`` onto the projection
        plane of the view.

        :param int x: mouse its x-coordinate in the Viewer.
        :param int y: mouse its y-coordinate in the Viewer.
        :rtype: Point
        """
        return self._screen_to_projection_plane(x, y)[0]

    def screen_to_distance_along_axis(self, x, y, axis_point, axis_direction,
                                      tolerance=1.0e-7):
        """Project screen coordinates ``(x, y)`` onto an axis defined
        by start point ``pt`` and direction ``v`` in world coordinates, return
        distance along axis.

        :param int x: mouse's x-coordinate in the Viewer screen.
        :param int y: mouse's y-coordinate in the Viewer screen.
        :param Point axis_point: start point of axis in world coordinates
        :param Vector axis_direction: direction of axis
        :param float tolerance: tolerance below which eye vector and
            ``axis_direction`` are consider parallel (and distance is ``0``).
        :rtype: float
        """
        proj_pt, proj_direction = self._screen_to_projection_plane(x, y)
        w = proj_pt - axis_point

        v_view = axis_direction.project_on_plane(proj_direction)
        v_view_norm = v_view.length

        if abs(v_view_norm) < tolerance:
            # v_view and proj_direction are parallel
            return 0.0

        return w * v_view * axis_direction.length / (v_view_norm * v_view_norm)

    def screen_to_point_on_axis(self, x, y, axis_point, axis_direction,
                                tolerance=1.0e-7):
        """Project screen coordinates ``(x, y)`` onto an axis defined
        by start point ``pt`` and direction ``v`` in world coordinates, return
        point on axis.

        :param int x: mouse's x-coordinate in the Viewer screen.
        :param int y: mouse's y-coordinate in the Viewer screen.
        :param Point axis_point: start point of axis in world coordinates
        :param Vector axis_direction: direction of axis
        :param float tolerance: tolerance below which eye vector and
            ``axis_direction`` are consider parallel (and distance is ``0``).
        :rtype: Point
        """
        distance = self.screen_to_distance_along_axis(
            x, y, axis_point, axis_direction, tolerance=tolerance)
        return axis_point.translate(axis_direction.normalized, distance)

    def screen_to_point_in_plane(self, x, y, plane_point, plane_normal):
        """Return the intersection point between a line defined by the view
        ray through the screen's ``(x, y)`` position, and a plane defined by
        ``plane_point`` and ``plane_normal``. The view ray is the direction
        in which the camera is currently looking.

        :param int x: mouse its x-coordinate in the Viewer.
        :param int y: mouse its y-coordinate in the Viewer.
        :param Point plane_point: a point which will lie on the plane.
        :param Vector plane_normal: Normal vector of the plane.
        :returns: The point on the plane, or :py:`None` if the
            viewing-direction is parallel to the provided plane.
        :rtype: Point | None
        """
        proj_pt, proj_direction = self._screen_to_projection_plane(x, y)
        return plane_line_intersection(plane_point, plane_normal,
                                       proj_pt, proj_direction)

    @deprecated(replaced_by="screen_to_point_in_plane")
    def mouse_to_world_coords(self, x, y, plane_point, plane_normal):
        return self.screen_to_point_in_plane(x, y, plane_point, plane_normal)

    def _screen_to_projection_plane(self, x, y):
        """Project screen coordinates ``(x, y)`` onto the projection
        plane of the view, and return eye vector for further computations.

        :param int x: mouse its x-coordinate in the Viewer.
        :param int y: mouse its y-coordinate in the Viewer.
        :rtype: (Point, Vector)
        """
        wx, wy, wz, vx, vy, vz = self._occ_viewer._v3d_view.ConvertWithProj(
            x, y)
        return Point(wx, wy, wz), Vector(vx, vy, vz)


class ViewWrapper(Base):
    """For each visualized object that is a DrawableShape instance, an
    associated Wrapper object is constructed that listens for changes to style
    and shape. Moreover, it catches exceptions, because the ParaPy GUI should
    not immediately fail when object attributes fail. Instead it should
    display a warning message to inform the user.
    """

    #: DrawableShape instance
    #: :type: parapy.geom.occ.drawable.DrawableShape
    obj = Input()
    #: owning Viewer object
    #: :type: parapy.gui.viewer.Viewer
    viewer = Input()

    @Attribute
    def _Handle_AIS_InteractiveObject(self):
        """Return handle or None (in case of failure).

        :rtype: OCC.AIS.Handle_AIS_InteractiveObject | None
        """
        obj = self.obj
        try:
            handle = obj._Handle_AIS_InteractiveObject
        except Exception as e:
            msg = "shape evaluation failed on object {:}"
            logger.warning(msg.format(repr(obj)), exc_info=True)
            return None
        else:
            return handle

    @Attribute
    def _display_style(self):
        """Slot that GUI "listens" to.

        :rtype: dict
        """
        obj = self.obj
        try:
            return obj._display_style()
        except Exception as e:
            msg = "Evaluation of one or more style attributes failed on {:}."
            logger.warning(msg.format(repr(obj)), exc_info=True)
            return {}

    @_Handle_AIS_InteractiveObject.on_slot_change
    def on_shape_change(self, slot, new, old):
        self.viewer.shape_updates[self.obj] = old

    @_display_style.on_slot_change
    def on_style_change(self, slot, new, old):
        self.viewer.style_updates[self.obj] = old

    # TODO (RvD): very hackish programming, think of better strategy.
    def unregister(self):
        # break link between caches surrounding
        # "_Handle_AIS_InteractiveObject", "_display_style" and their
        # precedents, otherwise invalidation of these might
        # trigger the on_slot_change listener to communicate with Viewer
        cache = self.get_cache("_Handle_AIS_InteractiveObject", eager=False)
        if cache:
            precs = cache.precedents
            while precs:
                precs.pop().dependents.remove(cache)
        cache = self.get_cache("_display_style", eager=False)
        if cache:
            precs = cache.precedents
            while precs:
                precs.pop().dependents.remove(cache)


class ViewerWindow(wx.Frame):
    def __init__(self, title="ParaPy Graphical User Interface"):
        wx.Frame.__init__(self, None, -1, title)

        self.viewer = Viewer(self)

        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(self.viewer, 1, wx.EXPAND)
        self.SetSizer(sizer)
        self.SetAutoLayout(True)
        sizer.Layout()

        # do this after V3D_View has been created...
        self.Show(True)


_created_viewers = list()


def living_viewers():
    global _created_viewers

    still_living = list()
    for weak_v in _created_viewers:
        viewer = weak_v()
        if viewer:
            still_living.append(weak_v)

    _created_viewers = still_living
    return len(still_living)


def register_viewer(viewer):
    _created_viewers.append(weakref.ref(viewer))


def unregister_viewer(viewer):
    for weak_v in _created_viewers:
        this_viewer = weak_v()
        if this_viewer and this_viewer == viewer:
            _created_viewers.remove(weak_v)


def destroy_registered_viewers():
    global _created_viewers
    for weak_v in _created_viewers:
        viewer = weak_v()
        if viewer:
            parent = viewer.GetParent()
            to_destroy = parent if parent else viewer
            to_destroy.DestroyChildren()
            to_destroy.Destroy()

    _created_viewers = list()


def new_viewer():
    """Create a new viewer in a frame.

    :rtype: Viewer
    """
    app = wx.GetApp() or wx.App(False)
    frame = wx.Frame(None)
    viewer = Viewer(frame)
    # lifeline to avoid that it gets gc'ed, makes sure the app is alive
    # as long as the viewer is alive.
    viewer.__app = app
    register_viewer(viewer)
    return viewer


if __name__ == '__main__':
    from OCC.wrapper.BRepPrimAPI import (
        BRepPrimAPI_MakeBox,
        BRepPrimAPI_MakeSphere)

    app = wx.GetApp() or wx.App(False)
    frame = ViewerWindow()
    viewer = frame.viewer

    box = BRepPrimAPI_MakeBox(1, 2, 3)
    sphere = BRepPrimAPI_MakeSphere(1)

    ais_shape1 = viewer._occ_viewer.display_topods_shape(box.Shape())
    ais_shape2 = viewer._occ_viewer.display_topods_shape(sphere.Shape())
    # ais_trihedron1 = viewer.display_trihedron((2, 2, 0), zoom_persistent=True)
    # ais_trihedron2 = viewer.display_trihedron((3, 3, 0),
    # zoom_persistent=False)
    # ais_text = viewer.display_text("Value: 1.0", (1.5, 1, 0), top_most=True)
    # ais_text = viewer.display_text("Value: 2.0", (2.0, 1, 0), top_most=True)
    # viewer.highlight(ais_shape1, "red")

    # viewer.add_clipplane((0, 0, 0.3), (0, 0, 1))
    # viewer.add_clipplane((0, 0, 0.4), (0, 0, -1))

    frame.Maximize()

    app.MainLoop()

    # some code to create a situation where GUI evaluation fails due to an
    # error in drawing
    from parapy.core import *  # noqa
    from parapy.gui import display
    from parapy.geom import Box


    class InvertedWidthBox(Box):
        @Attribute
        def width(self):
            return 1 / self.my_w

        my_w = Input()


    b = Box(1, 2, 3)  # used to set the viewer 'zoom'
    c = InvertedWidthBox(length=2, height=3, my_w=1)  # my_w can be set so a
    # failure occurs
    display((b, c))
