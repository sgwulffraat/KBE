#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""Defines the main Mesh class."""

import atexit
import operator
import os
import warnings
import weakref

from OCC.utils.mesh import _append_hypotheses
from OCC.wrapper.SMDSAbs import (
    SMDSAbs_Edge, SMDSAbs_Face, SMDSAbs_Node, SMDSAbs_Volume)
from OCC.wrapper.SMESH import SMESH_Gen, SMESH_Mesh

from parapy.core import (
    Attribute, FileWriter, Input, Part, child, descriptor_getattr,
    ensure_iterable)
from parapy.core.utilities import get_rgb_value
from parapy.core.validate import OneOf, Range
from parapy.core.widgets import CheckBox, Dropdown
from parapy.geom.occ.boolean import get_dim
from parapy.geom.occ.compound import Compound
from parapy.mesh.core.controls import Controls
from parapy.mesh.core.groups import Groups, MeshGroup
from parapy.mesh.salome.controls import SalomeHypotheses
from parapy.mesh.salome.grid import Grid, SubGrid
from parapy.mesh.salome.utilities import RGB2QuantityColor, SuppresStdOut

SMDSAbs_ENUM = [SMDSAbs_Node, SMDSAbs_Edge, SMDSAbs_Face, SMDSAbs_Volume]


def yield_controls(controls):
    """Flatten controls spec and yield individual Control objects.

    :param controls: sequence of SalomeHypotheses or Controls instances.
    :type controls: collections.Iterable[SalomeHypotheses | Controls]
    :rtype: collections.Iterable[SalomeHypotheses]
    """
    for control in controls:
        if isinstance(control, Controls):
            # expand to individual controls
            for control in yield_controls(control.controls):
                yield control
        elif hasattr(type(control), "__iter__"):
            for control in yield_controls(control):
                yield control
        else:
            yield control


def sort_controls(controls):
    """Return controls in order of their applicability. For now, controls are
    sorted against :attr:`SalomeHypotheses.DIMENSION`. Rationale: start with
    the lowest dimension first.

    :param controls: iterable of SalomeHypotheses instances.
    :type controls: collections.Iterable[SalomeHypotheses]
    :rtype: list[SalomeHypotheses]
    """
    getter = operator.attrgetter("DIMENSION")
    return sorted(controls, key=getter)


class UniDimensionalCompound(Compound):
    @property
    def TOPODIM(self):
        return get_dim(self)


def group_generator(groups):
    """Iterate over the group/compound elements, possibly nested,
    in ``groups``.

    :param groups: a single group or a collection of groups or compounds
        that is iterable.
    :rtype: collections.Iterator[parapy.mesh.core.groups.MeshGroup | parapy.geom.Compound | parapy.geom.BRep]
    """
    for group in ensure_iterable(groups):
        if isinstance(group, Groups):
            for group_ in group.groups:
                # MeshGroup instance
                yield group_
        else:
            if hasattr(group, "__iter__"):
                yield UniDimensionalCompound(group)
            else:
                yield group


def _clean_mesh_caches():
    """Clean the mesh caches, of both OCC and ParaPy. Only call when Python is
    closing down, otherwise segfaults might occur
    """
    import gc
    from OCC.utils.mesh import _CACHED_MESHES

    Mesh._mesh_cache.clear()
    _CACHED_MESHES.clear()
    gc.collect()


# This is a fix for a hanging process on Linux after some meshing has been
# done. Not sure why this works, might have to do with Pythons cleanup order
# at shutdown
atexit.register(_clean_mesh_caches)


class Mesh(FileWriter):
    """Proper documentation still missing."""

    __initargs__ = ["shape_to_mesh", "controls", "groups"]
    file_or_dir = "file"

    #: Shape to mesh (is defaulting).
    #: :type: parapy.geom.occ.drawable.DrawableShape
    shape_to_mesh = Input()

    #: Sequence of SalomeHypotheses or Controls instances.
    #: :type: typing.Sequence[parapy.mesh.core.controls.MeshControl | Controls]
    controls = Input()

    #: Sequence of MeshGroup instances.
    #: :type: parapy.mesh.core.groups.MeshGroup | collections.Iterable[parapy.mesh.core.groups.MeshGroup]
    groups = Input([])

    #: Refinements that are applied on this mesh to improve the output-mesh.
    #: :type: parapy.mesh.salome.refinements.MeshRefinement | collections.Iterable[parapy.mesh.salome.refinements.MeshRefinement]
    refinements = Input([])

    #: Limits the application of hypotheses to the dimensional value:
    #:
    #: 1. Edge meshing
    #: 2. Surface meshing
    #: 3. Volume meshing
    #:
    #: :type: int
    max_dimension = Input(3, validator=Range(1, 3))

    #: Path to mesh file. Full path including extension.
    #: :type: None | str
    filename = Input(None)

    #: Suppress output entirely?
    #: :type: str
    silent = Input(False, widget=CheckBox)

    #: Path to log file (all stdout output from SMESH is redirected here).
    #: Full path including extension.
    #: :type: None | str
    logfilename = Input(None)

    #: Controls display mode in GUI: 'shaded', 'wireframe' or 'shrink'.
    #: :type: str
    display_mode = Input("wireframe", defaulting=True,
                         validator=OneOf(Grid.DISPLAY_MODES),
                         widget=Dropdown(Grid.DISPLAY_MODES))

    #: If set to `True` compacts the mesh at the end. In general, you should
    #: not have to change this value.
    #: type: bool
    compact_mesh = Input(True, widget=CheckBox, private=True)

    #: Is set to True, ignores the algo->OnlyUnaryInput() feature and computes
    #: the mesh for the given shape only. In general you should not have
    #: to change this value.
    #: type: bool
    shape_only = Input(False, widget=CheckBox, private=True)

    #: If set to `True`, create a mesh starting from the vertices and move
    #: upwards from there to the more complex shape. In general, you should
    #: not have to change this value.
    #: type: bool
    upward = Input(False, widget=CheckBox, private=True)

    #: :type: OCC.SMESH.SMESH_Gen
    _SMESH_GEN = None

    _mesh_cache = []

    @Attribute
    def _compute_flag(self):
        flag = 0
        if self.shape_only:
            flag |= SMESH_Gen.SHAPE_ONLY
        if self.upward:
            flag |= SMESH_Gen.UPWARD
        if self.compact_mesh:
            flag |= SMESH_Gen.COMPACT_MESH
        return flag

    @Attribute(private=True)
    def SMESH_Data(self):
        """Trigger evaluation of smesh and returns various SMESH objects.

        :rtype: (OCC.SMESH.SMESH_Mesh, list[OCC.SMESH.SMESH_subMesh], list[OCC.SMESHDS.SMESHDS_GroupBase])
        """
        if self.logfilename:
            stdout = self.logfilename
        elif self.silent:
            stdout = os.devnull
        else:
            stdout = False

        gen = self._get_SMESH_Gen()
        mesh: SMESH_Mesh = gen.CreateMesh(True)
        self._register_for_clearing(mesh)

        topods_shape = self.shape_to_mesh.TopoDS_Shape

        with SuppresStdOut(stdout=stdout):
            # print "creating study with id:", study_id
            mesh.ShapeToMesh(topods_shape)
            # trigger calculation
            self.apply_controls(gen, mesh)
            SMESH_subMeshes, SMESHDS_GroupBases = self.apply_groups(mesh)
            gen.Compute(mesh, topods_shape, self._compute_flag)

        if self.logfilename:
            print("Written log file:", os.path.abspath(str(self.logfilename)))

        self.apply_refinements(mesh)

        return mesh, SMESH_subMeshes, SMESHDS_GroupBases

    @classmethod
    def _register_for_clearing(cls, msh: SMESH_Mesh):
        # Meshes need to be kept cached due to them potentially causing
        # segfaults when cleaned up. To be able to do this, and continue
        # using SMESH_Mesh objects as usual we use the following system.
        # 1. We create an alias of msh
        # 2. We cache the alias, and remove the ownership of msh
        # 3. When msh is cleaned up by Python, we clear the mesh through
        #    the alias. We cannot do this directly by putting a
        #    weakref on msh, because the closure would have a hard-reference
        #    to msh, and the weakref callback will be done AFTER the object
        #    has been cleaned up.
        alias = SMESH_Mesh.__new__(SMESH_Mesh)
        alias.this = msh.this  # the alias and msh both are a proxy
                               # to the same C++ SMESH_Mesh object

        # ensure that if hypotheses are cached, they are also kepy alive by
        # the alias!
        _append_hypotheses(msh, [])  # ensure that _hyps is present
        alias._hyps = msh._hyps  # ensure that hypotheses are cached

        msh.thisown = False  # removing the msh proxy does not affect C++

        # FIXME (TBD): Currently using this hack to make sure Salome
        #  does not crash. The meshes will be cleared, however, the mesh
        #  objects will not be collected at C++ side.

        # removing the alias does not clean the mesh object, it only
        # cleans the mesh it contains
        alias.thisown = False

        # FIXME (FT): Find out what causes the segfault, then we do not
        #  need to keep the meshes. Probably in NETGEN, the 2D_ONLY
        #  hypothesis and StdMeshers_Prism3D.
        def clear(_):
            # to prevent segfaults and
            # to prevent the test suite from getting stuck in a
            # SMESH_Hypothesis::~SMESH_Hypothesis() destructor at the end:
            for hyp in alias._hyps:
                hyp.thisown = False

            alias.Clear()
            del alias._ref

        alias._ref = weakref.ref(msh, clear)

        cls._mesh_cache.append(alias)

    @Attribute(private=True)
    def SMESH_Mesh(self):
        """Trigger evaluation of smesh and returns SMESH_MESH object on the
        entire ``shape_to_mesh``.
        API:
        http://docs.salome-platform.org/latest/tui/SMESH/classSMESH__Mesh.html

        :rtype: OCC.SMESH.SMESH_Mesh
        """
        return self.SMESH_Data[0]

    @Attribute
    def groups_flat(self):
        """Flat list of the groups in this mesh.

        :rtype: list[parapy.mesh.core.groups.MeshGroup | parapy.geom.Compound | parapy.geom.BRep]
        """
        return list(group_generator(self.groups))

    # cached here because multiple slots use it
    @Part
    def grid(self):
        """The grid generated by the mesher.

        :rtype: parapy.mesh.salome.grid.Grid
        """
        return Grid(pass_down="SMESH_Mesh")

    # =========================================================================
    # Parts
    # =========================================================================
    @Part
    def subgrid(self):
        """:rtype: parapy.mesh.salome.grid.SubGrid | collections.Iterable[parapy.mesh.salome.grid.SubGrid]"""
        return SubGrid(
            quantify=len(self.groups_flat) if self.groups_flat else 0,
            pass_down="SMESH_Mesh",
            TopoDS_Shape=self.groups_flat[child.index].TopoDS_Shape,
            label=self.groups_flat[child.index].label,
            SMESH_subMesh=self.SMESH_Data[1][child.index],
            SMESHDS_GroupBase=self.SMESH_Data[2][child.index])

    @classmethod
    def _get_SMESH_Gen(cls) -> SMESH_Gen:
        """The :class:`OCC.SMESH.SMESH_Gen` singleton that generates the
        meshes.

        :rtype: OCC.SMESH.SMESH_Gen
        """
        gen = cls._SMESH_GEN
        if not gen:
            gen = cls._SMESH_GEN = SMESH_Gen()
        return gen

    def apply_controls(self, gen: SMESH_Gen, mesh: SMESH_Mesh):
        """Iterate over all hypotheses and applies them. This is called
        before meshing.

        :param OCC.SMESH.SMESH_Gen gen: mesh generator.
        :param OCC.SMESH.SMESH_Mesh mesh: mesh instance.
        """
        # self._submeshes = []
        maxdim = self.max_dimension
        controls = ensure_iterable(self.controls)

        controls = yield_controls(controls)
        controls = sort_controls(controls)

        last_hyp_id = gen.GetANewId()
        for control in controls:
            dim = control.DIMENSION
            if dim <= maxdim:
                hyp_id = last_hyp_id + 1
                last_hyp_id = control._apply(hyp_id, gen, mesh)

                if not isinstance(last_hyp_id, int) or last_hyp_id < hyp_id:
                    msg = ("_apply() method should return int representing "
                           "last id used for assignment. Not: {!r}. "
                           "Object: {!r}")
                    raise RuntimeError(msg.format(last_hyp_id, self))

    def apply_groups(self, mesh):
        """Adds geometry-associated zones to mesh by iterating over all zones.
        This is called before meshing.

        :param OCC.SMESH.SMESH_Mesh mesh: mesh instance.
        :returns: list_of_groups, list_of_submeshes
        :rtype: (list[OCC.SMESH.SMESH_subMesh], list[OCC.SMESHDS.SMESHDS_GroupBase])
        """

        SMESH_subMeshes = []
        SMESHDS_GroupBases = []

        for group in self.groups_flat:

            if isinstance(group, MeshGroup):
                dim, label, topods_shape = (group.DIMENSION, group.label,
                                            group.TopoDS_Shape)
                color = get_rgb_value(group.color)
            else:
                dim, topods_shape = group.TOPODIM, group.TopoDS_Shape
                color = (255, 0, 0)
                label = str(topods_shape.__hash__())

            element_type = SMDSAbs_ENUM[dim]
            # GetSubMesh() assures mesh data is computed for subgrids.
            submesh = mesh.GetSubMesh(topods_shape)
            group = mesh.AddGroup(element_type, label, -1, topods_shape)
            groupds = group.GetGroupDS()
            groupds.SetColor(RGB2QuantityColor(color))

            SMESH_subMeshes.append(submesh)
            SMESHDS_GroupBases.append(groupds)

        return SMESH_subMeshes, SMESHDS_GroupBases

    def apply_refinements(self, mesh):
        """Apply the refinements on ``mesh``.

        :param OCC.SMESH.SMESH_Mesh mesh: mesh instance.
        """
        for refinement in ensure_iterable(self.refinements):
            submeshes = []
            for ref_target in group_generator(refinement.target_groups):
                if ref_target is self.shape_to_mesh:  # it is the shape-to-mesh
                    # not self.SMESH_Mesh, otherwise circular references appear
                    submeshes.append(mesh)
                else:  # it is a sub mesh
                    # check if the target is a defined group, raise if it is
                    # not
                    if ref_target not in self.groups_flat:
                        msg = ("Refinement target group {0} is not a mesh "
                               "group of this Mesh ({1}). Add this group to "
                               "the mesh if you want to apply a refinement "
                               "to it. Object: {1}.")
                        raise ValueError(msg.format(ref_target, self))

                    subshape = ref_target.TopoDS_Shape
                    submeshes.append(mesh.GetSubMesh(subshape))

            refinement._apply_refinement(mesh, submeshes)

    def get_subgrid(self, identifier, predicate=operator.eq,
                    raise_exception=True):
        """Return the SubGrid corresponding to identifier. If identifier is
        string, we search for label, if its a shape, we search for
        TopoDS_Shape.

        :param identifier: A string or shape to identify a sub-grid with.
        :type identifier: str | parapy.geom.BRep | parapy.geom.Curve | parapy.geom.Surface
        :param collections.Callable predicate: method to perform the
            test if ``identifier`` matches a certain sub-grid label.
        :param bool raise_exception: Should an exception be raised when
            ``identifier`` does not specify a legal sub-grid?
        :rtype: parapy.mesh.salome.grid.SubGrid
        :raises ValueError: If ``identifier`` is not a :class:`str` or
            a shape-like (:class:`parapy.geom.BRep`,
            :class:`parapy.geom.Curve`, :class:`parapy.geom.Surface)`.
        :raises KeyError: If ``identifier`` does not identify a subgrid in
            this Mesh instance.
        """
        try:
            identifier = descriptor_getattr(identifier, "TopoDS_Shape")
        except AttributeError:
            if isinstance(identifier, str):
                test = lambda grid: predicate(grid.label, identifier)
            else:
                msg = ("Argument `identifier` is either str or a shape (has a "
                       "TopoDS_Shape Attribute), not {}. Object: {!r}")
                raise ValueError(msg.format(identifier, self))
        else:
            test = lambda grid: (grid.TopoDS_Shape.IsPartner(identifier))

        for subgrid in self.subgrid:
            if test(subgrid):
                return subgrid

        if raise_exception:
            raise KeyError(
                "Identifier {} doesn't name any subgrid. Make sure you've "
                "defined a group "
                "using Mesh.groups input.".format(identifier))

    def write(self, pathname=None, log=True):
        """Write mesh output to ``pathname``. Only
        *.unv;*.dat;*.stl;*.sauv;*.cgns;*.med extensions are supported. CGNS
        data format used is HDF5.

        :param str|None pathname: full pathname to output file. In None,
            :attr:`filename` is used.
        :param bool log: show info log on console when done?
        :rtype: bool
        :raises ValueError: if the file in ``pathname`` is not of a valid
            extension.
        """
        pathname = self.resolve_pathname(pathname)
        _, ext = os.path.splitext(pathname)
        ext = ext[1:].lower()
        try:
            callback = self._writer_callbacks[ext]
        except KeyError:
            if ext == "su2":
                try:
                    import parapy.lib.su2
                except ImportError:
                    msg = "Please pip install the parapy.lib.su2 package first"
                    raise RuntimeError(msg)
                else:
                    msg = ("Please add 'from parapy.lib.su2 import Mesh' to "
                           "the top of your module.")
                    warnings.warn(msg)
                    callback = self._writer_callbacks[ext]
            else:
                msg = "{} is not a valid file extension, choose one of {}."
                raise ValueError(msg.format(ext, self.extensions()))

        if self.logfilename:
            stdout = self.logfilename
        elif self.silent:
            stdout = os.devnull
        else:
            stdout = False
        with SuppresStdOut(stdout=stdout):
            callback(self, pathname)
        if log:
            print("Written:", pathname)
        return True

    #: :type: dict[str, (self: Mesh, filename: str) -> T]
    _writer_callbacks = {}

    @classmethod
    def register_callback(cls, ext, callback):
        """Register a writer callback for ``ext``. Callback signature is
        ``(self: Mesh, filename: str) -> T``.

        >>> # to register writer callback for some extension "abc"
        >>> def write_abc(self, filename):
        >>>    pass
        >>> Mesh.register_callback("abc", write_abc)

        :param str ext: extension, e.g. "cgns"
        :param callback: callback function of the form
            ``(self: Mesh, filename: str) -> T``
        """
        ext = ext.lstrip(".").lower()
        cls._writer_callbacks[ext] = callback

    @classmethod
    def extensions(cls):
        """Extensions for which writer callbacks have been registered.

        >>> Mesh.extensions()
        ['stl', 'dat', 'cgns', 'sauv', 'unv', 'med']

        :rtype: list[str]
        """
        return list(cls._writer_callbacks.keys())

    @property
    def wildcard(self):
        """Wildcard used for file dialog.

        >>> from parapy.mesh.salome import Mesh
        >>> Mesh().wildcard
        'mesh file (*.stl,*.dat,*.cgns,*.sauv,*.unv,*.med) | *.stl;*.dat;*.cgns;*.sauv;*.unv;*.med;'
        """
        extensions = self.extensions()
        s1 = ",*.".join(extensions)
        s2 = ";*.".join(extensions)
        return "mesh file (*.{}) | *.{}".format(s1, s2)

    def _write_stl(self, filename):
        ascii = True
        return self.SMESH_Mesh.ExportSTL(filename, ascii)

    def _write_unv(self, filename):
        return self.SMESH_Mesh.ExportUNV(filename)

    def _write_dat(self, filename):
        return self.SMESH_Mesh.ExportDAT(filename)

    def _write_cgns(self, filename):
        """Write mesh output to ``filename``. CGNS data format used is HDF5"""
        smesh_mesh = self.SMESH_Mesh
        return smesh_mesh.ExportCGNS(filename, smesh_mesh.GetMeshDS())

    def _write_sauv(self, filename):
        flag = self.SMESH_Mesh.ExportSAUV(filename)

        # the SAUV exporter exports it as '*.sauv.med' so we need to
        # rename the file.
        real_out = "{}.med".format(filename)
        os.rename(real_out, filename)

        return flag

    def _write_med(self, filename):
        self.SMESH_Mesh.ExportMED(filename)

Mesh.register_callback("stl", Mesh._write_stl)
Mesh.register_callback("unv", Mesh._write_unv)
Mesh.register_callback("dat", Mesh._write_dat)
Mesh.register_callback("cgns", Mesh._write_cgns)
Mesh.register_callback("sauv", Mesh._write_sauv)
Mesh.register_callback("med", Mesh._write_med)
